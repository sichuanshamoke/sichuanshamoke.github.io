<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懷仁堂</title>
  
  <subtitle>Studying and Recording</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-11T16:58:51.187Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Shamoke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络第六章-应用层</title>
    <link href="http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2024-08-11T15:44:14.000Z</published>
    <updated>2024-08-11T16:58:51.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络第六章-应用层"><a href="#计算机网络第六章-应用层" class="headerlink" title="计算机网络第六章 应用层"></a>计算机网络第六章 应用层</h2><blockquote><p>计算机学科基础：计算机网络第六章应用层的学习笔记</p></blockquote><span id="more"></span><h3 id="一-网络应用模型"><a href="#一-网络应用模型" class="headerlink" title="一.网络应用模型"></a>一.网络应用模型</h3><h4 id="1-客户-服务器模型（C-S）"><a href="#1-客户-服务器模型（C-S）" class="headerlink" title="1.客户/服务器模型（C/S）"></a>1.客户/服务器模型（C/S）</h4><ul><li>在客户/服务器(Client/Server,C/S)模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求<ul><li>服务器的工作流程<ul><li>服务器处于接收请求的状态</li><li>客户机发出服务请求，并等待接收结果</li><li>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机</li></ul></li></ul></li><li>客户程序必须知道服务器程序的地址，客户机上一般不需要特殊的硬件和复杂的操作系统。</li><li>而服务器上运行的软件则是专门用来提供某种服务的程序，可同时处理多个远程或本地客户的要求。<br>系统启动后即自动调用并一直不断地运行着，被动地等待并接收来自各地客户的请求。因此，服务器程序不需要知道客户程序的地址</li><li>客户/服务器模型的主要的特征<ul><li>客户是服务请求方，服务器是服务提供方<br>常见的使用客户/服务器模型的应用包括Web、文件传输协议(FTP)、远程登录和电子邮件等</li><li>网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储/删除数据，<br>或进行其他受限的网络活动。整个网络的管理工作由少数服务器担当，因此网络的管理非常集中和方便</li><li>客户机相互之间不直接通信。例如，在Web应用中两个浏览器并不直接通信</li><li>可扩展性不佳。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限</li></ul></li></ul><h4 id="2-P2P模型"><a href="#2-P2P模型" class="headerlink" title="2.P2P模型"></a>2.P2P模型</h4><ul><li><p>P2P模型的思想是整个网络中的传输内容不再被保存在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。</p></li><li><p>在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一对计算机一一称为对等方(Per)，直接相互通信<br>P2P模型从本质上来看仍然使用客户/服务器模式，每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p></li><li>P2P模型的优点<ul><li>减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率<br>例如，播放流媒体时对服务器的压力过大，而通过P2P模型，可以利用大量的客户机来提供服务</li><li>多个客户机之间可以直接共享文档</li><li>可扩展性好，传统服务器有响应和带宽的限制，因此只能接受一定数量的请求</li><li>网络健壮性强，单个结点的失效不会影响其他部分的结点。</li></ul></li><li>P2P模型的缺点<ul><li>在获取服务的同时，还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。<br>例如，经常进行P2P下载还会对硬盘造成较大的损伤。</li><li>据某互联网调研机构统计，当前P2P程序已占互联网50%~90%的流量，使网络变得非常拥塞，<br>因此各大ISP(互联网服务提供商，如电信、网通等）通常都对P2P应用持反对态度。</li></ul></li></ul><h4 id="3-常见应用层协议端口号"><a href="#3-常见应用层协议端口号" class="headerlink" title="3.常见应用层协议端口号"></a>3.常见应用层协议端口号</h4><ul><li><img src="https://s1.ax1x.com/2023/08/12/pPuSIX9.png" alt="pPuSIX9.png"></li></ul><h3 id="二-域名系统（DNS✪）"><a href="#二-域名系统（DNS✪）" class="headerlink" title="二.域名系统（DNS✪）"></a>二.域名系统（DNS✪）</h3><h4 id="1-DNS的概述"><a href="#1-DNS的概述" class="headerlink" title="1.DNS的概述"></a>1.DNS的概述</h4><ul><li>域名系统(DNS)是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名转换为便于机器处理的IP地址。<br>互联网上提供的主机一定要有IP地址，不一定要有域名</li><li>DNS系统采用客户/服务器模型，<strong>其协议运行在UDP之上，使用53号端口</strong></li><li>从概念上可将DNS分为3部分：层次域名空间、域名服务器和解析器。</li><li>一个域名可以对应多个主机或IP地址，一个主机或IP地址也可以对应多个域名</li><li>主机需要知道自己的本地域名服务器的IP地址，本地域名服务器需要知道根服务器的IP地址</li></ul><h4 id="2-层次域名空间"><a href="#2-层次域名空间" class="headerlink" title="2.层次域名空间"></a>2.层次域名空间</h4><ul><li>因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名(Domain Name)。</li><li>域(Domain)是名字空间中一个可被管理的划分。域还可以划分为子域，而子域还可以继续划分为子域的子域，<br>这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，而各标号之间用点(“.”)隔开<img src="https://s1.ax1x.com/2023/08/11/pPn9vu9.png" alt="pPn9vu9.png"></li><li>关于域名中的标号有以下几点需要注意<ul><li>标号中的英文不区分大小写</li><li>标号中除连字符(-)外不能使用其他的标点符号</li><li>每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符</li><li>级别最低的域名写在最左边，级别最高的顶级域名写在最右边</li></ul></li><li>项级域名的分类(TLD)<ul><li>国家（地区）顶级域名：国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，“.uk”表示英国</li><li>通用顶级域名：常见的有“.com”（公司）、“.net”（网络服务机构）、“.org”（非营利性组织）和“.gov”（国家或政府部门）等</li><li>基础结构域名。这种顶级域名只有一个，即arpa，用于反向域名解析，因此又称反向域名</li></ul></li><li>在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理</li></ul><h4 id="3-域名服务器"><a href="#3-域名服务器" class="headerlink" title="3.域名服务器"></a>3.域名服务器</h4><ul><li><p>域名服务器的概述</p><ul><li>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型。</li><li>域名到IP地址的解析是由运行在域名服务器上的程序完成的，一个服务器所负责管辖的范围称为区(不以“域”为单位)<br>各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，<br>每个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。</li><li>每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息<br>当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器</li><li>DNS使用了大量的域名服务器，它们以层次方式组织，采用分布式设计的DNS<br>没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上。</li></ul></li><li><p>域名服务器的分类</p><ul><li>根域名服务器<ul><li>根域名服务器是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的IP地址</li><li><strong>根域名服务器也是最重要的域名服务器，不管是哪个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就<u>首先</u>要求助于根域名服务器</strong></li><li>因特网上有13个根域名服务器，尽管我们将这13个根域名服务器中的每个都视为单个服务器，但每个“服务器”实际上是冗余服务器的集群，以提供安全性和可靠性</li><li>根域名服务器用来管辖顶级域(如.com)，通常它并不直接把待查询的域名直接转换成IP地址，<br>而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询</li></ul></li><li>顶级域名服务器<ul><li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。</li><li>收到DNS查询请求时，就给出相应的回答(可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址)</li></ul></li><li>授权域名服务器（权限域名服务器）<ul><li>每台主机都必须在授权域名服务器处登记。为了更可靠工作，一台主机最好至少有两个授权域名服务器。</li><li>许多域名服务器都同时充当本地域名服务器和授权域名服务器。<strong>授权域名服务器总能将其管辖的主机名转换为该主机的IP地址</strong></li></ul></li><li>本地域名服务器<ul><li>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</li><li>在Windows系统中配置“本地连接”时，就需要填写DNS地址，这个地址就是本地DNS（域名服务器）的地址</li></ul></li><li>层次图片<ul><li><img src="https://s1.ax1x.com/2023/08/11/pPnPJzD.png" alt="pPnPJzD.png"></li></ul></li></ul></li></ul><h4 id="4-域名解析过程-♚"><a href="#4-域名解析过程-♚" class="headerlink" title="4.域名解析过程(♚)"></a>4.域名解析过程(♚)</h4><ul><li><p>两种查询方式</p><ul><li>递归查询（主机向本地域名服务器的查询）<ul><li>如果本地主机所询问的本地域名服务器不知道被查询域名的IP地址，<br>那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文</li></ul></li><li>迭代查询（本地域名服务器向根域名服务器的查询）<ul><li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，<br>要么告诉本地域名服务器：“你下一步应当向哪个顶级域名服务器进行查询”，然后让本地域名服务器向这个顶级域名服务器进行后续的查询</li><li>顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应向哪个权限域名服务器查询。最后，知道所要解析的域名的IP地址后，把这个结果返回给发起查询的主机。</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/11/pPnF08f.png" alt="pPnF08f.png"></li></ul></li></ul></li><li><p>高速缓存</p><ul><li>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。</li><li>当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速缓存中。</li><li>当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问。</li><li>因为主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息。</li></ul></li><li>例题<ul><li>例1：最少情况：当本地域名服务器中有该域名的DNS信息时，不需要查询任何其他域名服务器，最少发出0次DNS查询<br>最多情况：因为均采用迭代查询方式，在最坏情况下，本地域名服务器需要依次迭代地向根域名服务器、顶级域名服务器(.com)、权限域名服务器(xyz.com)、权限域名服务器(abc.xyz.com)发出DNS查询请求，因此最多发出4次DNS查询。<ul><li><img src="https://s1.ax1x.com/2023/08/11/pPnAmfx.png" alt="pPnAmfx.png"></li></ul></li><li>例2：最短本地域名服务器已有缓存，只需访问其即可（10），此时再进行浏览（10）总共20；最长需要本地服务器依次访问根服务器、顶级域名服务器、域名服务器（30），加上之前访问本地服务器的时间以及主机向网站进行浏览的时间，共50<ul><li><img src="https://s1.ax1x.com/2023/08/11/pPnAK1K.png" alt="pPnAK1K.png"></li></ul></li></ul></li></ul><h3 id="三-文件传输系统（FTP）"><a href="#三-文件传输系统（FTP）" class="headerlink" title="三.文件传输系统（FTP）"></a>三.文件传输系统（FTP）</h3><h4 id="1-FTP的工作原理"><a href="#1-FTP的工作原理" class="headerlink" title="1.FTP的工作原理"></a>1.FTP的工作原理</h4><ul><li>FTP提供交互式的访问，<strong>允许客户指明文件的类型与格式，并允许文件具有存取权限</strong>。<br>它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件</li><li>FTP采用客户/服务器的工作方式，它使用TCP可靠的传输服务。一个FTP服务器进程可同时为多个客户进程提供服务。</li><li>FTP的服务器进程由两大部分组成：一个主进程，负责接收新的请求，另外有若干从属进程，负责处理单个请求。</li><li>FTP的功能<ul><li>提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力</li><li>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</li><li>以匿名FTP的方式提供公用文件共享的能力</li></ul></li><li>FTP服务器的工作步骤<ul><li>打开熟知端口21（控制端口），使客户进程能够连接上</li><li>等待客户进程发连接请求</li><li>启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止</li><li>回到等待状态，继续接收其他客户进程的请求。</li><li>FTP服务器必须在整个会话期间保留用户的状态信息。特别是服务器必须把指定的用户账户与控制连接联系起来，<br>服务器必须追踪用户在远程目录树上的当前位置</li></ul></li></ul><h4 id="2-控制连接与数据连接"><a href="#2-控制连接与数据连接" class="headerlink" title="2.控制连接与数据连接"></a>2.控制连接与数据连接</h4><ul><li><p>FTP在工作时使用两个并行的TCP连接：一个是控制连接(服务器端口号21)，<br>一个是数据连接(服务器端口号20)。使用两个不同的端口号可以使协议更容易实现。</p></li><li><p>控制连接（端口号21）</p><ul><li>服务器监听21号端口，等待客户连接，建立在这个端口上的连接称为控制连接</li><li>控制连接用来传输控制信息(如连接请求、传送请求等)，并且控制信息都以7位ASCII格式传送，<br>FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程</li><li>控制连接并不用来传送文件，但在传输文件时也可以使用控制连接（如客户在传输中途发一个中止传输的命令），<br><strong>因此控制连接在整个会话期间一直保持打开状态</strong>。</li></ul></li><li>数据连接（端口号20）<ul><li>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。</li><li>数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，<br><strong>在传送完毕后关闭“数据传送连接”并结束运行</strong>。</li><li>数据连接的两种传输模式<ul><li>主动模式PORT<ul><li>客户端连接到服务器的21端口，登录成功后要读取数据时，客户端随机开放一个端口，并发送命令告知服务器</li><li>服务器收到PORT命令和端口号后，通过20端口和客户端开放的端口连接，发送数据。</li></ul></li><li>被动模式PASV模式<ul><li>客户端要读取数据时，发送PASV命令到服务器，服务器在本地随机开放一个端口，并告知客户端，<br>客户端再连接到服务器开放的端口进行数据传输。</li></ul></li></ul></li></ul></li><li><strong>无论是用PORT模式还是PASV模式，选择权在客户端</strong></li><li><strong>主动模式传送数据是“服务器”连接到“客户端”的端口，被动模式传送数据是“客户端”连接到“服务器”的端口。</strong></li><li><strong>TCP的20和21端口均为<u>服务器</u>的端口，客户进程的端口是客户进程自己提供的</strong></li><li>带外传送与NFS<ul><li>因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外(Out-of-band)传送的。</li><li>使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器，来回传送耗费很多时间。</li><li>网络文件系统(NFS)采用另一种思路，它允许进程打开一个远程文件，并能在该文件的某个特定位置开始读写数据。<br>此时NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件</li></ul></li></ul><h3 id="四-电子邮件"><a href="#四-电子邮件" class="headerlink" title="四.电子邮件"></a>四.电子邮件</h3><h4 id="1-电子邮件系统的组成结构"><a href="#1-电子邮件系统的组成结构" class="headerlink" title="1.电子邮件系统的组成结构"></a>1.电子邮件系统的组成结构</h4><ul><li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，<br>并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</li><li>电子邮件系统的主要的组成构件<ul><li>用户代理(User Agent)<ul><li>用户与电子邮件系统的接口。用户代理向用户提供一个很友好的接口来发送和接收邮件，<br>用户代理至少应当具有撰写、显示和邮件处理的功能。</li><li>通常情况下，用户代理就是一个运行在PC上的程序（电子邮件客户端软件），常见的有Outlook和Foxmail等。</li></ul></li><li>邮件服务器<ul><li>它的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</li><li>邮件服务器采用客户/服务器方式工作，但它必须能够同时充当客户和服务器。<ul><li>例如，当邮件服务器A向邮件服务器B发送邮件时，A就作为SMTP客户，而B是SMTP服务器</li><li>反之，当B向A发送邮件时，B就是SMTP客户，而A就是SMTP服务器</li></ul></li></ul></li><li>邮件发送协议和读取协议<ul><li>SMTP（邮箱发送协议）<ul><li><strong>用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件</strong></li><li>SMTP用的是“推”(Push)的通信方式，即用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，<br>SMTP客户将邮件“推”送到SMTP服务器</li></ul></li><li>POP3（邮件读取协议）<ul><li>用于用户代理从邮件服务器读取邮件</li><li>POP3用的是“拉”(Pull)的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li></ul></li><li>在浏览器中时，HTTP协议也可以发送或接收邮件</li></ul></li></ul></li><li>电子邮件的收发过程<ul><li>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送端邮件服务器</li><li>发送端邮件服务器将邮件放入邮件缓存队列中，等待发送</li><li>运行在发送端邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，<br>就向运行在接收端邮件服务器的SMTP服务器进程发起建立TCP连接</li><li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。<br>当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接</li><li>运行在接收端邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取</li><li>收信人打算收信时，调用用户代理，使用POP3(或IMAP)协议将自己的邮件从接收端邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）</li></ul></li></ul><h4 id="2-电子邮件格式与MIME"><a href="#2-电子邮件格式与MIME" class="headerlink" title="2.电子邮件格式与MIME"></a>2.电子邮件格式与MIME</h4><ul><li>电子邮件格式<ul><li>一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分</li><li>邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。<br>最重要的关键字是To和Subject.</li><li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。电子邮件地址的规定格式为：收件人邮箱名@邮箱所在主机的域名，如abc@cskaoyan.com，其中收信人邮箱名即用户名，在邮件服务器上唯一</li><li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容</li><li>还有一个必填的关键字是From，但它通常由邮件系统自动填入</li></ul></li><li>多用途网际邮件扩充（MIME）<ul><li>由于SMTP只能传送<strong>7位的ASCI码</strong>邮件，许多其他非英语国家的文字就无法传送，<br>且无法传送可执行文件及其他二进制对象，因此提出了MIME</li><li>MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则，可以转换格式</li><li>MIME主要包括以下三部分内容<ul><li>5个新的邮件首部字段，包括MME版本、内容描述、内容标识、传送编码和内容类型</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li></ul></li></ul></li></ul><h4 id="3-SMTP和POP3"><a href="#3-SMTP和POP3" class="headerlink" title="3.SMTP和POP3"></a>3.SMTP和POP3</h4><ul><li>简单邮件传输协议 (SMTP)<ul><li>SMTP用的是TCP连接，<strong>端口号为25</strong>，是一种提供可靠且有效的电子邮件传输的协议，<br>它控制两个相互通信的SMTP进程交换信息。</li><li>由于SMTP使用客户/服务器方式，因此负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务<br>器。</li></ul></li><li>邮局协议(POP)<ul><li>在传输层使用TCP，<strong>端口号为110</strong>，使用客户/服务器的工作方式，是一个非常简单但切能有限的邮件读取协议，<br>现任使用的是它的第3个版本POP3.</li><li>POP3采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。<br>接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序。</li><li>POP有两种工作方式：“下载并保留”和“下载并删除”。<ul><li>在“下载并保留”方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件</li><li>而使用“下载并删除”方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。</li></ul></li></ul></li></ul><h3 id="五-万维网（www✪）"><a href="#五-万维网（www✪）" class="headerlink" title="五.万维网（www✪）"></a>五.万维网（www✪）</h3><h4 id="1-www的概念与组成结构"><a href="#1-www的概念与组成结构" class="headerlink" title="1.www的概念与组成结构"></a>1.www的概念与组成结构</h4><ul><li><p>万维网是无数个网络站点和网页的集合，它们在一起构成了因特网最主要的部分<br>（因特网也包括电子邮件、Usenet和新闻组）。</p></li><li><p>万维网是一个分布式、联机式的信息存储空间，资源由一个全域“统一资源定位符”(URL)标识</p></li><li>这些资源通过超文本传输协议(HTTP)传送给使用者，而后者通过单击链接来获取资源。</li><li><strong>万维网以客户/服务器方式工作。浏览器是在用户主机上的万维网客户程序，而万维网文档所驻留的主机则运行服务器程序，这台主机称为万维网服务器。</strong><br><strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong></li><li>万维网的内核部分<ul><li>统一资源定位符(URL)<ul><li>负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL</li><li>URL的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li><li>&lt;协议&gt;指用什么协议来获取万维网文档，常见的协议有http、fp等</li><li>&lt;主机&gt;是存放资源的主机在因特网中的域名或IP地址</li><li>&lt;端口&gt;和&lt;路径&gt;有时可省略。在URL中不区分大小写。</li></ul></li><li>超文本传输协议(HTTP)<ul><li>一个应用层协议，它使用TCP连接进行可靠的传输</li><li>HTTP是万维网客户程序和服务器程序之间交互所必须严格遵守的协议</li></ul></li><li>超文本标记语言(HTML)<ul><li>一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息(包括文字、声音、图像、视频等)、格式进行描述</li><li>万维网页面的设计者可以很方便地用一个超链接从本页面的某处链接到因特网上的任何一个万维网页面，<br>并能够在自己的计算机屏幕上显示这些页面。</li></ul></li></ul></li></ul><h4 id="2-超文本传输协议（HTTP）"><a href="#2-超文本传输协议（HTTP）" class="headerlink" title="2.超文本传输协议（HTTP）"></a>2.超文本传输协议（HTTP）</h4><ul><li>HTTP的操作过程<ul><li>用户点击超链接或输网址后的过程<ul><li>1.浏览器分析URL</li><li>2.浏览器向DNS请求解析URL的IP地址</li><li>3.DNS解析出IP地址</li><li>4.浏览器与服务器建立TCP连接<ul><li>每个万维网站点都有一个服务器进程，它不断地监听TCP的端口80（默认），<br>当监听到连接请求后便与浏览器建立TCP连接</li></ul></li><li>5.浏览器发出HTTP请求</li><li>6.服务器响应HTTP请求并发送相关文件给浏览器</li><li>7.释放TCP连接</li><li>8.浏览器解释文件并将web页显示给用户</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/11/pPnG99U.png" alt="pPnG99U.png"></li></ul></li></ul></li><li>HTTP的特点<ul><li>HTTP使用TCP作为传输层协议，保证了数据的可靠传输。但HTTP本身是无连接的，通信的双方在交换HTTP报文之前不需要先建立HTTP连接。</li><li>HTTP是无状态的，可使用Cookie（存储在用户主机中的文本文件），通过识别码记录一段时间内某用户的访问记录</li><li>HTTP的两种连接方式<ul><li>非持久连接（HTTP/1.0只能使用非持续连接）<ul><li>对于非持久连接，每个网页元素对象 (如JPEG图形、Flash等) 的传输都需要单独建立一个TCP连接<br><strong>第三次握手的报文段中捎带了客户对万维网文档的请求</strong></li><li>请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间RTT</li><li>每个对象引用都导致2×RTT的开销，此外每次建立新的TCP连接都要分配缓存和变量，使万维网服务器的负担很重。</li><li>打开一个包含100张图片的web界面，需要打开和关闭101次TCP连接</li></ul></li><li>持久连接（持续连接为HTTP/1.1的默认方式）<ul><li>万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求和响应报文</li><li>分为了非流水线方式和流水线方式<ul><li>非流水线方式<ul><li>对于非流水线方式，客户在收到前一个响应后才能发出下一个请求（相当于浏览器要接收确认）<br>服务器发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源</li></ul></li><li>流水线方式<ul><li><strong>HTTP/1.1的默认方式是使用流水线的持久连接</strong>，客户每遇到一个对象引用就立即发出一个请求，<br>因而客户可以逐个地连续发出对各个引用对象的请求。</li><li>如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历1个RTT延迟，<br>而不是像非流水线方式那样，每个引用都必须有1个RTT延迟</li><li>这种方式减少了TCP连接中的空闲时间，提高了效率。</li></ul></li></ul></li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/11/pPnJiPf.png" alt="pPnJiPf.png"></li></ul></li></ul></li></ul></li><li>HTTP的报文结构<ul><li>HTTP是面向文本的，因此报文中的每个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</li><li>分为请求报文（从客户向服务器发送的请求报文）和响应报文（从服务器到客户的回答）</li><li><img src="https://s1.ax1x.com/2023/08/11/pPnh6XQ.png" alt="pPnh6XQ.png"></li></ul></li><li>例题<ul><li><img src="https://s1.ax1x.com/2023/08/12/pPuSZe1.png" alt="pPuSZe1.png"><ul><li>答案：本题还要考虑慢开始的拥塞控制算法<img src="https://s1.ax1x.com/2023/08/12/pPuSdfS.png" alt="pPuSdfS.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机网络第六章-应用层&quot;&gt;&lt;a href=&quot;#计算机网络第六章-应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络第六章 应用层&quot;&gt;&lt;/a&gt;计算机网络第六章 应用层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：计算机网络第六章应用层的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络第五章-传输层</title>
    <link href="http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2024-08-11T15:43:34.000Z</published>
    <updated>2024-08-11T16:54:16.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络第五章-传输层"><a href="#计算机网络第五章-传输层" class="headerlink" title="计算机网络第五章 传输层"></a>计算机网络第五章 传输层</h2><blockquote><p>计算机学科基础：计算机网络第五章的学习笔记</p></blockquote><span id="more"></span><h3 id="一-传输层提供的服务（✠）"><a href="#一-传输层提供的服务（✠）" class="headerlink" title="一.传输层提供的服务（✠）"></a>一.传输层提供的服务（✠）</h3><h4 id="1-传输层的功能（✠）"><a href="#1-传输层的功能（✠）" class="headerlink" title="1.传输层的功能（✠）"></a>1.传输层的功能（✠）</h4><ul><li><p>传输层的概述</p><ul><li>从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，<br><strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong></li><li><strong>在通信子网中没有传输层，传输层只存在于通信子网以外的主机中</strong></li><li>传输层向高层用户屏蔽了低层网络核心的细节(如网络拓扑、路由协议等)，<br>它使应用进程看见的是在两个传输层实体之间好像有一条端到端的逻辑通信信道，这条逻辑通信信道对上层的表现却因传输层协议不同而有很大的差别。</li><li>当传输层采用面向连接的TCP时，尽管下面的网络是不可靠的（只提供尽最大努力的服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。<br>但当传输层采用无连接的UDP时，这种逻辑通信信道仍然是一条不可靠信道。</li></ul></li><li><p>传输层的功能</p><ul><li>传输层位于网络层之上，它为运行在<strong>不同主机上的进程之间</strong>提供了逻辑通信，而网络层提供<strong>主机之间</strong>的逻辑通信。<ul><li>逻辑通信”的意思是：传输层之间的通信好像是沿水平方向传送数据，<br>但事实上这两个传输层之间并没有一条水平方向的物理连接</li></ul></li><li>复用和分用<ul><li>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据</li><li>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</li><li>注意：网络层也有复用分用的功能，但网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，<br>分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。</li></ul></li><li>传输层还要对收到的报文进行差错检测（<strong>首部和数据部分</strong>）<ul><li>而网络层只检查IP数据报的首部，不检验数据部分是否出错</li></ul></li><li>提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。<ul><li>而网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如虚电路，要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）</li></ul></li></ul></li></ul><h4 id="2-传输层的寻址与端口（✪）"><a href="#2-传输层的寻址与端口（✪）" class="headerlink" title="2.传输层的寻址与端口（✪）"></a>2.传输层的寻址与端口（✪）</h4><ul><li>端口的作用<ul><li>端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，<br>以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li><li>端口是传输层服务访问点(TSAP)，它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，<br>只不过IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程。<ul><li>数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口。</li></ul></li><li>在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。<ul><li>硬件端口是不同硬件设备进行交互的接口，</li><li>而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。</li></ul></li></ul></li><li>端口号<ul><li>应用进程通过端口号进行标识，端口号长度为16bit，能够表示65536($2^{16}$)个不同的端口号。</li><li>端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，<br>在因特网中不同计算机的相同端口号是没有联系的。</li><li>端口号的分类（根据范围）<ul><li>服务器端使用的端口号（0~49151）<ul><li>熟知端口号，数值为0~1023<ul><li>IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道</li><li><img src="https://s1.ax1x.com/2023/08/08/pPV2lCj.png" alt="pPV2lCj.png"></li></ul></li><li>登记端口号，数值为1024~49151<ul><li>它是供没有熟知端口号的应用程序使用的，使用这类端口号必须在IANA登记，以防止重复。</li></ul></li></ul></li><li>客户端使用的端口号，数值为49152~65535<ul><li>由于这类端口号仅在客户进程运行时才动态地选择，因此又称短暂端口号（也称临时端口）</li><li>通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程以后使用。</li></ul></li></ul></li></ul></li><li>套接字<ul><li>在网络中通过IP地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，<br>端口号拼接到IP地址即构成套接字Socket。</li><li>在网络中采用发送方和接收方的套接字来识别端点。套接字实际上是一个通信端点，<strong>套接字Socket=(IP地址：端口号)</strong><br><strong>它唯一地标识网络中的一台主机和其上的一个应用（进程）</strong></li></ul></li></ul><h4 id="3-无连接服务与面向连接服务（✪）"><a href="#3-无连接服务与面向连接服务（✪）" class="headerlink" title="3.无连接服务与面向连接服务（✪）"></a>3.无连接服务与面向连接服务（✪）</h4><ul><li>面向连接服务与无连接服务<ul><li>面向连接服务就是在通信双方进行通信之前，必须先建立连接，<br>在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接</li><li>无连接服务是指两个实体之间的通信不需要先建立好连接，<br>需要通信时，直接将信息发送到“网络”中，让该信息的传递在网上尽力而为地往目的地传送。</li></ul></li><li>TCP协议与UDP协议<ul><li>面向连接的传输控制协议(TCP)<ul><li>TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</li><li>采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道</li><li>TCP不提供广播或组播服务</li><li>TCP增加了许多开销，如确认（可靠传输）、流量控制、计时器及连接管理等。<br>这不仅使协议数据单元的头部增大很多，还要占用许多的处理机资源。</li><li>TCP主要适用于可靠性更重要的场合，如文件传输协议(FTP)、超文本传输协议(HTTP)、远程登录(TELNET)等。</li></ul></li><li>无连接的用户数据报协议(UDP)<ul><li>UDP是一个无连接的非可靠传输层协议，采用UDP时，传输层向上提供的是一条不可靠的逻辑信道</li><li>UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认。</li><li>它在IP之上仅提供两个附加服务：多路复用和对数据的错误检查</li><li>如果用户应用程序使用UDP进行数据传输，那么必须在传输层的上层即应用层提供可靠性方面的全部工作。</li><li>由于UDP比较简单，因此执行速度比较快、实时性好。<br>使用UDP的应用主要包括小文件传送协议(TFTP)、DNS、SNMP和实时传输协议(RTP)</li></ul></li><li>例题<ul><li>注：<strong>UDP首部有8B，TCP首部最少20B</strong>，此时选D<ul><li><img src="https://s1.ax1x.com/2023/08/10/pPeY1wq.png" alt="pPeY1wq.png"></li></ul></li></ul></li></ul></li><li>IP数据报和UDP数据报的区别<ul><li>IP数据报在网络层要经过路由的存储转发</li><li>而UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，<br>UDP数据报的信息对路由是不可见的</li></ul></li><li>TCP和网络层虚电路的区别<ul><li>TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见</li><li>虚电路所经过的交换结点都必须保存虚电路状态信息。在网络层若采用虚电路方式，则无法提供无连接服务<br>而传输层采用TCP不影响网络层提供无连接服务。</li></ul></li></ul><h3 id="二-UDP协议"><a href="#二-UDP协议" class="headerlink" title="二.UDP协议"></a>二.UDP协议</h3><h4 id="1-UDP数据报"><a href="#1-UDP数据报" class="headerlink" title="1.UDP数据报"></a>1.UDP数据报</h4><ul><li>UDP概述<ul><li>UDP仅在IP的数据报服务之上增加了两个最基本的服务：复用和分用以及差错检测</li><li>UDP不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，所有维护可靠性的工作可由用户在应用层来完成<br>应用开发者可根据应用的需求来灵活设计自己的可靠性机制</li><li>UDP是面向报文的。发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，<br>既不合并，也不拆分，而是保留这些报文的边界</li><li>接收方UDP对IP层交上来UDP数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。</li><li>报文不可分割，是UDP数据报处理的最小单位<ul><li>因此，应用程序必须选择合适大小的报文，若报文太长，UDP把它交给IP层后，可能会导致分片</li><li>若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，两者都会降低IP层的效率。</li></ul></li></ul></li><li>UDP的优点<ul><li>无须建立连接：因此UDP不会引入建立连接的时延</li><li>无连接状态：UDP不维护连接状态，也不跟踪这些参数。<br>因此，某些专用应用服务器使用UDP时，一般都能支持更多的活动客户机</li><li>分组首部开销小：TCP有20B的首部开销，而UDP仅有8B的开销。</li><li>应用层能更好地控制要发送的数据和发送时间：UDP没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率<br>某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而UDP正好满足这些应用的需</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信</li></ul></li><li>UDP的应用场景<ul><li>UDP常用于一次性传输较少数据的网络应用，如DNS、SNMP等，<br>因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。</li><li>UDP也常用于多媒体应用（如IP电话、实时视频会议、流媒体等），显然，可靠数据传输对这些应用来说并不是最重要的；<br>但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。</li><li>适用于客户机/服务器领域，不适用于远程登录</li></ul></li><li>UDP数据报（UDP首部和用户数据）<ul><li>UDP首部（<strong>有8B，由4个字段组成，每个字段的长度都是2B</strong>）<ul><li>源端口：源端口号。<strong>在需要对方回信时选用，不需要时可用全0</strong></li><li>目的端口：目的端口号。<strong>这在终点交付报文时必须使用到，是实现分用服务的依据</strong></li><li>长度：UDP数据报的长度（包括首部和数据），其最小值是8（仅有首部）</li><li>校验和：检测UDP数据报在传输中是否有错。有错就丢弃。<br><strong>该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0</strong></li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/08/pPV4mtO.png" alt="pPV4mtO.png"></li></ul></li><li>UDP数据报传输的流程（分用服务）<ul><li>当传输层从IP层收到UDP数据报时，<strong>就根据首部中的目的端口</strong>，把UDP数据报通过相应的端口上交给应用进程</li><li>如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于端口号的应用进程）<br>那么就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/08/pPV43nI.png" alt="pPV43nI.png"></li></ul></li></ul></li></ul></li></ul><h4 id="2-UDP校验"><a href="#2-UDP校验" class="headerlink" title="2.UDP校验"></a>2.UDP校验</h4><ul><li><p><strong>UDP的校验和功能不是必需的，可以不使用，若源主机不想计算校验和，则该校验和字段应为全0</strong></p></li><li><p>伪首部的概念</p><ul><li><p>在计算校验和时，要在UDP数据报之前增加12B的伪首部</p></li><li><p>伪首部并不是UDP的真正首部。只是在计算校验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。<br>校验和就是按照这个临时的UDP数据报来计算的</p></li><li><p>伪首部既不向下传送又不向上递交，而只是为了计算校验和</p></li><li>UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，<br><strong>但不同的是，IP数据报的校验和只检验IP数据报的首部，但UDP的校验和则检查首部和数据部分</strong></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/08/pPV4O8e.png" alt="pPV4O8e.png"></li></ul></li></ul></li><li><p>UDP校验和的过程（<strong>UDP校验和的计算方法是二进制反码运算求和再取反</strong>）</p><ul><li>发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。</li><li>若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节（但此字节不发送）<ul><li>如UDP数据报的长度是15B(不含伪首部），因此需要添加一个全0字节</li></ul></li><li><strong>然后按二进制反码计算出这些16位字的和，将此和的二进制反码写入校验和字段，去掉伪首部之后发送</strong><ul><li>例如：如果校验和的计算结果恰好为0，那么将校验和字段置为全1。</li></ul></li><li>接收方把收到的UDP数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，<br>按二进制反码求这些16位字的和。</li><li>当无差错时其结果应为全1，否则就表明有差错出现，接收方就应该丢弃这个UDP数据报，<br>或向上交给应用层附上出差错的报告</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/08/pPVILXd.png" alt="pPVILXd.png"></li></ul></li></ul></li><li>注意事项<ul><li>校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节，但是此字节和伪首部一样，是不发送的</li><li>如果UDP校验和校验出UDP数据报是错误的，那么可以丢弃，<br>也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报</li><li>通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，<br>还可以检查IP数据报的源IP地址和目的地址。</li></ul></li></ul><h3 id="三-TCP协议（✪）"><a href="#三-TCP协议（✪）" class="headerlink" title="三.TCP协议（✪）"></a>三.TCP协议（✪）</h3><h4 id="1-TCP协议的特点"><a href="#1-TCP协议的特点" class="headerlink" title="1.TCP协议的特点"></a>1.TCP协议的特点</h4><ul><li>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题</li><li>TCP协议的特点<ul><li>TCP是面向连接的传输层协议，TCP连接是一条逻辑连接（虚连接）</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点到点的（一对一）</li><li>TCP提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序</li><li>TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，<br>为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据<ul><li>发送缓存暂存的数据<ul><li>发送应用程序传送给发送方TCP准备发送的数据</li><li>TCP已发送但尚未收到确认的数据</li></ul></li><li>接收缓存暂存的数据<ul><li>按序到达但尚未被接收应用程序读取的数据</li><li>不按序到达的数据</li></ul></li></ul></li><li>TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流。</li></ul></li><li>TCP和UDP在发送报文时所采用的方式完全不同<ul><li>UDP报文的长度由发送应用进程决定</li><li>TCP报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。</li><li>如果应用进程传送到TCP缓存的数据块太长，TCP就把它划分得短一些再传送</li><li>如果太短，TCP也可以等到积累足够多的字节后再构成报文段发送出去</li></ul></li></ul><h4 id="2-TCP报文段"><a href="#2-TCP报文段" class="headerlink" title="2.TCP报文段"></a>2.TCP报文段</h4><ul><li>TCP传送的数据单元称为报文段。TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答</li><li>一个TCP报文段分为首部和数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中</li><li>首部的前20B是固定的。TCP首部最短为20B，后面有4N字节是根据需要而增加的选项，长度为4B的整数倍；<br>加上可选字段后，TCP首部最大为60B</li><li>TCP报文字段<ul><li>源端口和目的端口：各占2B<ul><li>端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口实现<ul><li>注：IP/UDP数据报和TCP报文都是源在前目的在后<br>只有MAC帧是目的在前源在后</li></ul></li></ul></li><li>序号：占4B，范围为$0\sim 2^{32}-1$，共$2^{32}$个序号<ul><li><strong>TCP是面向字节流的（即TCP传送时是逐个字节传送的），所以TCP连接传送的字节流中的每个字节都按顺序编号</strong></li><li>序号字段的值指的是本报文段所发送的数据的<strong>第一个字节的序号</strong></li><li>如：一报文段的序号字段值是301，而携带的数据共有100B，表明本报文段的数据的最后一个字节的序号是400<br>因此下一个报文段的数据序号应从401开始。</li></ul></li><li>确认号：占4B<ul><li><strong>期望收到对方下一个报文段的第一个数据字节的序号</strong></li><li><strong>若确认号为N，则表明到序号N-1为止的所有数据都已正确收到</strong></li><li>例：B正确收到了A发送过来的一个报文段，其序号字段是501，而数据长度是200B(序号501~700)，<br>这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701</li></ul></li><li>数据偏移（即首部长度）：占4位（bit）<ul><li>指出TCP报文段的数据起始处距离TCP报文段的起始处有多远（因为TCP首部有可选选项）</li><li>“数据偏移”的单位是4B，由于4位二进制数能表示的最大值为15，因此TCP首部的最大长度为60B</li></ul></li><li>保留。占6位，保留为今后使用，但目前应置为0</li><li>6个控制位（每个一位，共占6位）<ul><li>紧急位URG。当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，<br>应尽快传送（相当于高优先级的数据）。但URG需要和首部中紧急指针字段配合使用，<br>即数据从第一个字节到紧急指针所指字节就是紧急数据。（在发送缓存中可以插队）</li><li>确认位ACK。仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。<br>TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.</li><li>推送位PSH(Push)。接收方TCP收到PSH=1的报文段，就尽快地交付给接收应用进程，<br>而不再等到整个缓存都填满了后再向上交付。</li><li>复位位RST(Reset)。当RST=1时，表明TCP连接中出现严重差错（如主机崩溃或其他原因），<br>必须释放连接，然后再重新建立运输连接。</li><li>同步位SYN。当SYN=1时表示这是一个连接请求或连接接受报文。<br>当SYN=1，ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使用SYN=1,ACK=1.</li><li>终止位FIN(Finish)。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li></ul></li><li>窗口。占2B，范围为$0\sim2^{16}-1$<ul><li><strong>现在允许对方发送的数据量，是接收方让发送方设置其发送窗口的依据</strong></li><li><strong>若以发送方的窗口值来看，则表示发送端收到一个确认之前可以发送的字节数</strong></li><li>例如，设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的一方还要接收1000字节数据(字节序号为701~1700)的接收缓存空间</li><li>例<ul><li><strong>常常使接收方没有接收到之前某个报文段的数据就发送了确认（接收窗口）来考察，此题还能发送的数据为接收窗口减已发送未收到数据=300</strong>，选C<ul><li><img src="https://s1.ax1x.com/2023/08/10/pPe0MCt.png" alt="pPe0MCt.png"></li></ul></li></ul></li></ul></li><li>校验和。占2B。<ul><li>校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部（<strong>只需将UDP伪首部的协议字段的17改成6,UDP长度字段改成TCP长度，其他的和UDP一样</strong>）。</li></ul></li><li>紧急指针。占2B。</li><li>紧急指针仅在URG=1时才有意义，它指出在本报文段中紧急数据共有多少字节（紧急数据在报文段数据的最前面）</li><li>选项。长度可变。<ul><li>TCP最初只规定了一种选项，即最大报文段长度（Maximum Segment Size,MSS).MSS是TCP报文段中的数据字段的最大长度（注意仅仅是数据字段）。</li></ul></li><li>填充。这是为了使整个首部长度是4B的整数倍。</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPZgNGj.png" alt="pPZgNGj.png"></li></ul></li></ul><h4 id="3-TCP连接管理（♚）"><a href="#3-TCP连接管理（♚）" class="headerlink" title="3.TCP连接管理（♚）"></a>3.TCP连接管理（♚）</h4><ul><li>TCP连接的端口即为套接字(Socket)或插口，每条TCP连接唯一地被通信的两个端点（即两个套接字）确定</li><li>TCP连接的建立采用客户/服务器模式。主动发起连接建立的应用进程称为客户(Client)<br>而被动等待连接建立的应用进程称为服务器(Server)。</li><li>TCP连接的建立（三次握手）<ul><li>客户端发送请求连接报文段，此时无应用层数据<br>SYN=1，seq=x</li><li>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据<br>SYN=1，ACK=1，seq=y，ack=x+1</li><li>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。<br>ACK=1，seq=x+1，ack=y+1</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPZWZIU.png" alt="pPZWZIU.png"></li></ul></li></ul></li><li>TCP连接的释放（四次挥手）<ul><li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。<br>FIN=1，seq=u</li><li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了，此时为半关闭状态。<br>ACK=1，seq=v，ack=u+1</li><li>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接<br>FIN=1，ACK=1，seq=w，ack=u+1</li><li>客户端回送一个确认报文段，<strong>再等到时间等待计时器设置的2MSL（最长报文段寿命）后</strong>，连接彻底关闭<br>ACK=1，seq=u+1，ack=w+1（此时客户机的状态为TIME-WAIT）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPZWBLt.png" alt="pPZWBLt.png"></li></ul></li></ul></li><li>例题<ul><li>例1：<strong>总结：回复字段中的序号为上一个字段的ack；回复字段的ack为上一个字段的序号+数据载荷</strong>，如本题选B<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPeJfoV.png" alt="pPeJfoV.png"></li></ul></li><li>例2：至少的时间时，此时服务器端的两次发送可以合并为一次，由图像可知，客户端时间为：RTT+2MSL；<br>服务器端时间为：1.5RTT。此题选D<ul><li><img src="https://s1.ax1x.com/2023/08/10/pPeN3GT.png" alt="pPeN3GT.png"></li></ul></li><li>例3：甲与乙建立TCP连接时发送的SYN段中的序号为1000，则在数据传输阶段所用起始序号为1001，在断开连接时，甲发送给乙的FIN段中的序号为5001，在无任何重传的情况下，甲向乙已经发送的应用层数据的字节数为5001-1001=4000。<ul><li><img src="https://s1.ax1x.com/2023/08/10/pPeNgLd.png" alt="pPeNgLd.png"></li></ul></li></ul></li></ul><h4 id="4-TCP可靠传输"><a href="#4-TCP可靠传输" class="headerlink" title="4.TCP可靠传输"></a>4.TCP可靠传输</h4><ul><li>TCP提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样<br>TCP使用了校验、序号、确认和重传等机制来达到这一目的。<strong>其中，TCP的校验机制与UDP校验一样，只需要将17改为6</strong></li><li>序号<ul><li>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，<br>序号建立在传送的字节流之上，而不建立在报文段之上</li><li>TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。</li></ul></li><li>确认<ul><li>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传</li><li><strong>TCP采用了对报文段确定的机制</strong></li><li>TCP默认使用累积确认，即TCP只确认数据流中至第一个丢失字节为止的字节。</li></ul></li><li>重传<ul><li>超时重传<ul><li>TCP每发送一个报文段，就对这个报文段设置一次计时器。<br>计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段</li><li>TCP采用一种自适应算法，TCP保留了RTT的一个加权平均往返时间RTTs<br>它会随新测量RTT样本值的变化而变化</li><li>超时计时器设置的超时重传时间(RTO)应略大于RTTs,但也不能大太多，否则当报文段丢失时，TCP不能很快重传，导致数据传输时延大。</li></ul></li><li>快速重传<ul><li>每当比期望序号大的<u>失序报文</u>段到达时接收方时，发送一个冗余ACK给发送方（丢失报文之前正确接收到的报文的ACK）</li><li>当发送方收到三个这样的ACK后，立即重传之前丢失的报文，即为快速重传</li><li>例<ul><li>本题选C<img src="https://s1.ax1x.com/2023/08/09/pPeJxJO.png" alt="pPeJxJO.png"></li></ul></li></ul></li></ul></li></ul><h4 id="5-TCP流量控制（♚）"><a href="#5-TCP流量控制（♚）" class="headerlink" title="5.TCP流量控制（♚）"></a>5.TCP流量控制（♚）</h4><ul><li><p>TCP提供流量控制服务来消除发送方由于发送速率太快使接收方缓存区溢出的可能性<br>TCP提供一种基于滑动窗口协议的流量控制机制，发送方发送数据的量由接收方决定</p></li><li><p>在流量控制中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口rwnd<br>即调整TCP报文段首部中的“窗口”字段值，来限制发送方向网络注入报文的速率</p><ul><li>发送方根据其对当前网络拥塞程度的估计而确定的窗口值，这称为拥塞窗口cwnd，其大小与网络的带宽和时延密切相关</li></ul></li><li><p>TCP流量控制的过程</p><ul><li>接收方设置确认报文段首部的窗口字段来将rwnd通知给发送方，rwnd即接收方允许连续接收的最大能力，单位是字节。</li><li>发送方总是根据最新收到的rwmd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内<br>保证不会使接收方的接收缓存溢出。</li><li>发送方的发送窗口的实际大小取rwnd和cwmd中的最小值</li><li>示例<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPZ5x3D.png" alt="pPZ5x3D.png"></li></ul></li></ul></li><li>传输层和数据链路层的流量控制的区别<ul><li>传输层定义端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制</li><li>数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化</li></ul></li></ul><h4 id="6-TCP拥塞控制（♚）"><a href="#6-TCP拥塞控制（♚）" class="headerlink" title="6.TCP拥塞控制（♚）"></a>6.TCP拥塞控制（♚）</h4><ul><li><p>拥塞控制的概念</p><ul><li>拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</li><li>在拥塞控制中，由发送方自己通过检测网络状况来决定发送数据的量</li><li>发送方的发送窗口的实际大小取rwnd和cwmd中的最小值</li><li>拥塞的定义<ul><li>当对资源需求的总和&gt;可用资源时，会出现拥塞</li><li>出现拥塞时，端点并不了解拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。</li><li>此时网络中有许多资源同时呈现供应不足→网络性能变坏→网络吞吐量将随输入负荷增大而下降</li></ul></li><li>拥塞控制与流量控制的区别<ul><li>拥塞控制是让网络能够承受现有的网络负荷，是一个<strong>全局性</strong>的过程，<br>涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往是指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），<br>它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>拥塞控制和流量控制都通过控制发送方发送数据的速率来达到控制效果</li></ul></li></ul></li><li><p>TCP协议的窗口</p><ul><li>接收窗口：接收方根据接受缓存设置的窗口值，并告知给发送方，反映接收方容量</li><li>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量</li><li>发送窗口的<strong>上限</strong>取决于接收窗口和拥塞窗口中最小的那个</li><li>注意区分接收缓存与接收窗口（接收缓存&gt;=接收窗口，接收窗口=接收缓存-在缓存中的数据）<ul><li>例：发送窗口的上限值=min{接收窗口，拥塞窗口}。4个RTT后，乙收到的数据全部存入缓存，不被取走，<br>此时接收窗口只剩下1KB(16-1-2-4-8=1)的空间，虽然拥塞窗口此时为16，但是发送窗口是取其中较小的值（接收窗口1KB）选A<ul><li><img src="https://s1.ax1x.com/2023/08/10/pPeUgpT.png" alt="pPeUgpT.png"></li></ul></li></ul></li></ul></li><li><p>拥塞控制的4种算法（计算某时刻的拥塞窗口大小）</p><ul><li><p>慢开始和拥塞避免算法</p><ul><li>慢开始和拥塞避免算法的概念<ul><li>慢开始算法<ul><li>在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段，<br>目的是试探一下网络的拥塞情况（初始值由最大段长MSS决定）</li><li>之后每经过一个传输轮次(即往返时延RTT)，cwnd就会加倍，即cwnd的值随传输轮次指数规律增长。</li><li>慢开始一直把cwnd增大到一个规定的慢开始门限ssthresh（阈值），然后改用拥塞避免算法</li></ul></li><li>拥塞避免算法<ul><li>拥塞避免算法的思路是让拥塞窗口cwmd缓慢增大，每经过一个往返时延RTT就把发送方的拥塞窗口cwmd加1，<br>而不是加倍，使拥塞窗口cwmd按线性规律缓慢增长（即加法增大）</li><li>根据cwnd的大小执行不同的算法，可归纳如下<ul><li>当cwnd&lt;ssthresh时，使用慢开始算法</li><li>当cwmd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd=ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法</li></ul></li></ul></li><li>乘法减少和加法增加<ul><li>乘法减小<ul><li>不论是在慢开始阶段还是在拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞），<br>就把慢开始门限值ssthresh设置为当前拥塞窗口的一半（并执行慢开始算法）</li><li>当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入网络的分组数。</li></ul></li><li>加法增加<ul><li>执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个RTT)，就把拥塞窗口cwd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞</li></ul></li></ul></li></ul></li><li>慢开始和拥塞避免算法的执行过程<ul><li><strong>初始时，拥塞窗口设置为1，即cwnd=1</strong>，慢开始门限置为16，即ssthresh=16<br><strong>（初始值由最大段长MSS决定，一般为1）</strong></li><li>慢开始阶段，cwnd的初值为1，以后发送方每收到一个确认ACK，cwnd值加1，<br>也即经过每个传输轮次(RTT)，cwnd呈<strong>指数规律增长</strong>（第一次RTT后为2，第二次RTT后为4）</li><li><strong>注意区分第n次传输时与第n个RTT之后（第n个RTT内发送的都得到应答）的拥塞窗口大小的区别</strong></li><li>当拥塞窗口cwnd增长到<u>慢开始门限</u>ssthresh时(即当cwnd=l6时)，就改用拥塞避免算法，cwmd按<strong>线性规律增长</strong>（16,17,18……）<ul><li><strong>在慢开始（指数级增长）阶段，若2cwnd&gt;ssthresh，则下一个RTT后的cwmd等于ssthresh，而不等于2cwnd</strong><br><strong>即cwmd不能跃过ssthresh值。</strong></li><li><strong>如在第16个轮次时cwmd=8、ssthresh=12，则在第17个轮次时cwnd=12，而不等于16。</strong></li></ul></li><li><strong>假定cwmd=24时网络出现超时，更新ssthresh值为I2(即变为超时时cwnd值的一半)，cwnd重置为1，并执行慢开始算法，当cwmd=I2时，改为执行拥塞避免算法，待增加到超时时又重新慢开始</strong></li><li>图片（掌握过程）（注：MSS的值决定了初始的拥塞窗口大小的值，如果为2则为：2/4/8……）<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPZqe2V.png" alt="pPZqe2V.png"></li></ul></li><li>例题<ul><li>例1：<strong>注意：此时问的是第13次传输时拥塞窗口的大小，即为第13个次序时窗口的值，如果问的是第13次RTT后窗口的值，那么此时的值为第14个次序时窗口的值</strong>（1/2/4/8/9/10/11/12/1/2/4/6/7，选C）<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPeJMa6.png" alt="pPeJMa6.png"></li></ul></li><li>例2：最长的时间显然就是此时已经在门限值之上并一直做加法增加的情况，（32-8）*2=48，选D<ul><li><img src="https://s1.ax1x.com/2023/08/10/pPeNiIP.png" alt="pPeNiIP.png"></li></ul></li></ul></li></ul></li></ul></li><li><p>快重传和快恢复算法</p><ul><li><p>快重传</p><ul><li>快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测<br>丢了包当然意味着网络可能出现了拥塞</li><li>快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段</li><li>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，<br>而不必等待那个报文段设置的重传计时器超时</li></ul></li><li><p>快恢复算法</p><ul><li>当发送方连续收到三个冗余ACK（即重复确认）时，执行“乘法减小”算法，<br>把慢开始门限ssthresh设置为此时发送方cwnd的一半。这是为了预防网络发生拥塞。</li><li><p><strong>此时跳过拥塞窗口cwnd从1起始的慢开始过程，把cwnd值设置为慢开始门限ssthresh改变后的数值，</strong><br>然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/08/09/pPZLwlV.png" alt="pPZLwlV.png"></li></ul></li></ul></li></ul></li><li><p>两组算法的适用情况</p><ul><li><strong>在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法（只要看到题干中有超时就用此方法）</strong><ul><li>例：此时使用的是慢开始与拥塞避免算法，注意题干中为：这些报文段均得到确认之后，即为1,2,4,8,16（选B）<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPeGBv9.png" alt="pPeGBv9.png"></li></ul></li></ul></li><li><strong>当发送方接收到冗余ACK时，采用快重传和快恢复算法</strong><ul><li>例：此时使用的是快重传与快恢复算法，注意题干中为：这些报文得到确认之后，即为17,18,19,20,21（选D）<ul><li><img src="https://s1.ax1x.com/2023/08/09/pPeGvvj.png" alt="pPeGvvj.png"></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机网络第五章-传输层&quot;&gt;&lt;a href=&quot;#计算机网络第五章-传输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络第五章 传输层&quot;&gt;&lt;/a&gt;计算机网络第五章 传输层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：计算机网络第五章的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络第四章-网络层</title>
    <link href="http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2024-08-11T15:43:04.000Z</published>
    <updated>2024-08-11T16:48:17.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络第四章-网络层"><a href="#计算机网络第四章-网络层" class="headerlink" title="计算机网络第四章-网络层"></a>计算机网络第四章-网络层</h2><blockquote><p>计算机学科基础：计算机网络第四章网络层的学习笔记</p></blockquote><span id="more"></span><h3 id="一-网络层的功能（✠）"><a href="#一-网络层的功能（✠）" class="headerlink" title="一.网络层的功能（✠）"></a>一.网络层的功能（✠）</h3><h4 id="1-异构网络互联"><a href="#1-异构网络互联" class="headerlink" title="1.异构网络互联"></a>1.异构网络互联</h4><ul><li>定义<ul><li>网络互连是指将两个以上的计算机网络，通过一定的方法，用一些中间设备（又称中继系统）相互连接起来，<br>以构成更大的网络系统。</li><li>网络互连通常是指用路由器进行网络互连和路由选择</li><li>互联网在网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</li></ul></li><li>中继系统的分类<ul><li>物理层中继系统：转发器，集线器。</li><li>数据链路层中继系统：网桥或交换机。</li><li>网络层中继系统：路由器。</li><li>网络层以上的中继系统：网关</li></ul></li><li>TCP/IP体系在网络互连上采用的做法是在网络层采用标准化协议，但相互连接的网络可以是异构的<br>异构是指物理层与数据链路层均不同</li></ul><h4 id="2-路由与转发"><a href="#2-路由与转发" class="headerlink" title="2.路由与转发"></a>2.路由与转发</h4><ul><li>路由选择（确定哪一条路径）<ul><li>按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由</li><li>根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表</li></ul></li><li>分组转发（当一个分组到达时所采取的动作）<ul><li>路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li><li>路由表是根据路由选择算法得出的，而转发表是从路由表得出的。<br>在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</li></ul></li></ul><h4 id="3-SDN的基本概念"><a href="#3-SDN的基本概念" class="headerlink" title="3.SDN的基本概念"></a>3.SDN的基本概念</h4><ul><li>软件定义网络采用集中式的控制平面和分布式的数据平面，两个平面相互分离，|<br>控制平面利用控制-数据接口对数据平面上的路由器进行集中式控制，方便软件来控制网络</li><li>通过Openflow协议（也可以通过其他途径）将转发表（在SDN中称为流表）下发给路由器。<br>路由器的工作很单纯，即收到分组、查找转发表、转发分组。</li><li>SDN提供的编程接口称为北向接口，北向接口提供了一系列丰富的API，<br>开发者可以在此基础上设计自己的应用，而不必关心底层的硬件细节。</li><li>SDN控制器和转发设备建立双向会话的接口称为南向接口，通过不同的南向接口协议(如Openflow)，<br>SDN控制器就可兼容不同的硬件设备，同时可以在设备中实现上层应用的逻辑。</li><li>SDN控制器集群内部控制器之间的通信接口称为东西向接口，用于增强整个控制平面的可靠性和可拓展性</li><li>SDN的优点：<ul><li>全局集中式控制和分布式高速转发，既利于控制平面的全局优化，又利于高性能的网络转发</li><li>灵活可编程与性能的平衡，控制和转发功能分离后，使得网络可以由专有的自动化工具以编程方式配置</li><li>降低成本，控制和数据平面分离后，尤其是在使用开放的接口协议后，就实现了网络设备的制造与功能软件的开发相分离，从而有效降低了成本。</li></ul></li><li>SDN的问题<ul><li>安全风险，集中管理容易受攻击，如果崩溃，整个网络会受到影响。</li><li>瓶颈问题，原本分布式的控制平面集中化后，随着网络规模扩大，控制器可能成为网络性能的瓶颈。</li></ul></li></ul><h4 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4.拥塞控制"></a>4.拥塞控制</h4><ul><li>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞。此时通信子网的负载增加<br>导致吞吐量降低</li><li>流量控制和拥塞控制的区别<ul><li>流量控制往往是指在发送端和接收端之间的点对点通信量的控制。<br>流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，<br>涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。</li></ul></li><li>拥塞控制的方法<ul><li>开环控制<ul><li>在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。这是一种静态的预防方法，<br>一旦整个系统启动并运行，中途就不再需要修改。</li><li>开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度策略等。<br>所有这些手段的共性是，在做决定时不考虑当前网络的状态。</li></ul></li><li>闭环控制<ul><li>事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，<br>然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。</li><li>闭环控制是基于反馈环路的概念，是一种动态的方法。</li></ul></li></ul></li></ul><h3 id="二-路由算法"><a href="#二-路由算法" class="headerlink" title="二.路由算法"></a>二.路由算法</h3><h4 id="1-静态路由与动态路由"><a href="#1-静态路由与动态路由" class="headerlink" title="1.静态路由与动态路由"></a>1.静态路由与动态路由</h4><ul><li>静态路由算法（又称非自适应路由算法）<ul><li>由网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，<br>网络管理员需要手工去修改路由表中相关的静态路由信息。</li><li>它不能及时适应网络状态的变化，对于简单的小型网络，可以采用静态路由。</li></ul></li><li>动态路由算法（又称自适应路由算法）<ul><li>路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，<br>而这些路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优的寻路效果</li><li>静态路由算法的特点是简便和开销较小，在拓扑变化不大的小网络中运行效果很好。<br>动态路由算法能改善网络的性能并有助于流量控制</li><li>但算法复杂，会增加网络的负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性</li><li>常用的动态路由算法可分为两类：距离-向量路由算法和链路状态路由算法。</li></ul></li></ul><h4 id="2-距离-向量路由算法"><a href="#2-距离-向量路由算法" class="headerlink" title="2.距离-向量路由算法"></a>2.距离-向量路由算法</h4><ul><li>在距离-向量路由算法中，<strong>所有结点</strong>都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。<br>这种路由选择表包含：每条路径的目的地（另一结点）、路径的代价（也称距离）</li><li>所有的结点都监听从其他结点传来的路由选择更新信息，并在下列情况下更新它们的路由选择表<ul><li>被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</li><li>发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离（较小的代价）<br>此种情况下，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由</li></ul></li><li>距离-向量路由算法的实质<ul><li>迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短（最小代价）通路。<br>它要求每个结点在每次更新时都将它的全部路由表发送给所有相邻的结点。</li><li>更新报文的大小与通信子网的结点个数成正比，所有结点都将参加路由选择信息交换</li><li>最常见的距离-向量路由算法是RIP算法，它采用“跳数”作为距离的度量</li></ul></li><li>在距离-向量路由协议中，“好消息传得快，而坏消息传得慢”，<br>这就导致了当路由信息发生变化时，该变化未能及时地被所有路由器知道，而仍然可能在路由器之间进行传递，这就是“慢收敛”现象。慢收敛是导致发生路由回路的根本原因。</li></ul><h4 id="3-链路状态路由算法"><a href="#3-链路状态路由算法" class="headerlink" title="3.链路状态路由算法"></a>3.链路状态路由算法</h4><ul><li>链路状态路由算法的过程<ul><li>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，<br>而不是仅送给那些直接相连的结点。每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息。</li><li>每当链路状态报文到达时，路由结点便使用这些状态信息去更新自己的网络拓扑和状态“视野图”</li><li>一旦链路状态发生变化，结点就对更新的网络图利用Dijkstra最短路径算法重新计算路由，从单一的源出发计算到达所有目的结点的最短路径。</li></ul></li><li>链路状态路由算法的特点<ul><li>每个参与该算法的结点都具有完全的网络拓扑信息并执行下述两项任务<ul><li>主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。</li><li>定期地将链路状态传播给所有其他结点（或称路由结点）</li></ul></li><li>向本自治系统中所有路由器发送信息，使用洪泛法，即路由器通过所有端口向所有相邻的路由器发送信息；<br>而每个相邻路由器又将此信息发往其所有相邻路由器（但不再发送给刚刚发来信息的那个路由器）</li><li>发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul><li>“链路状态”是指说明本路由器与哪些路由器相邻及该链路的“度量”</li><li>对于OSPF算法，链路状态的“度量”主要用来表示费用、距离、时延、带宽等。</li></ul></li><li>只有当链路状态发生变化时，路由器才向所有路由器发送此信息。由于一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。</li><li>典型的链路状态算法是OSPF算法。</li></ul></li><li><p>链路状态路由算法的优点</p><ul><li>每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算<br>链路状态报文不加改变地传播，因此采用该算法易于查找故障。</li><li>当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。</li><li>由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关，<br>因此链路状态算法比距离-向量算法有更好的规模可伸展性。</li></ul></li><li><p>距离-向量路由算法与链路状态路由算法的比较</p><ul><li>在距离-向量路由算法中，每个结点仅与它的直接邻居交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计。</li><li>在链路状态路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链路的费用。<br>相较之下，距离-向量路由算法有可能遇到路由环路等问题。</li></ul></li></ul><h4 id="4-层次路由（✠）"><a href="#4-层次路由（✠）" class="headerlink" title="4.层次路由（✠）"></a>4.层次路由（✠）</h4><ul><li>路由选择必须按照层次的方式进行，因特网将整个互联网划分为许多较小的自治系统（注意一个自治系统中包含很多局域网）<br>每个自治系统有权自主地决定本系统内应采用何种路由选择协议。</li><li>如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。</li><li>因特网把路由选择协议划分为两大类<ul><li>一个自治系统内部所使用的路由选择协议称为<strong>内部网关协议(IGP)</strong>，也称域内路由选择，具体的协议有<u>RIP和OSPF</u>等。</li><li>自治系统之间所使用的路由选择协议称为<strong>外部网关协议(EGP)</strong>，也称域间路由选择，<br>用在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有<u>BGP</u></li></ul></li><li>使用层次路由时，OSPF将一个自治系统再划分为若干区域(Area)，每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。</li><li>采用分层次划分区域的方法虽然会使交换信息的种类增多，也会使OSPF协议更加复杂。<br>但这样做却能使每个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模很大的自治系统中。</li></ul><h3 id="三-IPV4（✪）"><a href="#三-IPV4（✪）" class="headerlink" title="三.IPV4（✪）"></a>三.IPV4（✪）</h3><h4 id="1-IPV4分组"><a href="#1-IPV4分组" class="headerlink" title="1.IPV4分组"></a>1.IPV4分组</h4><ul><li>IPv4分组的格式<ul><li>一个IP分组由首部和数据部分组成。首部前一部分的长度固定，共20B，是所有IP分组必须具有的。</li><li>在首部固定部分的后面是一些可选字段，其长度可变，用来提供错误检测及安全等机制。</li><li>首部中的一些重要字段<ul><li>版本<ul><li>指 IP 协议的版本, 目前广泛使用的版本号为 4 </li></ul></li><li>首部长度<ul><li>占 4 位，可以表示的最大十进制数是 15 。以 32 位为单位，最大值为${60 \mathrm{B}}{(15 \times 4 \mathrm{B})}$。<br>最常用的首部长度是${20 \mathrm{B}}$, 此时不使用任何选项（即可选字段）。</li></ul></li><li>总长度<ul><li>占 16 位。指首部和数据之和的长度，单位为字节，因此数据报的最大长度为${2^{16}-1=65535 \mathrm{B}}$。</li><li>以太网帧的最大传送单元 (MTU) 为${1500 \mathrm{B}}$， 因此当一个 IP 数据报封装成帧时,<br>数据报的总长度 (首部加数据) 一定不能超过下面的数据链路层的 MTU 值。</li></ul></li><li>标识<ul><li>占 16 位。它是一个计数器，每产生一个数据报就加 1 , 并赋值给标识字段。但它并不是 “序号” (因为 IP 是无连接服务)</li><li>当一个数据报的长度超过网络的 MTU 时，必须分片，此时每个数据报片都复制一次标识号, 以便能正确重装成原来的数据报。 </li></ul></li><li>标志<ul><li>占 3 位。标志字段的最低位为${M F, M F=1}$表示后面还有分片, $MF{=0}$表示最后一个分片</li><li>标志字段中间的一位是 DF，只有当 DF${=0}$ 时才允许分片。</li></ul></li><li>片偏移<ul><li>占 13 位。它指出较长的分组在分片后, 某片在原分组中的相对位置。</li><li>片偏移以 8 个字节为偏移单位。除最后一个分片外, 每个分片的长度一定是${8 \mathrm{B}}$的整数倍。</li></ul></li><li>生存时间 (TTL)<ul><li>占 8 位。数据报在网络中可通过的路由器数的最大值, 标识分组在网络中的寿命, 以确保分组不会永远在网络中循环。<br>路由器在转发分组前, 先把 TTL 减 1 。 若 TTL 被减为 0 , 则该分组必须丢弃。（一个分组可以经过的最多的跳数）</li></ul></li><li>协议<ul><li>占 8 位。指出此分组携带的数据使用何种协议, 即分组的数据部分应上交给哪个协议进行处理, 如 TCP、UDP 等。</li><li>其中值为 6 表示 TCP, 值为 17 表示 UDP。</li></ul></li><li>首部校验和<ul><li>占 16 位。<u>首部校验和只校验分组的首部</u>, 而不校验数据部分。 </li></ul></li><li>源地址字段：占 4B, 标识发送方的 IP 地址。</li><li>目的地址字段：占 4B, 标识接收方的 IP 地址。</li></ul></li><li><strong>注意，在IP数据报首部中有三个关于长度的标记，首部长度、总长度、片偏移，</strong><br><strong>基本单位分别为4B、1B、8B（需要记住）。题目中经常会出现这几个长度之间的加减运算。</strong></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/05/pPkv8ht.png" alt="pPkv8ht.png"></li></ul></li></ul></li><li>IP数据报分片<ul><li>分片的流程<ul><li>创建一个 IP 数据报时, 源主机为该数据报加上一个标识号。</li><li>当一个<u>中间路由器</u>需要将一个数据报分片时, 形成的每个数据报 (即片) 都具有原始数据报的标识号。</li><li>当 IP 数据报的总长度大于链路层 MTU 时, 就需要将 IP 数据报中的数据分装在多个较小的 IP 数据报中, 这些较小的数据报称为片。</li><li>片在<u>目的主机网络层</u>被重新组装。目的主机使用 IP 首部中的标识、标志和片偏移字段来完成对片的重组。</li><li>当目的主机收到来自同一发送主机的一批数据报时, 它可以通过检查数据报的标识号来确定哪些数据报属于同一个原始数据报的片。</li><li>目的主机在对片进行重组时, 使用片偏移字段来确定片应放在原始 IP 数据报的哪个位置。</li></ul></li><li>标志位<ul><li>IP 首部中的标志位占 3 位, 但只有后 2 位有意义, 分别是 MF 位 (More Fragment) 和 DF 位 (Don’t Fragment)。</li><li>只有当 $DF{=0}$时，该 IP 数据报才可以被分片。</li><li>$MF$ 则用来告知目的主机该 IP 数据报是否为原始数据报的最后一个片。<ul><li>当${\mathrm{MF}=1}$时, 表示相应的原始数据报还有后续的片</li><li>当${\mathrm{MF}=0}$时, 表示该数据报是相应原始数据报的最后一个片。</li></ul></li></ul></li><li>分片的例子<ul><li>一个长 4000B 的 IP 数据报 (首部 20B, 数据部分${3980 \mathrm{B}}$) 到达一个路由器, 需要转发到一条 MTU 为${1500 \mathrm{B}}$的链路上</li><li>原始数据报中的${3980 \mathrm{B}}$数据必须被分配到 3 个独立的片中 (每片也是一个 IP 数据报)。</li><li>由于偏移值的单位是${8 \mathrm{B}}$, 所以除最后一个片外, 其他所有片中的有效数据载荷都是 8 的倍数。</li><li>$片偏移=（之前分片的总数据-20<em>(分片序数-1)/8$，如第三个分片的偏移量为（3000-20</em>2）/ 8<br>第二个分片的偏移量为：（1500-20）/ 8</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/05/pPkzGy8.png" alt="pPkzGy8.png"></li></ul></li></ul></li><li>例题<ul><li>此时不仅要满足最大分片数量这个条件，还需要满足片偏移的数据量是8的倍数的条件，以第一个分片为准，其可能的数据量为：800-20=780，780中满足8的倍数的最大数为776，因此第一个分片的最大长度为779。显然779*2&lt;1580，此时第二个分片的MF标志位为1，总长度字段为796<br><img src="https://s1.ax1x.com/2023/08/06/pPAgJ0g.png" alt="pPAgJ0g.png"></li></ul></li></ul></li></ul><h4 id="2-IPV4地址与NAT"><a href="#2-IPV4地址与NAT" class="headerlink" title="2.IPV4地址与NAT"></a>2.IPV4地址与NAT</h4><ul><li>IPv4地址（32位，由网络号与主机号组成）<ul><li>IP地址的分类，注意每一类的前几位是固定的数字<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAtTvn.png" alt="pPAtTvn.png"></li></ul></li><li>常见的三类IP地址的使用范围<ul><li><img src="https://s1.ax1x.com/2023/08/05/pPApPv6.png" alt="pPApPv6.png"></li><li>A类地址可用的网络数为$2^{7}-2$，减2的原因是<ul><li>第一，网络号字段全为0的IP地址是保留地址，意思是“本网络”</li><li>第二，网络号为127的IP地址是环回自检地址。</li></ul></li></ul></li><li>近年来, 由于广泛使用无分类 IP 地址进行路由选择, 这种传统分类的 IP 地址已成为历史。</li><li>特殊的IP地址<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAtOET.png" alt="pPAtOET.png"></li></ul></li><li>IP地址的特点<ul><li>每个 IP 地址都由网络号和主机号两部分组成，因此 IP 地址是一种分等级的地址结构。<br>分等级的好处是：<ul><li>IP 地址管理机构在分配 IP 地址时只分配网络号, 而主机号则由得到该网络的单位自行分配，方便了 IP 地址的管理</li><li>路由器仅根据目的主机所连接的网络号转发分组 (而不考虑目标主机号), 从而减小了路由表所占的存储空间。</li></ul></li><li>IP 地址是标志一台主机 (或路由器) 和一条链路的接口，路由器至少存在两个端口，因此路由器至少有两个IP地址</li><li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。路由器总是具有两个或两个以上的 IP 地址, 路由器的每个端口都有一个不同网络号的 IP 地址。</li><li>用转发器或桥接器 (网桥等) 连接的若干 LAN 仍然是同一个网络 (同一个广播域), 因此该 LAN 中所有主机的 IP 地址的网络必须相同, 但主机号必须不同。</li><li>在 IP 地址中, 所有分配到网络号的网络 (无论是 LAN 还是 WAN) 都是平等的。</li></ul></li></ul></li><li>网络地址转换(NAT)<ul><li>NAT的概述<ul><li>网络地址转换 (NAT) 是指通过将专用网络地址转换为公用地址，从而对外隐藏内部管理的 IP 地址。</li><li>它使得整个专用网只需要一个全球 IP 地址就可以与因特网连通，由于专用网本地 IP 地址是可重用的，所以NAT大大节省了 IP 地址的消耗。同时, 它隐藏了内部网络结构, 从而降低了内部网络受到攻击的风险。</li><li>在因特网中的所有路由器, 对目的地址是私有地址的数据报一律不进行转发。<br>这种采用私有 IP 地址的互联网络称为专用互联网或本地互联网。私有 IP 地址也称可重用地址。</li></ul></li><li><strong>私有网段</strong>（私有IP地址只用于 LAN, 不用于WAN连接）<ul><li>${\mathrm{A}}$类: 1 个${\mathrm{A}}$类网段，即${\mathbf{1 0} .0 .0 .0 \sim \mathbf{1 0} .255 .255 .255}$</li><li>${B}$类: 16 个${B}$类网段，即${172.16 .0 .0 \sim 172.31 .255 .255}$。</li><li>$C$ 类: 256 个${C}$类网段, 即 $192.168.0.0\sim192.168.255.255$。</li></ul></li><li>NAT路由器<ul><li>使用 NAT 时需要在专用网连接到因特网的路由器上安装 NAT 软件, NAT 路由器至少有一个有效的外部全球 IP 地址。<br>使用本地地址的主机和外界通信时, NAT 路由器使用 NAT 转换表进行本地 IP 地址和全球 IP 地址的转换。</li><li>NAT 转换表中存放着 \{本地 IP 地址: 端口 \} 到 \{全球 IP 地址: 端 口${\}}$的映射。<br>通过这种映射方式, 可让多个私有 IP 地址映射到一个全球 IP 地址。</li><li>当发送到NAT的分组的IP地址和端口同时在NAT转换表中有对应时才转发，只有没有两个同时对应的，就直接丢弃该分组。</li><li>普通路由器在转发IP数据报时，不改变其源IP地址和目的IP地址。<br>而NAT路由器在转发IP数据报时，一定要更换其IP地址(转换源IP地址或目的IP地址)。</li><li>普通路由器仅工作在网络层，而NAT路由器转发数据报时需要查看和转换传输层的端口号</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/05/pPAAI1J.png" alt="pPAAI1J.png"></li></ul></li></ul></li></ul></li></ul><h4 id="3-子网划分与子网掩码、CIDR（♚）"><a href="#3-子网划分与子网掩码、CIDR（♚）" class="headerlink" title="3.子网划分与子网掩码、CIDR（♚）"></a>3.子网划分与子网掩码、CIDR（♚）</h4><ul><li><p>子网划分</p><ul><li>子网划分的影响<ul><li>将原来较大的网络细分为几个规模较小的网络，减少广播域的大小，减少主机的数量（子网号占据了主机号位）</li><li><strong>提高IP地址的利用率，并不增加网络的数量</strong></li></ul></li><li>子网划分的基本思路如下:<ul><li>子网划分纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</li><li><strong>从主机号借用若干比特作为子网号, 当然主机号也就相应减少了相同的比特</strong>。三级IP地址的结构如下<br>IP 地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}。</li><li>凡是从其他网络发送给本单位某台主机的 IP 数据报, 仍然是根据 IP 数据报的目的网络号, 先找到连接到本单位网络上的路由器，然后该路由器在收到 IP 数据报后, 按目的网络号和子网号找到目的子网。最后把 IP 数据报直接交付给目的主机。</li></ul></li><li>例<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAftK0.png" alt="pPAftK0.png"></li></ul></li></ul></li><li>子网掩码（定长）<ul><li>网络号的位上均为1，主机号的位上均为0，子网掩码与IP地址逐位相与，就得到子网网络地址</li><li>现在的因特网标准规定：所有的网络都必须使用子网掩码。如果一个网络未划分子网，那么就采用默认子网掩码。<ul><li>A、B、C类地址的默认子网掩码分别为255.0.0.0、255.255.0.0、255.255.255.0</li></ul></li><li>同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码</li><li>路由器的路由表中，所包含信息的主要内容有目的网络地址、子网掩码、下一跳地址。</li><li><strong>牢记下面这些常用的二进制转换关系，首先根据子网掩码判断主机号，子网号的占位，之后通过IP地址与子网掩码作与运算，求出相应的网络地址</strong><ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAUGex.png" alt="pPAUGex.png"></li></ul></li></ul></li><li>无分类编址（CIDR，可变长，构成超网）<ul><li>CIDR的概述<ul><li>无分类域间路由选择${\mathrm{CIDR}}$是在变长子网掩码的基础上提出的一种消除传统${\mathrm{A}}$、${\mathrm{B}}$、${\mathrm{C}}$类网络划分,<br>并且可以在软件的支持下实现超网构造的一种 IP 地址的划分方法。</li><li>CIDR 使用 “网络前缀” 的概念代替子网络的概念, 与传统分类 IP 地址最大的区别就是，网络前缀的位数不是固定的，可以任意选取。CIDR 的记法是：IP::${=\{&lt;}$网络前缀${&gt;,&lt;}$主机号${&gt;\}}$</li><li>CIDR 还使用 “斜线记法” (或称 CIDR 记法), 即 IP 地址/网络前缀所占比特数。其中, 网络前缀所占比特数对应于网络号的部分, 等效于子网掩码中连续 1 的部分</li><li>CIDR 的优点在于网络前缀长度的灵活性。由于上层网络的前缀长度较短，因此相应的路由表的项目较少。<br>而内部又可采用延长网络前缀的方法来灵活地划分子网</li></ul></li><li>CIDR地址块<ul><li>将网络前缀都相同的连续 IP 地址组成 “CIDR 地址块”。一个 CIDR 地址块可以表示很多地址, 这种地址的聚合称为路由聚合, 或称构成超网。</li><li>CIDR 地址块中的地址数一定是 2 的整数次幂, 实际可指派的地址数通常为${2^{N}-2, N}$表示主机号的位数, 主机号全0代表网络号, 主机号全 1 为广播地址。</li><li>网络前缀越短, 其地址块所包含的地址数就越多。而在三级结构的 IP 地址中, 划分子网使网络前缀变长。</li><li>例如<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAs3dA.png" alt="pPAs3dA.png"></li></ul></li></ul></li><li>路由聚合<ul><li>将两个网络地址取交集可以构成超网，实现路由聚合</li><li>路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由, 有利于减少路由器之间的信息的交换, 从而提高网络性能。</li><li>例<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAsWyF.png" alt="pPAsWyF.png"></li></ul></li></ul></li><li>最长前缀匹配 (最佳匹配)<ul><li>使用 CIDR 时, 路由表中的每个项目由 “网络前缀” 和 “下一跳地址” 组成。</li><li>使用路由表中的网络地址与IP地址做与运算，如果匹配则待定</li><li>在查找路由表时可能会得到不止一个匹配结果。此时, 应当从匹配结果中选择具有最长网络前缀的路由, 因为网络前缀越长, 其地址块就越小, 因而路由就越具体。</li></ul></li></ul></li><li>网络层转发分组的过程<ul><li>转发表中两个特殊的路由<ul><li>主机路由<ul><li>对特定目的主机的IP地址专门指明一个路由，以方便网络管理员控制和测试网络。</li><li>若特定主机的IP地址是a.b.c.d,则转发表中对应项的目的网络是a.b.c.d/32<br>32表示的子网掩码没有意义，但这个特殊的前缀可以用在转发表中。</li></ul></li><li>默认路由<ul><li>用特殊前缀0.0.0.0/0表示默认路由，全0掩码和任何目的地址进行按位与运算，结果必然为全0<br>必然和转发表中的0.0.0.0/0相匹配</li><li>只要目的网络是其他网络（不在转发表中），就一律选择默认路由。<br>与其它表项都不匹配时</li></ul></li></ul></li><li>流程<ul><li>从收到的 IP 分组的首部提取目的主机的 IP 地址${D}$(即目的地址)。</li><li>若查找到特定主机路由 (目的地址为${D}$), 就按照这条路由的下一跳转发分组<br>否则从转发表中的下一条 (即按前缀长度的顺序) 开始检查</li><li>将这一行的子网掩码与目的地址${D}$进行按位与运算。若运算结果与本行的前缀匹配，则查找结束，按照 “下一跳” 指出的进行处理 (或者直接交付本网络上的目的主机, 或通过指定接口发送到下一跳路由器)。否则, 若转发表还有下一行, 则对下一行进行检查</li><li>若转发表中有一个默认路由, 则把分组传送给默认路由; 否则, 报告转发分组出错。</li><li>例题<ul><li>此时先从前缀最长的开始检查，子网掩码为22的项与分组目的地址不匹配，之后看子网掩码为11的目的网络，<br>此时可以匹配，于是从R2转发出去<br><img src="https://s1.ax1x.com/2023/08/06/pPAJ7Gj.png" alt="pPAJ7Gj.png"></li></ul></li></ul></li><li>注意 <ul><li>得到下一跳路由器的 IP 地址后, 并不是直接将该地址填入待发送的数据报, 而是将该IP地址转换成 MAC 地址 (通过 ARP)<br>将此 MAC 地址放到 MAC 帧首部中, 然后根据这个 MAC 地址找到下一跳路由器。</li><li>在不同网络中传送时, MAC 帧中的源地址和目的地址要发生变化, 但是网桥在转发帧时, 不改变帧的源地址, 请注意区分。<br>IP数据报头部的源地址与目的地址不发生变化（没有NAT的情况下）</li></ul></li></ul></li><li>相关例题<ul><li>例1：首先B类地址要划分子网的话，还有主机位的16位可以划分，再通过主机数目求得主机位数，之后可以求得相应的子<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPARLlt.png" alt="pPARLlt.png"></li></ul></li><li>例2：用填充法来划分相应的情况，划分出五种即可<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAfWVO.png" alt="pPAfWVO.png"></li></ul></li><li>例3：此时需要将各个网络可划分的情况列举出来，看是否满足3个子网下刚好契合<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAhCMq.png" alt="pPAhCMq.png"></li><li><img src="https://s1.ax1x.com/2023/08/06/pPAhAdU.png" alt="pPAhAdU.png"></li></ul></li><li>例4：首先目的地址一定就是web服务器的地址，但是源地址需要将私有地址经过NAT路由器进行转换，<br>此时根据NAT路由器链路的网段信息（题干中），此时只剩下两个主机位，只有可能是01或10，于是选符合条件的D选项<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAhzTO.png" alt="pPAhzTO.png"></li></ul></li></ul></li></ul><h4 id="4-ARP、DHCP与ICMP"><a href="#4-ARP、DHCP与ICMP" class="headerlink" title="4.ARP、DHCP与ICMP"></a>4.ARP、DHCP与ICMP</h4><ul><li><p>IP 地址与硬件地址</p><ul><li>IP 地址是网络层使用的地址, 它是分层次等级的。</li><li>硬件地址是数据链路层使用的地址 (MAC 地址), 它是平面式的。</li><li>在 IP 层抽象的互联网上只能看到 IP 数据报，虽然在 IP 数据报首部中有源 IP 地址，但路由器只根据目的 IP 地址进行转发。</li><li>在局域网的链路层, 只能看见 MAC 帧。IP 数据报被封装在 MAC 帧中, 通过路由器转发 IP 分组时, 会重新封装源硬件地址和目的硬件地址</li></ul></li><li><p>地址解析协议 (ARP，网络层协议)</p><ul><li>使用ARP协议来完成IP地址到MAC地址的映射</li><li>每台主机都设有一个 ARP 高速缓存, 用来存放本局域网上各主机和路由器的 IP 地址到 MAC 地址的映射表, 称 ARP 表。<br>使用 ARP 来动态维护此 ARP 表。</li><li>ARP的原理（工作在网络层）<ul><li>主机 A 欲向本局域网上的某台主机 B 发送 IP 数据报时, 先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。</li><li>如果有, 就可查出其对应的硬件地址, 再将此硬件地址写入 MAC 帧, 然后通过局域网将该 MAC 帧发往此硬件地址。</li><li>如果没有, 那么就通过使用目的 MAC 地址为 FFFF-FF-FF-FF-FF 的帧来封装并广播 ARP 请求分组 (广播发送), 使同一个局域网里的所有主机都收到此 ARP 请求。<strong>尽管 ARP 请求分组是广播发送的, 但 ARP 响应分组是普通的单播</strong>，即从一个源地址发送到一个目的地址。</li><li>主机 B 收到该 ARP 请求后, 向主机 A 发出 ARP 响应分组 (单播发送), 分组中包含主机 B 的 IP 与 MAC 地址的映射关系, 主机 A 收到 ARP 响应分组后就将此映射写入 ARP 缓存, 然后按查询到的硬件地址发送 MAC 帧。</li><li>如果所要找的主机和源主机不在同一个局域网上, 那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址<br>然后把分组发送给这个路由器, 让这个路由器把分组转发给下一个网络。 剩下的工作就由下一个网络来做</li><li>例<ul><li>首先主机通过ARP找到局域网内的路由器，再经过路由器之间的4次使用ARP协议到达B所造的路由器，最后此路由器再使用一次ARP协议即可找到主机B，一共进行了6次<br><img src="https://s1.ax1x.com/2023/08/06/pPAtVcn.png" alt="pPAtVcn.png"></li></ul></li></ul></li></ul></li><li><p>动态主机配置协议 (DHCP，应用层协议) </p><ul><li>常用于给主机动态地分配 IP 地址, 它提供了即插即用的联网机制<br>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与，<strong>DHCP 是应用层协议, 它是基于 UDP 的。</strong></li><li>DHCP 的工作原理如下<ul><li>使用客户/服务器（C/S）模式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>本地网络上所有主机都能收到此广播报文, 但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。</li><li>若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。DHCP 服务器的回答报文称为提供报文。</li></ul></li><li>DHCP的特点<ul><li>DHCP 允许网络上配置多台 DHCP 服务器, 当 DHCP 客户机发出 “DHCP 发现” 消息时, 有可能收到多个应答消息。<br>这时, DHCP 客户机只会挑选其中的一个, 通常挑选最先到达的。</li><li>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的, 因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址DHCP 称这段时间为租用期。租用期的数值应由 DHCP 服务器自己决定, DHCP 客户也可在自己发送的报文中提出对租用期的要求。</li><li><strong>DHCP 的客户端和服务器端需要通过广播方式来进行交互</strong>, 原因是在 DHCP 执行初期, 客户端不知道服务器端的 IP 地址, 而在执行中间，客户端并未被分配 IP 地址, 从而导致两者之间的通信必须采用广播的方式。</li><li>采用 UDP 而不采用 TCP 的原因也很明显：TCP 需要建立连接, 如果连对方的 IP 地址都不知道, 那么更不可能通过双方的套接字建立连接。</li><li>DHCP 是应用层协议, 因为它是通过客户/服务器模式工作的, DHCP 客户端向 DHCP 服务器请求服务, 而其他层次的协议是没有这两种工作方式的</li></ul></li></ul></li><li><p>网际控制报文协议 (ICMP，网络层协议)</p><ul><li><p>为了提高 IP 数据报交付成功的机会, 在网络层使用了网际控制报文协议 (ICMP) 来让主机或路由器报告差错和异常情况。</p></li><li><p><strong>ICMP 报文作为 IP 层数据报的数据, 加上数据报的首部, 组成 IP 数据报发送出去。</strong></p></li><li><p>ICMP 报文的种类</p><ul><li><p>ICMP 差错报告报文</p><ul><li>ICMP 差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。</li><li>种类<ul><li>终点不可达，当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li><li>源点抑制，当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，<br>使源点知道应当把数据报的发送速率放慢</li><li>时间超过，当路由器收到生存时间(TTL)为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。<br>当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>参数问题，当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向），路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li></ul></li><li>不应发送ICMP差错报告报文的几种情况如下<ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文。</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</li></ul></li></ul></li><li><p>ICMP询问报文有4种类型：回送请求和回答报文、时间戳请求和回答报文、地址掩码请求和回答报文、路由器询问和通告报文，最常用的是前两类。</p></li><li><p><strong>ICMP的两个常见应用是分组网间探测PING（用来测试两台主机之间的连通性）和Traceroute</strong></p><p>PING使用了ICMP回送请求和回答报文，Traceroute(Tracert)使用了ICMP时间超过报文。</p></li></ul></li></ul></li></ul><h3 id="四-IPV6"><a href="#四-IPV6" class="headerlink" title="四.IPV6"></a>四.IPV6</h3><h4 id="1-IPv6的主要特点"><a href="#1-IPv6的主要特点" class="headerlink" title="1.IPv6的主要特点"></a>1.IPv6的主要特点</h4><ul><li>IPv6的主要特点<ul><li><strong>IPv6将地址从32位(4B)扩大到128位(16B),更大的地址空间</strong></li><li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</li><li>IPv6支持<strong>即插即用（即自动配置），不需要DHCP协议。</strong></li><li>IPv6<strong>首部长度必须是8B的整数倍</strong>，IPv4首部是4B的整数倍。<br><strong>且首部长度固定为40B</strong></li><li><strong>IPv6中不允许分片</strong>。因此，如果路由器发现到来的数据报太大而不能转发到链路上，<br>那么丢弃该数据报，并向发送方发送一个指示分组太大的ICMP报文。</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/07/pPEZyrj.png" alt="pPEZyrj.png"></li></ul></li></ul><h4 id="2-IPv6地址"><a href="#2-IPv6地址" class="headerlink" title="2.IPv6地址"></a>2.IPv6地址</h4><ul><li><p>IPv6数据报的三种类型</p><ul><li>单播：单播就是传统的点对点通信</li><li>多播：多播是一点对多点的通信，分组被交付到一组计算机的每台计算机</li><li>任播：这是IPv6增加的一种类型。<br>任播的目的站是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机。</li></ul></li><li><p>IPv6的地址表示法</p><ul><li>即把地址中的每4位用一个十六进制数表示，并用冒号分隔每16位，如4BF5:0000:0000:0000:BA5F:039A:000A:2176</li><li>当16位域的开头有一些0时，可以采用一种缩写表示法，但在域中必须至少有一个数字。<br>可以把地址缩写为4BF5:0:0:0:BA5F:39A:A:2176</li><li>当有相继的0值域时，还可以进一步缩写。这些域可以用双冒号缩写，双冒号表示法在一个地址中仅能出现一次，<br>可以写成4BF5::BA5F:39A:A:2176</li></ul></li></ul><h3 id="五-路由协议（✠）"><a href="#五-路由协议（✠）" class="headerlink" title="五.路由协议（✠）"></a>五.路由协议（✠）</h3><h4 id="1-自治系统（AS）"><a href="#1-自治系统（AS）" class="headerlink" title="1.自治系统（AS）"></a>1.自治系统（AS）</h4><ul><li>单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由，<br>同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由。</li><li>一个自治系统内的所有网络都由一个行政单位(如一家公司、一所大学、一个政府部门等)管辖，<br>一个自治系统的所有路由器在本自治系统内都必须是连通的。</li></ul><h4 id="2-域内路由与域间路由"><a href="#2-域内路由与域间路由" class="headerlink" title="2.域内路由与域间路由"></a>2.域内路由与域间路由</h4><ul><li>自治系统内部的路由选择称为域内路由选择，自治系统之间的路由选择称为域间路由选择</li><li>因特网有两大类路由选择协议<ul><li>内部网关协议(IGP)<ul><li>内部网关协议即在一个自治系统内部使用的路由选择协议，它与互联网中其他自治系统选用什么路由选择协议无关。<br>目前这类路由选择协议使用得最多，如RIP和OSPF。</li></ul></li><li>外部网关协议(EGP)<ul><li>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时（两个自治系统可能使用不同的IGP)<br>就需要使用一种协议将路由选择信息传递到另一个自治系统，目前使用最多的外部网关协议是BGP4</li></ul></li></ul></li></ul><h4 id="3-路由信息协议（RIP-✠）"><a href="#3-路由信息协议（RIP-✠）" class="headerlink" title="3.路由信息协议（RIP ✠）"></a>3.路由信息协议（RIP ✠）</h4><ul><li><p>RIP是一种分布式的<strong>基于距离向量</strong>的路由选择协议，其最大优点就是简单</p></li><li><p><strong>RIP是应用层协议，它使用UDP传送数据(端口520)。</strong></p></li><li><p>RIP选择的路径不一定是时间最短的，但一定是具有<strong>最少路由器的路径</strong>。因为它是根据最少跳数进行路径选择的。</p><p>要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）。</p></li><li><p>RIP的规定</p><ul><li>网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录（因此这是一组距离，称为距离向量）</li><li><strong>距离也称跳数</strong>，规定从一个路由器到直接连接网络的距离（跳数）为1。而每经过一个路由器，距离（跳数）加1</li><li>RIP认为好的路由就是它通过的路由器的数目少，即优先选择跳数少的路径</li><li><strong>RIP允许一条路径最多只能包含15个路由器(即最多允许15跳)。因此距离等于16时，它表示网络不可达</strong>。<br>RIP只适用于小型互联网。距离向量路由可能会出现环路的情况，规定路径上的最高跳数的目的是为了防止数据报不断循环在环路上，减少网络拥塞的可能性</li><li>RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表（动态维护）</li></ul></li><li><p>RIP的特点(注意与OSPF的特点比较)</p><ul><li><strong>仅和相邻路由器交换信息</strong>。</li><li><strong>路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。</strong></li><li>按固定的时间间隔交换路由信息，如每隔30秒</li><li>RIP通过距离向量算法来完成路由表的更新。经过若干RIP广播后，所有路由器都最终知道了整个RIP网络的路由表，<br>称为RIP最终是收敛的。</li><li><strong>通过RIP收敛后，每个路由器到每个目标网络的路由都是距离最短的（即跳数最少，最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。</strong></li></ul></li><li><p>距离向量算法（✪）</p><ul><li>每个路由表项目都有三个关键数据：&lt;目的网络N，距离d，下一跳路由器地址X&gt;</li><li><p>对于每个相邻路由器发送过来的RIP报文，执行如下步骤</p><ul><li><strong>对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目</strong><br><strong>把“下一跳”字段中的地址都改为X,并把所有“距离”字段的值加1</strong></li><li><p>对修改后的RIP报文中的每个项目，执行如下步骤</p><ul><li>当原来的路由表中没有目的网络N时，把该项目添加到路由表中</li><li>当原来的路由表中有目的网络N，且下一跳路由器的地址是X时，用收到的项目替换原路由表中的项目</li><li>当原来的路由表中有目的网络N，且下一跳路由器的地址不是X时，<br>如果收到的项目中的距离d小于路由表中的距离，那么就用收到的项目替换原路由表中的项目<br>否则什么也不做。</li></ul></li><li><p>如果180秒(RIP默认超时时间为180秒)还没有收到相邻路由器的更新路由表，<br>那么把此相邻路由器记为不可达路由器，即把距离设置为16(距离为16表示不可达)</p></li></ul></li><li><p>例题</p><ul><li><p>例1</p><ul><li><img src="https://s1.ax1x.com/2023/08/07/pPEeMes.png" alt="pPEeMes.png"></li></ul></li><li><p>例2</p><ul><li><img src="https://s1.ax1x.com/2023/08/07/pPEmE7R.png" alt="pPEmE7R.png"></li></ul></li></ul></li></ul></li><li><p>RIP的优点：最大的优点是实现简单、开销小、收敛过程较快。</p></li><li><p>RIP的缺点（✪）</p><ul><li>限制了网络的规模，它能使用的最大距离为15(16表示不可达)</li><li>路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销也越大</li><li>网络出现故障时，会出现<strong>慢收敛现象</strong>（即需要较长时间才能将此信息传送到所有路由器），<br><strong>俗称“坏消息传得慢”，使更新过程的收敛时间长</strong></li><li>理解坏消息传的慢，此时R1还会向R2发送原来链路可到达的信息，因此R2的距离会更新到3<ul><li><img src="https://s21.ax1x.com/2024/08/12/pApeFcF.png" alt="pApeFcF.png"></li></ul></li></ul></li></ul><h4 id="4-开放最短路径优先协议（OSPF）"><a href="#4-开放最短路径优先协议（OSPF）" class="headerlink" title="4.开放最短路径优先协议（OSPF）"></a>4.开放最短路径优先协议（OSPF）</h4><ul><li>OSPF是使用分布式链路状态路由算法的典型代表，也是内部网关协议(IGP)的一种。</li><li><strong>OSPF是网络层协议，它不使用UDP或TCP,而直接用IP数据报传送（其IP数据报首部的协议字段为89)</strong></li><li><strong>当互联网规模很大时，OSPF要比RIP好得多，而且OSPF协议没有“坏消息传播得慢”的问题。</strong></li><li>OSPF的特点<ul><li>OSPF对不同的链路可根据IP分组的不同服务类型(TOS)而设置成不同的代价。<br>因此，OSPF对于不同类型的业务可计算出不同的路由，十分灵活。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为多路径间的负载平衡。</li><li>所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li><li>支持可变长度的子网划分和无分类编址CDR</li><li>每个链路状态都带上一个32位的序号，序号越大，状态就越新。</li></ul></li><li>OSPF的基本工作原理<ul><li>各路由器之间频繁地交换链路状态信息，因此所有路由器最终都能建立一个链路状态数据库。<br>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（称为链路状态数据库的同步）。</li><li>每个路由器根据这个全网拓扑结构图，使用Dijkstra最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。</li><li>此后当链路状态发生变化时，每个路由器重新计算到各目的网络的最优路径，构造新的路由表。</li></ul></li><li>区域的概念<ul><li>为使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干更小的范围，称为区域。</li><li>划分区域的好处是，将利用洪泛法交换链路状态信息的范围局限于每个区域而非整个自治系统，减少了整个网络上的通信量。</li><li>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑情况。</li><li>区域也有层次之分。处在上层的域称为主千区域，负责连通其他下层的区域，并且还连接其他自治域。</li><li>采用分层划分区域的方法使交换信息的种类增多，OSPF协议更加复杂</li></ul></li><li>OSPF与RIP的4点主要区别<ul><li><strong>OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。而RIP仅向自己相邻的几个路由器发送信息</strong></li><li><strong>发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</strong><br><strong>“链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”（或代价）。</strong><br><strong>而在RIP中，发送的信息是本路由器所知道的全部信息，即整个路由表。</strong></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，<br>不会出现RIP“坏消息传得慢”的问题。而在RIP中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息</li><li>OSPF是网络层协议，它不使用UDP或TCP,而直接用IP数据报传送（其IP数据报首部的协议字段为89)<br>而RIP是应用层协议，它在传输层使用UDP</li></ul></li></ul><h4 id="5-边界网关协议（BGP）"><a href="#5-边界网关协议（BGP）" class="headerlink" title="5.边界网关协议（BGP）"></a>5.边界网关协议（BGP）</h4><ul><li>边界网关协议(BGP)是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。<br>边界网关协议常用于互联网的网关之间。</li><li><strong>边界网关协议(BGP)只能力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非寻找一条最佳路由。</strong></li><li>BGP采用的是路径向量路由选择协议，它与距离向量协议和链路状态协议有很大的区别。</li><li><strong>BGP是应用层协议，它是基于TCP的。</strong></li></ul><h4 id="6-三种路由协议的区别（✪）"><a href="#6-三种路由协议的区别（✪）" class="headerlink" title="6.三种路由协议的区别（✪）"></a>6.三种路由协议的区别（✪）</h4><ul><li><img src="https://s1.ax1x.com/2023/08/06/pPAz7qS.png" alt="pPAz7qS.png"></li></ul><h3 id="六-IP组播"><a href="#六-IP组播" class="headerlink" title="六.IP组播"></a>六.IP组播</h3><h4 id="1-组播的概念"><a href="#1-组播的概念" class="headerlink" title="1.组播的概念"></a>1.组播的概念</h4><ul><li><p>组播的概念</p><ul><li>为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制。</li></ul></li></ul><ul><li>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分<br>发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点的传输方式</li></ul><ul><li><strong>组播一定仅应用于UDP，</strong>它对将报文同时送往多个接收者的应用来说非常重要。</li></ul><ul><li><strong>在IPV4中，组播地址在D类地址空间中分配，而IPv6也有一部分地址空间保留给组播组。</strong></li></ul><ul><li>组播的流程<ul><li><strong>主机使用一个称为IGMP（因特网组管理协议）的协议加入组播组。</strong>它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望。<br>通过扩展路由器的路由选择和转发功能，可以在许多路由器互连的支持硬件组播的网络上面实现因特网组播</li><li>对发送者而言，数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担。</li><li>主机组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发<br>组播需要路由器的支持才能实现，能够运行组播协议的路由器称为组播路由器。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/06/pPEpUpR.png" alt="pPEpUpR.png"></li></ul></li></ul></li></ul><h4 id="2-IP组播地址"><a href="#2-IP组播地址" class="headerlink" title="2.IP组播地址"></a>2.IP组播地址</h4><ul><li><strong>IP组播使用D类地址格式。D类地址的前四位是1110，因此D类地址范围是224.0.0.0~239.255.255.255。</strong><br><strong>每个D类IP地址标志一个组播组。</strong></li><li><p>组播数据报的特点</p><ul><li>组播数据报也是“尽最大努力交付”，不提供可靠交付。</li><li>组播地址只能用于目的地址，而不能用于源地址。</li><li>对组播数据报不产生ICMP差错报文。因此，若在PING命令后面键入组播地址，将永远不会收到响应。</li><li>并非所有的D类地址都可作为组播地址。</li></ul></li><li><p>硬件组播（MAC地址的前六位固定，后六位由IP地址的后23位映射得来）</p><ul><li><img src="https://s21.ax1x.com/2024/08/12/pApeEnJ.png" alt="pApeEnJ.png"></li></ul></li></ul><h4 id="3-IGMP与组播路由算法"><a href="#3-IGMP与组播路由算法" class="headerlink" title="3.IGMP与组播路由算法"></a>3.IGMP与组播路由算法</h4><ul><li><p>IGMP的概念</p><ul><li>要使路由器知道组播组成员的信息，需要利用因特网组管理协议（IGMP)。</li><li>IGMP让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组。</li><li>IGMP并不是在因特网范围内对所有组播组成员进行管理的协议。IGMP不知道IP组播组包含的成员数，也不知道这些成员分布在哪些网络上。</li></ul></li><li>IGMP的工作原理<ul><li>当某台主机加入新的组播组时，该主机应向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员。本地的组播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他组播路由器。</li><li>本地组播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，那么组播路由器就认为这个组是活跃的。</li><li>但一个组在经过几次的探询后仍然没有一台主机响应时，则不再将该组的成员关系转发给其他的组播路由器。</li></ul></li><li>组播路由选择协议<ul><li>连接到局域网上的组播路由器还必须和因特网上的其他组播路由器协同工作，以便把组播数据报用最小代价传送给所有组成员，这就需要使用组播路由选择协议。</li><li>组播路由选择实际上就是要找出以源主机为根结点的<strong>组播转发树</strong>，其中每个分组在每条链路上只传送一次（即在组播转发树上的路由器不会收到重复的组播数据报），<strong>可以避免路由环路</strong></li><li>不同的多播组对应于不同的多播转发树：同一个多播组，对不同的源点也会有不同的多播转发树。</li><li>在许多由路由器互连的支持硬件多点传送的网络上实现因特网组播时，主要有三种路由算法：<ul><li>第一种是基于链路状态的路由选择</li><li>第二种是基于距离-向量的路由选择</li><li>第三种可以建立在任何路由器协议之上，因此称为协议无关的组播(PIM)。</li></ul></li></ul></li></ul><h3 id="七-移动IP"><a href="#七-移动IP" class="headerlink" title="七.移动IP"></a>七.移动IP</h3><h4 id="1-移动IP的概念"><a href="#1-移动IP的概念" class="headerlink" title="1.移动IP的概念"></a>1.移动IP的概念</h4><ul><li>移动IP技术是移动结点(计算机/服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，<br><strong>并保证了基于网络IP的网络权限在漫游过程中不发生任何改变</strong>。</li><li>移动结点：具有永久IP地址的移动设备。</li><li>归属代理（本地代理）：一个移动结点的永久“居所”称为归属网络，<br>在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理</li><li>永久地址(归属地址/主地址)：移动站点在归属网络中的原始地址。</li><li>外部代理（外地代理）：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理</li><li>转交地址（辅地址）：可以是外部代理的地址或动态配置的一个地址。</li></ul><h4 id="2-移动IP通信过程"><a href="#2-移动IP通信过程" class="headerlink" title="2.移动IP通信过程"></a>2.移动IP通信过程</h4><ul><li><img src="https://s1.ax1x.com/2023/08/07/pPECJzR.png" alt="pPECJzR.png"></li></ul><h3 id="八-网络层设备（✪）"><a href="#八-网络层设备（✪）" class="headerlink" title="八.网络层设备（✪）"></a>八.网络层设备（✪）</h3><h4 id="1-冲突域和广播域"><a href="#1-冲突域和广播域" class="headerlink" title="1.冲突域和广播域"></a>1.冲突域和广播域</h4><ul><li>冲突域<ul><li>冲突域是指连接到同一物理介质上的所有结点的集合，这些结点之间存在介质争用的现象。</li><li>在OSI参考模型中，冲突域被视为第1层概念，像集线器、中继器等简单无脑复制转发信号的第1层设备所连接的结点都属于同一个冲突域，也就是说它们不能划分冲突域。</li><li>而第2层（网桥、交换机）、第3层（路由器）设备都可以划分冲突域。</li><li>一个交换机的所有端口属于一个广播域，每个端口属于一个冲突域</li></ul></li><li>广播域<ul><li>广播域是指接收同样广播消息的结点集合。也就是说，在该集合中的任何一个结点发送一个广播帧，其他能收到这个帧的结点都被认为是该广播域的一部分。</li><li>在OSI参考模型中，广播域被视为第2层概念，像第1层（集线器等）、第2层（交换机等）设备所连接的结点都属于同一个<br>广播域。</li><li>路由器，作为第3层设备，则可以划分广播域，即可以连接不同的广播域。</li><li>通常所说的局域网(LAN)特指使用路由器分割的网络，也就是广播域</li></ul></li></ul><h4 id="2-路由器的组成与功能"><a href="#2-路由器的组成与功能" class="headerlink" title="2.路由器的组成与功能"></a>2.路由器的组成与功能</h4><ul><li><p>路由器的概述</p><ul><li><p>路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络（连接异构网络）并完成路由转发。<br>在多个逻辑网络（即多个广播域）互连时必须使用路由器。</p></li><li><p>当源主机要向目标主机发送数据报时，路由器先检查源主机与目标主机是否连接在同一个网络上。如果源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器。</p></li><li>如果源主机和目标主机不在同一个网络上，那么路由器按照转发表（路由表）指出的路由将数据报转发给下一个路由器，这称为间接交付。</li><li><strong>路由器隔离了广播域。从结构上看，路由器由路由选择和分组转发两部分构成，而从模型的角度看，路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。</strong></li></ul></li><li><p>路由器的组成</p><ul><li>路由选择部分<ul><li>路由选择部分也称控制部分，其核心构件是路由选择处理机，还包括路由选择协议，路由表</li><li>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表。</li></ul></li><li>分组转发部分<ul><li>由三部分组成：交换结构、一组输入端口和一组输出端口。</li><li>交换结构是路由器的关键部件，它根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去<br>交换结构本身就是一个网络</li><li>输入端口在从物理层接收到的比特流中提取出数据链路层帧，进而从帧中提取出网络层数据报<br>输出端口则执行恰好相反的操作</li><li>有三种常用的交换方法：通过存储器进行交换、通过总线进行交换和通过互联网络进行交换</li></ul></li></ul></li><li><p>路由器的功能</p><ul><li>路由计算：通过和其他路由器进行基于路由协议的交互，完成路由表的计算。</li><li>分组转发：处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等</li><li>当路由器监测到拥塞时，可合理丢弃IP分组，并向发出该IP分组的源主机发送一个源点抑制的ICMP报文。</li><li>路由器对收到的IP分组首部进行差错检验，丢弃有差错首部的报文，但不保证IP分组不丢失。</li></ul></li><li><p>路由器和网桥的区别</p><ul><li>网桥与高层协议无关，而路由器是面向协议的，它依据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等。</li><li>现今的路由器一般都提供多种协议的支持，包括OSI、TCP/IP、IPX等</li></ul></li></ul><h4 id="3-路由表与路由转发"><a href="#3-路由表与路由转发" class="headerlink" title="3.路由表与路由转发"></a>3.路由表与路由转发</h4><ul><li>路由表是根据路由选择算法得出的，主要用途是路由选择。</li><li>标准的路由表有4个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口<br>可能包含默认路由（0.0.0.0、0.0.0.0）</li><li>图片<ul><li><img src="https://s21.ax1x.com/2024/08/12/pApeZ7R.png" alt="pApeZ7R.png"></li></ul></li><li>转发表与路由表的区别<ul><li>转发表是从路由表得出的，其表项和路由表项有直接的对应关系。</li><li>但转发表的格式和路由表的格式不同，<strong>其结构应使查找过程最优化（而路由表则需对网络拓扑变化的计算最优化）</strong></li><li>转发表中含有一个分组将要发往的目的地址，以及分组的下一跳（即下一步接收者的目的地址，实际为MAC地址）</li><li>为了减少转发表的重复项目，可以使用一个默认路由代替所有具有相同“下一跳”的项目，并将默认路由设置得比其他项目的优先级低</li><li>路由表总是用软件来实现的；转发表可以用软件来实现，甚至也可以用特殊的硬件来实现。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机网络第四章-网络层&quot;&gt;&lt;a href=&quot;#计算机网络第四章-网络层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络第四章-网络层&quot;&gt;&lt;/a&gt;计算机网络第四章-网络层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：计算机网络第四章网络层的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络第三章-数据链路层</title>
    <link href="http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2024-08-11T15:42:45.000Z</published>
    <updated>2024-08-11T16:30:28.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络第三章-数据链路层"><a href="#计算机网络第三章-数据链路层" class="headerlink" title="计算机网络第三章 数据链路层"></a>计算机网络第三章 数据链路层</h2><blockquote><p>计算机学科基础：计算机网络第三章数据链路层的学习笔记</p></blockquote><span id="more"></span><h3 id="一-数据链路层的功能（✪）"><a href="#一-数据链路层的功能（✪）" class="headerlink" title="一.数据链路层的功能（✪）"></a>一.数据链路层的功能（✪）</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，<br>将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</li></ul><h4 id="2-为网络层提供服务"><a href="#2-为网络层提供服务" class="headerlink" title="2.为网络层提供服务"></a>2.为网络层提供服务</h4><ul><li>无确认的无连接服务<ul><li>源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。</li><li><strong>适用于实时通信或误码率较低的通信信道，如以太网。</strong></li></ul></li><li>有确认的无连接服务。<ul><li>源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。</li><li><strong>该服务适用于误码率较高的通信信道，如无线通信。</strong></li></ul></li><li>有确认的面向连接服务。<ul><li>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。</li><li>目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧</li><li><strong>该服务的可靠性最高。该服务适用于通信要求(可靠性、实时性)较高的场合</strong></li></ul></li><li>注：有连接就一定要有确认，即不存在无确认的面向连接的服务。</li></ul><h4 id="3-链路管理"><a href="#3-链路管理" class="headerlink" title="3.链路管理"></a>3.链路管理</h4><ul><li>数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。</li><li>链路两端的结点要进行通信，必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号<br>初始化，然后才能建立连接</li><li>在传输过程中则要能维持连接，而在传输完毕后要释放该连接。</li><li>在多个站点共享同一物理信道的情况下（如在局域网中），如何在要求通信的站点间分配和管理信道<br>也属于数据链路层管理的范畴。</li></ul><h4 id="4-帧定界、帧同步与透明传输（✪）"><a href="#4-帧定界、帧同步与透明传输（✪）" class="headerlink" title="4.帧定界、帧同步与透明传输（✪）"></a>4.帧定界、帧同步与透明传输（✪）</h4><ul><li>两台主机之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。</li><li>帧定界<ul><li>将一段数据的前后分别添加首部和尾部，就构成了帧。帧长等于数据部分的长度加上首部和尾部的长度。<br>首部和尾部中含有很多控制信息，它们的一个重要作用是确定帧的界限，即帧定界。</li></ul></li><li>帧同步<ul><li>接收方应能从接收到的二进制比特流中区分出帧的起始与终止。（用帧定界标识位来区分）</li><li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但每种数据链路层<br>协议都规定了帧的数据部分的长度上限一最大传送单元(MTU)。</li></ul></li><li>透明传输<ul><li>如果在数据中恰好出现与帧定界符相同的比特组合（会误认为“传输结束”而丢弃后面的数据），那么就要采取有效的措施解决这个问题，即透明传输。</li><li>更确切地说，透明传输就是不管所传数据是什么样的比特组合，都应当能在链路上传送。</li></ul></li></ul><h4 id="5-差错控制（✪）"><a href="#5-差错控制（✪）" class="headerlink" title="5.差错控制（✪）"></a>5.差错控制（✪）</h4><ul><li>由于信道噪声等各种原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，这些错误可分为位错和帧错。</li><li><strong>位错指帧中某些位出现了差错。通常采用循环冗余校验(CRC)方式发现位错，通过自动重传请求(Automatic Repeat reQuest,.ARQ)方式来重传出错的帧</strong>。<ul><li>让发送方将要发送的数据帧附加一定的CRC冗余检错码一并发送，接收方则根据检错码对数据帧进行错误检测，</li><li>若发现错误则丢弃，发送方超时重传该数据帧。这种差错控制方法称为ARQ法。ARQ法只需返回很少的控制信息就可有效地确认所发数据帧是否被正确接收。</li></ul></li><li><strong>帧错指帧的丢失、重复或失序等错误。在数据链路层引入定时器（解决丢失问题）和编号机制（解决失序重复问题）</strong>，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</li></ul><h4 id="6-流量控制（✪）"><a href="#6-流量控制（✪）" class="headerlink" title="6.流量控制（✪）"></a>6.流量控制（✪）</h4><ul><li>流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。<br>否则会来不及接收帧而造成帧的丢失</li><li>需要有一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后继续发送。</li><li>流量控制并不是数据链路层特有的功能，许多高层协议中也提供此功能，只不过控制的对象不同而已。<ul><li>对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量</li><li>对于传输层来说，控制的则是从源端到目的端之间的流量。</li><li>在OSI体系结构中，数据链路层具有流量控制的功能。而在TCP/IP体系结构中，流量控制功能被移到了传输层。</li></ul></li></ul><h3 id="二-组帧（封装成帧✪）"><a href="#二-组帧（封装成帧✪）" class="headerlink" title="二.组帧（封装成帧✪）"></a>二.组帧（封装成帧✪）</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>组帧时既要加首部，又要加尾部。在网络中信息是以帧为最小单位进行传输的，<br>所以接收端要正确地接收帧，必须要清楚该帧在一串比特流中从哪里开始到哪里结束（因为接收端收到的是一串比特流，没有首部和尾部是不能正确区分帧的）</li><li>目前较常用的组帧方法是零比特填充法和违规编码法。</li><li>以太网MAC帧没有帧开始符和帧结束符<ul><li>在交付给物理层之后，物理层将在以太网帧前添加8字节的前导码（前7个字节为同步码，作用是使接收方的时钟同步，之后一个字节为帧开始符）。</li><li>并且以太网帧规定了帧间间隔为96比特的发送时间。（对于带宽为10Mb/s的传统以太网，96比特的发送时间为9.6us）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/30/pSdIIpQ.png" alt="pSdIIpQ.png"></li></ul></li></ul></li></ul><h4 id="2-字符计数法"><a href="#2-字符计数法" class="headerlink" title="2.字符计数法"></a>2.字符计数法</h4><ul><li><p>字符计数法是指在帧头部使用一个计数字段来标明帧内字符数。</p><p>目的结点的数据链路层收到字节计数值时，就知道后面跟随的字节数，从而可以确定帧结束的位置（计数字段提供的字节数包含自身所占用的一个字节）</p></li><li><p>如果计数字段出错，收发双方将失去同步</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/08/01/pP9XJLq.png" alt="pP9XJLq.png"></li></ul></li></ul><h4 id="3-字符填充的首尾定界符法（✪）"><a href="#3-字符填充的首尾定界符法（✪）" class="headerlink" title="3.字符填充的首尾定界符法（✪）"></a>3.字符填充的首尾定界符法（✪）</h4><ul><li>字符填充法使用特定字符来定界一帧的开始与结束，控制字符SOH放在帧的最前面，表示帧的首部开始，控制字符EOT表示帧的结束。</li><li>为了使信息位中出现的特定字符不被误判为帧的首尾定界符，可在特殊字符前面填充一个转义字符(ESC)来加以区分，以实现数据的透明传输。</li><li>接收方收到转义字符后，就知道其后面紧跟的是数据信息，而不是控制信息。<br>接收方收到数据后会自己删除这个插入的ESC字符，结果仍得到原来的数据</li><li>如果转义字符ESC也出现在数据中，那么解决方法仍是在转义字符前插入一个转义字符。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/01/pP9XDSJ.png" alt="pP9XDSJ.png"></li></ul></li></ul><h4 id="4-零比特填充的首尾标志法（✪）"><a href="#4-零比特填充的首尾标志法（✪）" class="headerlink" title="4.零比特填充的首尾标志法（✪）"></a>4.零比特填充的首尾标志法（✪）</h4><ul><li>零比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。它使用一个特定的比特模式，即01111110来标志一帧的开始和结束。</li><li>为了不使信息位中出现的比特流01111110被误判为帧的首尾标志<br>发送方的数据链路层在信息位中遇到5个连续的“1”时，将自动在其后插入一个“0”；</li><li>而接收方做该过程的逆操作，即每收到5个连续的“1”时，自动删除后面紧跟的“0”，以恢复原信息。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/01/pP9XWFO.png" alt="pP9XWFO.png"></li></ul></li><li>例题<ul><li><img src="https://s1.ax1x.com/2023/01/30/pSdTKGF.png" alt="pSdTKGF.png"></li></ul></li></ul><h3 id="三-差错控制（✪）"><a href="#三-差错控制（✪）" class="headerlink" title="三.差错控制（✪）"></a>三.差错控制（✪）</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>实际通信链路都不是理想的，比特在传输过程中可能会产生差错，1可能会变成0，0也可能会变成1，这就是比特差错</li><li>通常利用<u>编码技术</u>进行差错控制，主要有两类：自动重传请求ARQ和前向纠错FEC。</li><li>在ARQ方式中，接收端检测到差错时，就设法通知发送端重发，直到接收到正确的码字为止（检错编码）</li><li>在FEC方式中，接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正。（纠错编码）</li><li>发送方的数据链路层采用某种检错技术，根据帧的内容计算出一个检错码，将检错码填入帧尾部。<br>接收方的数据链路层从帧尾部取出检错码，采用与发送方相同的检错技术，就可以通过检错码检测出是否出现误码。（该字段即为帧检验序列FCS）</li></ul><h4 id="2-检错编码（✪）"><a href="#2-检错编码（✪）" class="headerlink" title="2.检错编码（✪）"></a>2.检错编码（✪）</h4><ul><li><p>概述</p><ul><li>检错编码都采用冗余编码技术，其核心思想是在有效数据（信息位）被发送前，先按某种关系附加一定的冗余位，构成一个符合某一规则的码字后再发送。</li><li>当要发送的有效数据变化时，相应的冗余位也随之变化，使得码字遵从不变的规则。</li><li>接收端根据收到的码字是否仍符合原规则来判断是否出错。常见的检错编码有奇偶校验码和循环冗余码。</li></ul></li><li><p>奇偶校验码（✪）</p><ul><li>奇校验是在待发送的数据后面添加一个校验位，使整个数据中1的个数为奇数，若接收到的1为偶数则说明错误。</li><li>偶校验是在待发送的数据后面添加一个校验位，使整个数据中1的个数为偶数，若接收到的1为奇数则说明错误。<ul><li><img src="https://s1.ax1x.com/2023/01/30/pSwQxc6.png" alt="pSwQxc6.png"></li></ul></li><li><strong>它只能检测奇数个比特的出错情况，但并不知道哪些位错了，也不能发现偶数个比特的出错情况。</strong></li></ul></li><li><p>冗余循环码（CRC✪）</p><ul><li><p>步骤</p><ul><li>收发双方约定好一个生成多项式G(X)</li><li>将数据作为被除数（后面添加生成多项式最高位次个0），生成多项式的各项系数构成的比特串作为除数</li><li>模2除法计算出差错检测码（冗余码），冗余码需在前面补0至与生成多项式的最高次项位数相同，将冗余码添加到待发送的数据的后面一起传输<ul><li>注：如多项式为10011，最高位是$x^{4}$，被除数后面需要添加4个0；算出余数之后需要再前面加0至余数的位数满足最高位次数4</li></ul></li><li>接收方收到了数据和冗余码后其作为被除数，生成多项式的各项系数构成的比特串作为除数，模2除法来计算是否误码，如果余数为0，则没有误码。</li></ul></li><li><p>关于生成多项式</p><ul><li><img src="https://s1.ax1x.com/2023/01/30/pSw1GIH.md.png" alt="pSw1GIH.md.png"></li></ul></li><li><p>发送方操作</p><ul><li><img src="https://s1.ax1x.com/2023/01/30/pSw1rdg.png" alt="pSw1rdg.png"></li></ul></li><li><p>接收方操作</p><ul><li><img src="https://s1.ax1x.com/2023/01/30/pSw3EOf.png" alt="pSw3EOf.png"></li></ul></li><li><p>特点</p><ul><li>通过循环穴余码（CRC）的检错技术，数据链路层做到了对帧的无差错接收。<ul><li>凡是接收端数据链路层接受的，我们都认为这些帧在传输过程中没有产生差错</li><li>而接收端丢弃的帧虽然也收到了，但最终因为有差错而被丢弃，即未被接受。</li></ul></li><li><p>循环冗余校验（CRC）只能检测出错误，无法定位错误，因此无法纠错，是检错码，不是纠错码。 (海明码可以纠错)</p></li><li><p>循环冗余校验（CRC）漏检率极低，非常易于用硬件实现，被广泛应用于数据链路层。</p></li></ul></li></ul></li></ul><h4 id="3-纠错编码"><a href="#3-纠错编码" class="headerlink" title="3.纠错编码"></a>3.纠错编码</h4><ul><li>海明码</li></ul><h3 id="四-流量控制与可靠传输机制-✪"><a href="#四-流量控制与可靠传输机制-✪" class="headerlink" title="四.流量控制与可靠传输机制(✪)"></a>四.流量控制与可靠传输机制(✪)</h3><h4 id="1-流量控制机制"><a href="#1-流量控制机制" class="headerlink" title="1.流量控制机制"></a>1.流量控制机制</h4><ul><li>停止-等待流量控制协议<ul><li>发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧</li><li>接收方每接收一帧，都要反馈一个应答信号，表示可接收下一帧，如果接收方不反馈应答信号，那么发送方必须一直等待</li><li>每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低。</li></ul></li><li>滑动窗口流量控制<ul><li>流程<ul><li>发送端每收到一个确认帧，发送窗口就向前滑动一个帧的位置</li><li>接收端收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</li><li>当发送窗口内没有可以发送的帧（即窗口内的帧全部是已发送但未收到确认的帧）时，发送方就会停止发送<br>直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧后，才开始继续发送。</li></ul></li><li>滑动窗口的特征<ul><li>只有接收窗口向前滑动并发送了确认帧时，发送方收到确认帧后，发送窗口才有可能向前滑动。</li><li>对于窗口大小为n的滑动窗口，最多可以有n-1帧已发送但没有确认</li></ul></li><li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意与第5章传输层的滑动窗口协议的区别）</li></ul></li></ul><h4 id="2-可靠传输机制"><a href="#2-可靠传输机制" class="headerlink" title="2.可靠传输机制"></a>2.可靠传输机制</h4><ul><li>确认机制<ul><li>确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。</li></ul></li><li>超时重传机制<ul><li>发送方在发送某个数据帧后就开启一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止。</li></ul></li><li>自动重传请求(ARQ)，通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一<ul><li>传统自动重传请求分为三种，即停止-等待（SW）、后退N帧（GBN）和选择重传（SR）。</li><li>后两种协议由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。</li></ul></li></ul><h4 id="3-单帧滑动窗口与停止-等待协议（SW）"><a href="#3-单帧滑动窗口与停止-等待协议（SW）" class="headerlink" title="3.单帧滑动窗口与停止-等待协议（SW）"></a>3.单帧滑动窗口与停止-等待协议（SW）</h4><ul><li><p>确认、否认与重传机制</p><ul><li><p>发送方每发送完一个帧就必须停下来，等待接收方发来的确认（ACK）或者否认（NAK）</p><ul><li>出现误码时，接收方丢弃该帧，并向发送方发送一个NAK帧，接收方收到NAK帧后，再重传该帧</li><li>没有出现误码时，接收方向发送方发送一个ACK帧，接收方收到ACK帧，发送下一个帧。</li></ul></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/02/02/pSDO8oQ.md.png" alt="pSDO8oQ.md.png"></li></ul></li></ul></li><li><p>超时重传机制</p><ul><li>发送方可在每发送完一个数帧时启动一个超时重传器<br>若到了超时重传器设置的超时重传时间（RTO），但未收到接收方发送的确认帧和否认帧，就重传之前发送过的这个帧</li><li>RTO的时长不能太长（等待时间过长，降低信道利用率）不能太短（发送方出现不必要的超时重传）<br>一般可将RTO设置为略大于收发双方的平均往返时间RTT。</li><li>补充了超时重传机制后，可以不使用否认机制。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/02/02/pSDjPED.md.png" alt="pSDjPED.md.png"></li></ul></li></ul></li><li>编号机制<ul><li>为了区别收到的是重复帧，可以每个帧带上不同的序号</li><li>每发送一个帧，其序号于上一次发送的数据帧的序号不相同（可用序号为0和1来标识）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/02/02/pSDvcWj.md.png" alt="pSDvcWj.md.png"></li></ul></li></ul></li><li>此外，为了超时重发和判定重复帧的需要，发送方和接收方都须设置一个帧缓冲区。<ul><li>发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传。</li><li>只有在收到对方发来的确认帧ACK时，方可清除此副本。</li></ul></li></ul><h4 id="4-多帧滑动窗口与后退N帧协议（GBN）"><a href="#4-多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="4.多帧滑动窗口与后退N帧协议（GBN）"></a>4.多帧滑动窗口与后退N帧协议（GBN）</h4><ul><li><p>概述（属于有序接收的滑动窗口协议）</p><ul><li><p>为了减少开销，GBN协议规定接收端不一定每收到一个正确的数据帧就必须立即发回一个确认帧，而可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认信息。</p><ul><li>对某一数据帧的确认就表明该数据帧和此前所有的数据帧均已正确无误地收到，称为累积确认。</li></ul></li><li><p>如本题选A，收到5号帧的确认，说明前面都已经收到，只有6没有收到</p><ul><li><img src="https://s1.ax1x.com/2023/08/01/pPCNbkj.png" alt="pPCNbkj.png"></li></ul></li><li>当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重传该出错帧及随后的N个帧。</li></ul></li><li><p>后退N帧协议的窗口设置</p><ul><li><strong>后退N帧协议的接收窗口为1，可以保证按序接收数据帧。若采用n比特对帧编号，则其发送窗口的尺寸W应满足$1&lt;W≤2^{n}-1$。</strong></li><li>若发送窗口的尺寸大于$2^{n}-1$，则会造成接收方无法分辨新帧和旧帧</li><li>后退N帧协议因连续发送数据帧而提高了信道的利用率<br>但是当信道的传输质量很差导致误码率较大时，后退N帧协议不一定优于停止-等待协议。</li></ul></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/08/01/pPClSmR.png" alt="pPClSmR.png"></li></ul></li></ul><h4 id="5-多帧滑动窗口与选择重传协议（SR）"><a href="#5-多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="5.多帧滑动窗口与选择重传协议（SR）"></a>5.多帧滑动窗口与选择重传协议（SR）</h4><ul><li><p>概述（属于无序接收的滑动窗口协议）</p><ul><li>为进一步提高信道的利用率，可设法只重传出现差错的数据帧或计时器超时的数据帧</li><li>但此时必须加大接收窗口，以便先收下发送序号不连续但仍处在接收窗口中的那些数据帧。<br>等到所缺序号的数据帧收到后再一并送交主机。</li><li>在选择重传协议中，每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传。</li><li>一旦接收方怀疑帧出错，就会发一个否定帧NAK给发送方，要求发送方对NAK中指定的帧进行重传。</li></ul></li><li><p>SR的滑动窗口设置</p><ul><li><p>选择重传协议的接收窗口尺寸$W_R$和发送窗口尺寸$W_T$都大于1，一次可以发送或接收多个帧。</p></li><li><p>在选择重传协议中，需要满足：<strong>发送窗口大小+接收窗口大小≤$2^n$</strong></p><ul><li>选择重传协议是对单帧进行确认，所以发送窗口大于接收窗口会导致溢出，发送窗口小于接收窗口没有意义</li><li>接收窗口和发送窗口的大小通常是相同的，所需缓冲区的数目等于窗口的大小</li><li><strong>SR中最大值都为序号范围的一半，若采用n比特对帧编号，则需要满足$W_Tmax=W_Rmax=2^{n-1}$</strong></li><li>如果窗口大小大于序号范围一半，当一个或多个确认帧丢失时，发送方就会超时重传之前的数据帧<br>但接收方无法分辨是新的数据帧还是重传的数据帧。</li></ul></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/08/01/pPC1aKH.png" alt="pPC1aKH.png"></li></ul></li></ul></li></ul><h4 id="6-关于求信道利用率的问题（♚）"><a href="#6-关于求信道利用率的问题（♚）" class="headerlink" title="6.关于求信道利用率的问题（♚）"></a>6.关于求信道利用率的问题（♚）</h4><ul><li><p>信道的效率，也称信道利用率。信道效率是对发送方而言的，是指发送方在一个发送周期的时间内，有效地发送数据<br>所需要的时间占整个发送周期的比率。</p><ul><li>发送方从开始发送数据到收到<strong>第一个确认帧</strong>为止，称为一个发送周期，设为T</li><li>发送方在这个周期内共发送L比特的数据（<strong>不止一个确认帧</strong>），发送方的数据传输速率为C</li><li>则发送方用于发送有效数据的时间为L/C，在这种情况下，信道的利用率=$\LARGE\frac{ \frac {L}{C}}{T}$</li><li>信道吞吐率=信道利用率×发送方的发送速率。</li></ul></li><li><p>做题思路</p><ul><li><strong>首先应该以一个数据帧为基准，算一个周期的时延T</strong></li><li>一个周期的总时延包括单个数据帧与确认帧的发送时延与传播时延，传播时延是来回的，需乘以2</li><li>确认帧的发送时延不算作有效数据发送时延</li><li>停止-等待协议中，信道利用率就直接以一个数据帧的发送时延为有效发送数据所需要的时间</li><li><p>滑动窗口协议中，一般会求满足相关信道利用率时的帧序号的比特数，此时需要求滑动窗口的数量$&lt;=2^{n}-1$</p><ul><li>窗口数量=发送的帧的数目=总发送数据量/单个帧数据量</li><li>信道的利用率=$\LARGE\frac{ \frac {L}{C}}{T}$，可以求出总发送数据量L</li></ul></li><li><p>例</p><ul><li><p>题目</p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCqi9J.png" alt="pPCqi9J.png"></li></ul></li><li><p>分析</p><ul><li>发送数据帧和确认帧的时间均为t=1000×8b/10kb/s=800ms.（确认帧不算有效数据发送时间）</li><li>发送周期为T=800ms+200ms+800ms+200ms=2000ms.</li><li>信道利用率为t/T×100%=800/2000=40%</li></ul></li></ul></li></ul></li><li><p>例1</p><ul><li><p><strong>在滑动窗口协议中，信道利用率最高时，说明其在一个数据帧发送的时间周期之内，发送方一直在发送数据</strong><br><strong>此时可以通过总时长除一个帧的发送时长求出其一共发出了多少帧，此时再利用定则算编号的比特数</strong></p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCbW6I.png" alt="pPCbW6I.png"></li></ul></li><li><p>分析</p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCb50f.png" alt="pPCb50f.png"></li></ul></li></ul></li><li><p>例2</p><ul><li><p>本题设发送的数据量为L，代入公式计算即可，之后再除以帧长算出发送了多少帧并用定则求出帧序号比特数</p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCbOcn.png" alt="pPCbOcn.png"></li></ul></li><li><p>分析</p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCbL1s.png" alt="pPCbL1s.png"></li></ul></li></ul></li><li><p>例3</p><ul><li><p>最大数据传输速率说明在一个T之内发送方都在传数据，此时使用总的窗口数据量除以一个周期的时延即可求出最大数据传输速率，之后再和带宽作比较，选较小的</p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCbvn0.png" alt="pPCbvn0.png"></li></ul></li><li><p>分析</p><ul><li><img src="https://s1.ax1x.com/2023/08/02/pPCbz7T.png" alt="pPCbz7T.png"></li></ul></li></ul></li></ul><h3 id="五-介质访问机制（✪）"><a href="#五-介质访问机制（✪）" class="headerlink" title="五.介质访问机制（✪）"></a>五.介质访问机制（✪）</h3><h4 id="1-介质访问控制子层"><a href="#1-介质访问控制子层" class="headerlink" title="1.介质访问控制子层"></a>1.介质访问控制子层</h4><ul><li>介质访问控制的概述<ul><li>介质访问控制所要完成的主要任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。</li><li>用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制(Medium Access Control,MAC)子层。</li></ul></li><li>介质访问控制的分类<ul><li>介质访问控制的内容是，采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况。</li><li>常见的介质访问控制方法有信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制。<br>其中前者是静态划分信道的方法，而后两者是动态分配信道的方法。</li></ul></li></ul><h4 id="2-信道划分介质访问控制（✠）"><a href="#2-信道划分介质访问控制（✠）" class="headerlink" title="2.信道划分介质访问控制（✠）"></a>2.信道划分介质访问控制（✠）</h4><ul><li>概述<ul><li>信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备。</li><li>可以造成共享时间，共享空间或者既共享时间又共享空间的效果</li></ul></li><li>多路复用技术<ul><li>当传输介质的带宽超过传输单个信号所需的带宽时，人们就通过<u>在一条介质上同时携带多个传输信号的方法</u>来提高传输系统的利用率，也是实现信道划分介质访问控制的途径。</li><li>多路复用技术把多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源，提高了信道的利用率。</li><li>采用多路复用技术可把多个输入通道的信息整合到一个复用通道中，在接收端把收到的信息分离出来并传送到对应的输出通道<ul><li>复用技术在发送端需要一个复用器，让多个用户通过复用器使用一个大容量的共享信道进行通信；<br>在接收端需要使用一个分用器，将共享信道中传输的信息分别发送给相应的用户</li><li><img src="https://s1.ax1x.com/2023/08/02/pPPisWq.png" alt="pPPisWq.png"></li></ul></li></ul></li><li>信道划分<ul><li>信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道。</li></ul></li><li>频分多路复用（FDM）<ul><li>概述<ul><li>频分多路复用是一种将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路复用技术。</li><li>将传输媒体的总频带划分成多个子频带，每个子频带作为一个通信子信道。<br>频分复用的所有用户同时占用不同的频带资源发送数据。</li><li>每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽。</li><li>在实际应用中，为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”。</li></ul></li><li>频分多路复用的优点在于充分利用了传输介质的带宽，系统效率较高；<br>由于技术比较成熟，实现也较容易。</li><li>适用于传输模拟信号</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/28/pSUqpLR.png" alt="pSUqpLR.png"></li></ul></li></ul></li><li>时分多路复用（TDM）<ul><li>概述<ul><li>时分多路复用是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。</li><li>每个时间片由复用的一个信号占用，利用每个信号在时间上的交叉，就可以在一条物理信道上传输多个信号</li></ul></li><li>统计时分多路复用（STDM）<ul><li>又称异步时分多路复用，是TDM的一种改进，它采用STDM帧，<br>STDM帧并不固定分配时隙，而按需动态地分配时隙，</li><li>当终端有数据要传送时，才会分配到时间片，因此可以提高线路的利用率</li><li>如线路传输速率为8000b/s，4个用户的平均速率都为2000b/s，当采用TDM方式时，每个用户的最高速率为2000b/s<br>而在STDM方式下，每个用户的最高速率可达8000b/s。</li></ul></li><li>适用于传输数字信号</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/28/pSUqAJO.png" alt="pSUqAJO.png"></li></ul></li></ul></li><li>波分多路复用（WDM）<ul><li>概述<ul><li>波分多路复用即光的频分多路复用，它在一根光纤中传输多种<u>不同波长（频率）</u>的光信号<br>由于波长（频率）不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来</li><li>由于光波处于频谱的高频段，有很高的带宽，因而可以实现多路的波分复用</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/28/pSUqtyj.png" alt="pSUqtyj.png"></li></ul></li></ul></li><li>码分多路复用（CDM✪）<ul><li>概述（也称为码分多址，CDMA）<ul><li>码分多路复用是采用不同的编码来区分各路原始信号的一种复用方式。<br>与FDM和TDM不同，它既共享信道的频率，又共享时间。</li><li>将每个比特时间再划分成m个更短的时间槽，称为码片(Chip)，通常m的值是64或128</li><li>信号以向量形式发送，各向量之间需要正交（内积为0），向量中的分量，就是所谓的码片</li><li>任何一个码片向量和该码片向量自身的规格化内积都是1</li><li>任何一个码片向量和该码片反码的向量的规格化内积是-1</li></ul></li><li>码分多址的流程<ul><li>每个站点被指派一个唯一的m比特码片序列。<ul><li>发送1时，站点发送它自己的m比特码片序列</li><li>发送0时，站点发送其m比特码片序列的反码。</li><li>码片序列中的0可用-1表示</li></ul></li><li>如果有两个或多个站点同时发送数据，此时各路数据在信道中的值为这些向量的线性叠加</li><li>最后到达接收站点，分别与对应站点的码片序列进行规格化内积<br>为1发送的是1，为-1发送的是0，为0没有发送信息</li></ul></li><li>码分多址的举例，设m=8，此时A<ul><li>站点A的码片序列被指派为00011011（-1-1-1+1+1-1+1+1）<ul><li>则A站发送00011011就表示发送比特1</li><li>发送11100100就表示发送比特0</li></ul></li><li>令站点B为(-1-1+1-1+1+1+1-1)，当A站向C站发送数据1时，就发送了向量(-1-1-1+1+1-1+1+1)；<br>当B站向C站发送数据0时，就发送了向量(+1+1-1+1-1-1-1+1)</li><li>两个向量到了公共信道上就进行叠加，实际上就是线性相加，得到S+T=(0 0 -2 2 0 -2 0 2)</li><li>到达C站后，进行数据分离，如果要得到来自A站的数据，C站就必须知道A站的码片序列，让S与S+T进行规格化内积。根据叠加原理，其他站点的信号都在内积的结果中被过滤掉了，内积的相关项都是0，而只剩下A站发送的信号。得到S(S+T)=1</li><li>所以A站发出的数据是1。同理，如果要得到来自B站的数据，那么T(S+T)=-1<br>因此从B站发送过来的信号向量是一个反码向量，代表0</li></ul></li><li>特点<ul><li>码分多路复用技术具有频谱利用率高、抗干扰能力强、保密性强、语音质量好等优点<br>还可以减少投资和降低运行成本，主要用于无线通信系统，特别是移动通信系统。</li></ul></li><li>例题<ul><li>注：收到谁发送的序列，用谁的码片去求得数据。</li><li><img src="https://s1.ax1x.com/2023/01/28/pSUxkFI.png" alt="pSUxkFI.png"></li></ul></li></ul></li></ul><h4 id="3-随机访问介质访问控制（✪）"><a href="#3-随机访问介质访问控制（✪）" class="headerlink" title="3.随机访问介质访问控制（✪）"></a>3.随机访问介质访问控制（✪）</h4><ul><li><p>概述</p><ul><li>在随机访问协议中，不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。</li><li>在总线型网络中，当有两个或多个用户同时发送信息时，就会产生帧的冲突（碰撞），导致所有用户的发送均以失败告终</li><li>为了解决随机接入时发生的碰撞，每个用户需要按照一定的规则反复地重传它的帧，直到无碰撞的通过</li><li>这些规则即为随机访问介质访问控制协议，它们的核心思想是：<ul><li>胜利者通过争用获得信道，从而获得信息的发送权。因此，随机访问介质访问控制协议又称争用型协议。</li></ul></li><li>采用随机访问控制机制时，各结点之间的通信就可既不共享时间，又不共享空间<ul><li>因此其实质上是一种将广播信道转化为点到点信道的行为</li></ul></li></ul></li><li><p>ALOHA协议（非重点）</p><ul><li>纯ALOHA协议<ul><li>概述<ul><li>当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。</li><li>发生碰撞时让各站等待一段随机的时间，然后再进行重传</li><li>若再次发生碰撞，则需要再等待一段随机的时间，直到重传成功为止</li></ul></li><li>吞吐量<ul><li>假设网络负载(T时间内所有站点发送成功的和未成功而重传的帧数)为G<br>则纯ALOHA网络的吞吐量(T时间内成功发送的平均帧数)为$S=Ge^{-2G}$(e=0.5时取极大值)</li></ul></li></ul></li><li>时隙ALOHA协议<ul><li>概述<ul><li>把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙(Slot)，规定只能在每个时隙开始时才能发送一个帧。<br>从而避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率。</li><li>每个帧在到达后，一般都要在缓存中等待一段小于时隙的时间，然后才能发送出去</li><li>在一个时隙内有两个或两个以上的帧到达时，在下一个时隙将产生碰撞。碰撞后重传的策略与纯ALOHA的情况是相似的。</li></ul></li><li>吞吐量：S=$Ge^{-G}$。当G=1时取极大值，比纯ALOHA网络的吞吐量大了1倍。</li></ul></li></ul></li><li>CSMA协议（载波监听多路访问，非重点）<ul><li>每个站点在发送前都先监听一下共用信道，发现信道空闲后再发送</li><li>1-坚持CSMA（易受传播延迟的影响）<ul><li>一个结点要发送数据时，首先监听信道，如果信道空闲，那么立即发送数据</li><li>如果信道忙，那么等待，同时继续监听直至信道空闲</li><li>如果发生冲突，那么随机等待一段时间后，再重新开始监听信道。</li><li>“1-坚持”的含义是：监听到信道忙后，继续坚持监听信道；监听到信道空闲后，发送帧的概率为1，即立刻发送数据。</li></ul></li><li>非坚持CSMA（增加平均延迟）<ul><li>一个结点要发送数据时，首先监听信道，如果信道空闲，那么立即发送数据（此特性与“1-坚持”一样）</li><li><strong>如果信道忙，那么放弃监听，等待一个随机的时间后再重复上述过程。</strong></li><li>非坚持CSMA协议在监听到信道忙后就放弃监听，因此降低了多个结点等待信道空闲后同时发送数据导致冲突的概率<br>但也会增加数据在网络中的平均延迟。</li></ul></li><li>p坚持CSMA（用于时分信道）<ul><li>一个结点要发送数据时，首先监听信道，<strong>如果信道空闲，那么以概率p发送数据，以概率1-P推迟到下一个时隙</strong></li><li>如果信道忙，就持续监听，直至信道空闲</li><li>这个过程一直持续到数据发送成功或因其他结点发送数据而检测到信道忙为止，<br>若是后者，则等待下一个时隙再重新开始监听。</li><li>其目的是降低1-坚持CSMA协议中多个结点检测到信道空闲后同时发送数据的冲突概率</li></ul></li><li>区别<ul><li><img src="https://s1.ax1x.com/2023/08/02/pPPX56J.png" alt="pPPX56J.png"></li></ul></li></ul></li><li>CSMA/CD协议（载波监听多路访问/碰撞检测✪）<ul><li>概述（先听后发、边听边发，冲突停发，随机重发）<ul><li>适用于总线形网络或半双工网络环境。</li><li>载波监听是指每个站点在发送前和发送中都必须不停地检测信道<ul><li>站点要发送数据前先监听信道，只有信道空闲才能发送</li><li>在发送中检测信道是为了及时发现发送的数据是否发生了碰撞。</li></ul></li><li>碰撞检测(Collision Detection)就是边发送边监听<ul><li>如果监听到了碰撞，则立即停止数据发送，等待一段随机时间后，重新开始尝试发送数据。</li></ul></li></ul></li><li>争用期<ul><li>信号在最远两个端点之间往返传输的时间为${2 \tau}$称为争用期</li><li>在发送帧后至多经过时间${2 \tau}$就能知道所发送的帧有没有发生碰撞 。</li><li>每个站在自己发送数据之后的一小段时间内, 存在发生碰撞的可能性, 只有经过争用期这段时间还未检测到碰撞时, 才能确定这次发送不会发生碰撞。</li></ul></li><li>最小帧长（争用期内可发送的数据长度）<ul><li>在争用期内如果检测到碰撞，站点就会停止发送，此时已发送出去的数据一定小于最短帧长，因此凡长度小于这个最短帧长的帧都是由于冲突而异常中止的无效帧。</li><li><strong>最小帧长的计算公式为：最小帧长=总线传播时延×2×数据传输速率</strong></li><li>以太网规定最短帧长为64B，凡长度小于64B的帧都是由于冲突而异常中止的无效帧，收到这种无效帧时应立即丢弃。</li><li>如果只发送小于64B的帧，如40B的帧，那么需要在MAC子层中于数据字段的后面加入一个整数字节的填充字段，以保证以太网的MAC帧的长度不小于64B</li><li>例题<ul><li>保持等式两边不变<img src="https://s1.ax1x.com/2023/08/03/pPiKHHI.png" alt="pPiKHHI.png"></li></ul></li></ul></li><li>随机重发（采用截断二进制指数退避算法）<ul><li>在检测到碰撞之后需要进行一段退避时间才能进行重新发送，此时该时间由截断二进制指数退避算法确定</li><li>截断二进制指数退避算法的流程<ul><li>首先需要确定基本退避时间, 一般取两倍的总线端到端传播时延${2 \tau}$(即争用期)。</li><li>定义参数${k}$，它等于重传次数，<strong>但${k}$不超过10 , 即${k=\min [}$重传次数，10]。</strong><ul><li>当重传次数不超过10时，${k}$等于重传次数</li><li>当重传次数大于 10 时，${k}$就不再增大而一直等于10 </li></ul></li><li>从离散的整数集合${\left[0,1, \cdots, 2^{k}-1\right]}$中随机取出一个数${r}$，重传所需退避的时间就是${r}$倍的基本退避时间，即${2 r \tau}$。<ul><li>第1次重传时，k=1，随机数r从整数[0,1]中选择，因此适配器可选的重传推迟时间是0或${2\tau}$。</li><li>若再次发送碰撞，则在第2次重传时，随机数r从整数[0,1,2,3]中选择，因此重传推迟时间是在0，${2 \tau}$，${4  \tau}$，${6  \tau}$<br>这4个时间中随机地选取一个。以此类推。</li></ul></li><li>当重传达 16 次仍不能成功时, 说明网络太拥挤, 认为此帧永远无法正确发出, 抛弃此帧并向高层报告出错</li></ul></li><li>使用截断二进制指数退避算法可使重传需要推迟的平均时间随重传次数的增大而增大<br>也称动态退避，因而能降低发生碰撞的概率，有利于整个系统的稳定</li><li>例题，此时注意碰撞的次数为11，大于10，因此k=10，区间小于等于$2^{10}-1=1023$<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPiPdfI.png" alt="pPiPdfI.png"></li></ul></li></ul></li><li>CSMA/CD的流程<ul><li>准备发送：适配器从网络层获得一个分组，封装成帧，放入适配器的缓存。</li><li>检测信道：若检测到信道空闲，它就开始发送这个帧。<br>若检测到信道忙，它就持续检测直至信道上没有信号能量，然后开始发送这个帧。</li><li>在发送过程中，适配器仍持续检测信道。这里只有两种可能<ul><li>发送成功：在争用期内一直未检测到碰撞，这个帧肯定能发送成功。</li><li>发送失败：在争用期内检测到碰撞，此时立即停止发送，适配器执行指数退避算法，<br>等待此算法生成的一段随机时间后继续进行信道检测。若重传16次仍不能成功，则停止重传并向上报错。</li></ul></li></ul></li><li>适用范围<ul><li>应用于总线型的有线连接的局域网</li><li>使用此协议的以太网只能进行半双工通信，全双工的网络不需要使用此协议</li><li>不适用于无线局域网<ul><li>无线局域网中接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度的动态变化范围很大，因此若要实现碰撞检测，则硬件上的花费就会过大。</li><li>在无线通信中，并非所有的站点都能够听见对方，即存在“隐蔽站”问题。</li></ul></li></ul></li></ul></li><li>CSMA/CA协议（载波监听多路访问/碰撞避免✪）<ul><li>概述（适用于802.11无线局域网）<ul><li>碰撞避免”并不是指协议可以完全避免碰撞，而是指协议的设计要尽量降低碰撞发生的概率。<ul><li>由于802.11无线局域网不使用碰撞检测，一旦站点开始发送一个帧，就会完全地发送该帧，要采用碰撞避免技术降低碰撞的可能性。</li></ul></li><li>由于无线信道的通信质量远不如有线信道，802.11使用链路层ARQ方案（停止-等待协议）<br>即站点每通过无线局域网发送完一帧，就要在收到对方的确认帧后才能继续发送下一帧，以此来实现可靠传输</li><li>使用分布式协调功能（DCF），在DCF模式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获得发送权。因此DCF向上提供争用服务。为802.11无线局域网的默认方式（必须实现）</li></ul></li><li>帧间间隔<ul><li>为了尽量避免碰撞，802.11无线局域网规定，所有的站完成发送后，必须再等待一段很短的时间后（此时继续<br>监听）才能发送下一帧。这段时间称为帧间间隔 (IFS) </li><li>IFS的长短取决于站点要发送的帧的类型<ul><li>短帧间间隔SIFS<ul><li>最短的帧间间隔，用来分隔属于一次对话的各帧</li><li>发送<u>ACK帧、CTS帧</u>等帧时需要先经过一段SIFS的时延</li></ul></li><li>DCF帧间间隔DIFS<ul><li>为最长的帧间间隔，在DCF方式中作为开始进入争用窗口的一段时延</li><li>发送RTS预约帧需要先经过一段DIFS时延</li></ul></li></ul></li></ul></li><li>CSMA/CA退避算法以及其流程<ul><li>信道从忙态变为空闲态时，任何一个站要发送数据帧，不仅都要等待一个DIFS，而且之后要进入争用窗口，计算随机退避时间以便再次试图接入信道，因此降低了碰撞发生的概率。</li><li>当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不使用退避算法。<br>其他所有情况都必须使用退避算法<ul><li>在发送第一个帧前检测到信道忙；</li><li>每次重传</li><li>每次成功发送后要发送下一帧</li></ul></li><li>否则，站点执行CSMA/CA退避算法<ul><li>选取一个随机回退值，进入争用窗口</li><li>只要信道空闲，退避计时器就进行倒计时；一旦检测到信道忙，退避计时器就冻结</li><li>当某个站点的退避计时器减到0时（这时信道只可能是空闲的），该站点就发送整个帧并等待确认帧<br>其它站点的退避倒计时在此阶段又冻结</li></ul></li><li>发送站结束退避算法并成功发送一个数据帧后，存在两种可能<ul><li>若在规定时间内收到确认，就知道已发送的这个帧被目的站正确接收。<br>这时如果要发送第二个帧，需要再次执行CSMA/CA退避算法，随机选定一段退避时间并进入争用窗口。</li><li>若发送站在规定时间（由重传计时器控制）内没有收到确认帧ACK，就必须重传该帧<br>此时需要再次使用CSMA/CA协议争用该信道进行重传<ul><li>该过程直到收到确认帧，或经过若干次重传失败后放弃发送才结束。</li></ul></li></ul></li><li>争用窗口与退避算法执行的图片<ul><li><img src="https://s1.ax1x.com/2023/02/09/pSWn8m9.png" alt="pSWn8m9.png"></li></ul></li></ul></li><li>信道预约机制（RTS，CTS帧，处理屏蔽站问题）<ul><li>站A和B都在AP的覆盖范围内，但A和B相距较远，彼此都听不见对方。<br>当A和B检测到信道空闲时，都向AP发送数据，导致碰撞的发生，这就是隐蔽站问题。</li><li>为了避免该问题，802.11允许发送站对信道进行预约。<ul><li>源站要发送数据帧之前先广播一个很短的“请求发送”RTS控制帧<ul><li>它包括源地址、目的地址和这次通信所持续的时间，该帧能被其范围内包括AP在内的所有站点听到</li></ul></li><li>若信道空闲，等待一个SIFS间隔后，AP广播一个“允许发送”CTS控制帧，它包括这次通信所需的持续时间（从RTS帧复制），该帧也能被其范围内包括A和B在内的所有站点听到。<ul><li>CTS帧有两个目的<ul><li>给源站明确的发送许可</li><li>指示其他站点在预约期内不要发送。</li></ul></li></ul></li><li>B和其他站听到CTS后，在CTS帧中指明的时间内将抑制发送，当A收到CTS帧之后，在经过一段SIFS后将发送其第一个数据帧并等待确认帧</li></ul></li><li>无线局域网传输数据帧图片<ul><li><img src="https://s1.ax1x.com/2023/02/09/pSWumBd.png" alt="pSWumBd.png"></li></ul></li></ul></li></ul></li><li>CSMA/CD与CSMA/CA的区别<ul><li>对于冲突的处理<ul><li>CSMA/CD可以检测冲突，但无法避免；</li><li>CSMA/CA发送数据的同时不能检测信道上有无冲突，本结点处没有冲突并不意味着在接收结点处就没有冲突，只能尽量避免冲突</li></ul></li><li>传输介质不同：CSMA/CD用于总线形以太网，CSMA/CA用于无线局域网802.11</li><li>检测方式不同<ul><li>CSMA/CD通过电缆中的电压变化来检测</li><li>而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式。</li></ul></li><li>总结<ul><li>CSMA/CA协议的基本思想是在发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免出现碰撞。</li><li>CSMA/CD协议的基本思想是发送前监听，边发送边监听，一旦出现碰撞马上停止发送。</li></ul></li></ul></li></ul><h3 id="六-局域网（✪）"><a href="#六-局域网（✪）" class="headerlink" title="六.局域网（✪）"></a>六.局域网（✪）</h3><h4 id="1-局域网的概念（LAN）"><a href="#1-局域网的概念（LAN）" class="headerlink" title="1.局域网的概念（LAN）"></a>1.局域网的概念（LAN）</h4><ul><li>局域网的三个要素<ul><li>局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式<br>其中最重要的是介质访问控制方式，它决定着局域网的技术特性。</li><li>拓扑结构<ul><li>主要有以下4大类：①星形结构：②环形结构；③总线形结构；④星形和总线形结合的复合型结构。</li></ul></li><li>传输介质<ul><li>局域网可以使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质。</li></ul></li><li>介质访问控制方法<ul><li>主要有CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</li></ul></li></ul></li><li>局域网的两个子层（媒体接入控制MAC子层和逻辑链路控制LLC子层）<ul><li>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，</li><li>与接入传输媒体有关的内容都放在MAC子层，它向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问<br>主要功能是：组帧和拆帧、比特差错检测、寻址、竞争处理</li><li>LLC子层的主要功能是：建立和释放数据链路层的逻辑连接、提供与高层的接口、差错控制、给帧加序号（待确认的服务）</li></ul></li></ul><h4 id="2-以太网（IEEE-802-3✪）"><a href="#2-以太网（IEEE-802-3✪）" class="headerlink" title="2.以太网（IEEE 802.3✪）"></a>2.以太网（IEEE 802.3✪）</h4><ul><li>以太网的概述（802.3局域网简称为以太网）<ul><li>IEEE802.3标准是一种基带总线形的局域网标准，它描述物理层和数据链路层的MAC子层的实现方法。</li><li>以太网<strong>逻辑上</strong>采用总线形拓扑结构，物理拓扑是星形或拓展星形结构</li><li>以太网中的所有计算机共享同一条总线，信息以广播方式发送，包括发送结点在内的总线上的所有结点都能收到信息</li><li>为了保证数据通信的方便性和可靠性，以太网简化了通信流程并使用了CSMA/CD方式对总线进行访问控制。<br>当以太网工作在全双工模式下不需要使用CSMA/CD方式（高速以太网）</li><li>以太网采用两项措施以简化通信<ul><li><strong>采用无确认无连接的工作方式</strong>，不对发送的数据帧编号，也不要求接收方发送确认，<br>即以太网尽最大努力交付数据，提供的是不可靠服务，对于差错的纠正则由高层完成</li><li>发送的数据都使用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来。</li></ul></li></ul></li><li>以太网的传输介质与网卡（✪）<ul><li>传输介质<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPi1J2T.png" alt="pPi1J2T.png"></li><li>注意：10BASE-T非屏蔽双绞线以太网拓扑结构为星形网，星形网中心为集线器，<br>但使用集线器的以太网在逻辑上仍然是一个总线形网，属于一个冲突域。</li></ul></li><li>网卡（工作在数据链路层与物理层）<ul><li>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板【又称网络适配器或网络接口卡(NIC)】实现的。<br>网卡上装有处理器和存储器，是工作在数据链路层的网络组件。</li><li>网卡和局域网的通信是通过电缆或双绞线以串行方式进行的，而网卡和计算机的通信则是通过计算机主板上的I/O总线以并行方式进行的。因此，网卡的重要功能就是进行数据的<u>串并转换</u>。</li><li>网卡不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</li><li>全世界的每块网卡在出厂时都有一个唯一的代码，称为介质访问控制(MAC)地址，<br>这个地址用于控制主机在网络上的数据通信。数据链路层设备(网桥、交换机等)都使用各个网卡的MAC地址。</li><li>网卡控制着主机对介质的访问，因此网卡也工作在物理层，<br>因为它只关注比特，而不关注任何地址信息和高层协议信息。</li></ul></li></ul></li><li>以太网的MAC帧（✪）<ul><li>物理地址（MAC地址）<ul><li>MAC地址长6字节，一般用由连字符（或冒号）分隔的12个十六进制数表示，如02-60-8c-e4-b1-21</li><li>高24位为厂商代码，低24位为厂商自行分配的网卡序列号。</li><li>局域网的“地址”应是每个站的“名字”或标识符。</li></ul></li><li>以太网的MAC帧<ul><li>由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先要用硬件检查MAC帧中的MAC地址。<br>如果是发往本站的帧，那么就收下，否则丢弃。</li><li>以太网MAC帧格式有两种标准：DIX Ethernet V2标准(即以太网V2标准)和IEEE802.3标准。<ul><li>以太网V2标准（64-1518字节）<ul><li>前导码：使接收端与发送端时钟同步，在帧前面插入8字节<ul><li>第一个字段共7字节，是前同步码，用来快速实现MAC帧的比特同步</li><li>第二个字段是帧开始定界符，表示后面的信息就是MAC帧。<ul><li>注意：MAC帧并不需要帧结束符，因为以太网在传送帧时，各帧之间必须有一定的<u>间隙</u>。</li><li>因此，接收端只要找到帧开始定界符，其后面连续到达的比特流就都属于同一个MAC帧</li></ul></li></ul></li><li>帧的首部（14字节）<ul><li>目的地址与源地址：通常使用6字节(48bit)MAC地址</li><li>类型：2字节，指出数据域中携带的数据应交给哪个协议实体处理。</li></ul></li><li>数据部分：46~1500字节，包含高层的协议消息。<ul><li>由于CSMA/CD算法的限制，以太网帧必须满足最小长度为64字节，0一46字节时数据较少时必须加以填充</li><li>由CSMA/CD可知，以太网帧的最短帧长为64B，而MAC帧的首部和尾部的长度为18字节<br>所以数据字段最短为64-18=46字节。最大的1500字节是规定的。</li><li>填充：0~46字节，当帧长太短时填充帧，使之达到64字节的最小长度。</li></ul></li><li>帧的尾部：校验码(FCS)，4字节<ul><li>校验范围从目的地址段到数据段的末尾，算法采用32位循环冗余码(CRC)，<br>不但需要检验MAC帧的数据部分，还要检验目的地址、源地址和类型字段，但不校验前导码。</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPi8O5n.png" alt="pPi8O5n.png"></li></ul></li></ul></li><li>802.3帧格式<ul><li>与DIX以太帧格式的不同之处在于用长度域替代了DIX帧中的类型域，指出数据域的长度</li><li>在实践中，前述长度/类型两种机制可以并存，由于IEEE802.3数据段的最大字节数是1500，<br>所以长度段的最大值是1500，因此从1501到65535的值可用于类型段标识符。</li></ul></li></ul></li></ul></li></ul></li><li>高速以太网（速率达到或超过100Mb/s的以太网称为高速以太网）<ul><li>100BASE-T以太网<ul><li>100BASE-T以太网是在双绞线上传送100Mb/s基带信号的星形拓扑结构以太网</li><li>使用CSMA/CD协议，既支持全双工方式，又支持半双工方式</li><li>可在全双工方式下工作而无冲突发生，因此在全双工方式下不使用CSMA/CD协议</li><li>MAC帧格式仍然是802.3标准规定的。保持最短帧长不变，<br>但将一个网段的最大电缆长度减小到100m。帧间时间间隔从原来的9.6us改为现在的0.96us.</li></ul></li><li>吉比特以太网（千兆以太网）<ul><li>允许在1G/s速率下用全双工和半双工两种方式工作</li><li>在半双工方式下使用CSMA/CD协议（全双工方式则不使用）</li></ul></li><li>10吉比特以太网<ul><li>以太网不再使用铜线而只使用光纤作为传输媒体。只工作在全双工方式，因此没有争用问题，也不使用CSMA/CD协议</li></ul></li></ul></li></ul><h4 id="3-无线局域网（IEEE-802-11✠）"><a href="#3-无线局域网（IEEE-802-11✠）" class="headerlink" title="3.无线局域网（IEEE 802.11✠）"></a>3.无线局域网（IEEE 802.11✠）</h4><ul><li><p>无线局域网的组成</p><ul><li><p>有固定基础设施的无线局域网</p><ul><li><p>无线局域网802.11（Wi-Fi），802.11使用星形拓扑，其中心称为接入点(AP)，在MAC层使用CSMA/CA协议</p></li><li><p>无线局域网的最小构件是基本服务集（BSS），一个基本服务集包括一个接入点 (AP) 和若干移动站。</p><p>安装AP时，必须为该AP分配一个不超过32字节的服务集标识符(SSID)和一个信道</p></li><li><p>一个基本服务集覆盖的地理范围称为一个基本服务区(BSA)</p></li></ul></li><li><p>无固定基础设施移动自组织网络</p><ul><li>又称自组网络。自组网络没有上述基本服务集中的AP，而是由一些平等状态的移动站相互通信组成的临时网络</li><li>各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能。</li></ul></li></ul></li><li><p>802.11局域网的MAC帧（无线局域网采取有确认无连接的服务）</p><ul><li>分为数据帧，控制帧，管理帧<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPiOB7t.png" alt="pPiOB7t.png"></li></ul></li><li>数据帧<ul><li>MAC首部，共30字节。帧的复杂性都在MAC首部。</li><li>帧主体，即帧的数据部分，不超过2312字节。它比以太网的最大长度长很多。</li><li>帧检验序列FCS是尾部，共4字节。</li></ul></li></ul></li><li><p>802.11帧首部的地址字段（✪）</p><ul><li><strong>地址字段中的前三个地址由帧控制字段中的去往AP和来自AP决定</strong></li><li><strong>当去往AP的值为1时，地址1就是接收AP的MAC地址，否则就是目的移动站的MAC地址；</strong></li><li><strong>当来自AP的值为1时，地址2就是发送AP的MAC地址，否则就是源移动站的MAC地址。</strong></li><li><img src="https://s1.ax1x.com/2023/08/03/pPiOVYT.png" alt="pPiOVYT.png"></li><li>举例<ul><li><img src="https://s1.ax1x.com/2023/02/09/pSW6yHH.md.png" alt="pSW6yHH.md.png"></li></ul></li></ul></li></ul><h4 id="4-虚拟局域网VLAN（802-1Q）"><a href="#4-虚拟局域网VLAN（802-1Q）" class="headerlink" title="4.虚拟局域网VLAN（802.1Q）"></a>4.虚拟局域网VLAN（802.1Q）</h4><ul><li>可以把一个较大的局域网分割成一些较小的与地理位置无关的逻辑上的VLAN，以软件方式实现</li><li>可以同时隔离冲突域与广播域，一个VLAN是一个广播域</li><li>在以太网帧中插入一个4字节的标识符（插入在源地址字段和类型字段之间），称为VLAN标签<br>用来指明发送该帧的计算机属于哪个虚拟局域网。</li><li>插入VLAN标签的帧称为802.1Q帧。由于VLAN帧的首部增加了4字节，因此以太网的最大帧长从原来的1518字节变为1522字节。VLAN帧后12位为标识符VID（可表示4096个）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPij9Zn.png" alt="pPij9Zn.png"></li></ul></li></ul><h3 id="七-广域网"><a href="#七-广域网" class="headerlink" title="七.广域网"></a>七.广域网</h3><h4 id="1-广域网的基本概念"><a href="#1-广域网的基本概念" class="headerlink" title="1.广域网的基本概念"></a>1.广域网的基本概念</h4><ul><li>广域网比局域网多了一个网络层的层次（使用的协议主要在网络层）</li><li>广域网与局域网的区别<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPFSqgK.png" alt="pPFSqgK.png"></li></ul></li></ul><h4 id="2-PPP协议（点对点协议）"><a href="#2-PPP协议（点对点协议）" class="headerlink" title="2.PPP协议（点对点协议）"></a>2.PPP协议（点对点协议）</h4><ul><li>概述<ul><li>使用串行线路通信的<u>面向字节</u>的协议，该协议应用在直接连接两个结点的链路上。</li><li>通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同的解决方案。</li></ul></li><li>三个组成部分<ul><li>链路控制协议(LCP)：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</li><li>网络控制协议(NCP)：PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li><li>一个将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元(MTU)的限制。</li></ul></li><li>PPP帧的格式<ul><li>PPP是面向字节的，因而所有PPP帧的长度都是整数个字节</li><li><img src="https://s1.ax1x.com/2023/08/03/pPFVeVf.png" alt="pPFVeVf.png"></li></ul></li><li>ppp协议的特点<ul><li>PPP提供差错检测但不提供纠错功能，只保证无差错接收(通过硬件进行CRC校验)<br>它是不可靠的传输协议，因此也不使用序号和确认机制。</li><li>它仅支持点对点的链路通信，不支持多点线路。</li><li>PPP只支持全双工链路。</li><li>PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信。</li><li>PPP是面向字节的，当信息字段出现和标志字段一致的比特组合时，PPP有两种不同的处理方法<ul><li>若PPP用在异步线路（默认），则采用字符填充法；</li><li>若PPP用在SONET/SDH等同步线路，则协议规定采用硬件来完成比特填充(和HDLC的做法一样)。</li></ul></li></ul></li></ul><h3 id="八-数据链路层设备（✪）"><a href="#八-数据链路层设备（✪）" class="headerlink" title="八.数据链路层设备（✪）"></a>八.数据链路层设备（✪）</h3><h4 id="1-网桥"><a href="#1-网桥" class="headerlink" title="1.网桥"></a>1.网桥</h4><ul><li>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段</li><li>网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域（又称冲突域）。</li><li>网桥必须具有路径选择的功能，接收到帧后，要决定正确的路径，将该帧转送到相应的目的局域网站点。</li></ul><h4 id="2-交换机的原理与特点"><a href="#2-交换机的原理与特点" class="headerlink" title="2.交换机的原理与特点"></a>2.交换机的原理与特点</h4><ul><li>原理<ul><li>以太网交换机的实质是一种多端口网桥<ul><li>网桥：隔离冲突域，但只有一个发送端口一个接收端口</li></ul></li><li>检测从以太端口来的数据帧的源和目的地的MAC（介质访问层）地址，然后与系统内部的动态查找表进行比较，</li><li>若数据帧的源MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</li></ul></li><li>特点<ul><li>以太网交换机的每个端口都直接与单台主机相连（网桥的端口往往连接到一个网段），并且一般都工作在全双工方式。</li><li>以太网交换机能同时连通多对端口，使每对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</li><li>以太网交换机是一种即插即用设备，其内部的帧的转发表是通过自学习算法自动地逐渐建立起来的。</li><li>以太网交换机由于使用专用的交换结构芯片，交换速率较高。</li><li>以太网交换机独占传输媒体的带宽。<ul><li>若交换机连接的10Mb/s的共享式以太网，若共有10个用户，则每个用户能够占有10MB/S带宽</li><li>且总带宽为10*10=100MB/S</li></ul></li></ul></li><li>两种交换模式<ul><li>直通式交换机<ul><li>只检查帧的目的地址，这使得帧在接收后几乎能马上被传出去。</li><li>这种方式速度快，但缺乏智能性和安全性，也无法支持具有不同速率的端口的交换。</li><li>例<ul><li>此时为直通交换只检查目的地址6字节为：6*8/v，选B</li><li><img src="https://s1.ax1x.com/2023/08/03/pPFntX9.png" alt="pPFntX9.png"></li></ul></li></ul></li><li>存储转发式交换机<ul><li>先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，</li><li>确认无误后通过查找表转换成输出端口将该帧发送出去。如果发现帧有错，那么就将其丢弃。</li><li>优点是可靠性高，并能支持不同速率端口间的转换，缺点是延迟较大。</li></ul></li></ul></li></ul><h4 id="3-交换机的自学习功能"><a href="#3-交换机的自学习功能" class="headerlink" title="3.交换机的自学习功能"></a>3.交换机的自学习功能</h4><ul><li>决定一个帧是应该转发到某个端口还是应该将其丢弃称为过滤</li><li>决定个顺应该被移动到哪个接口称为转发</li><li>交换机的过滤和转发借助于交换表完成；<br>至少包含：一个MAC地址；连通该MAC地址的交换机端口。</li><li>自学习流程：<ul><li>记录帧从相应端口进入交换机的源地址（建立地址与端口对应的交换表）</li><li>在查找到转发表没有相关目的地址的情况下，从除接收端口以外的其它所有端口转发出去</li><li>在有效时间之后将自动删除交换机的表项</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/08/03/pPFmp5T.png" alt="pPFmp5T.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机网络第三章-数据链路层&quot;&gt;&lt;a href=&quot;#计算机网络第三章-数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络第三章 数据链路层&quot;&gt;&lt;/a&gt;计算机网络第三章 数据链路层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：计算机网络第三章数据链路层的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络第二章-物理层</title>
    <link href="http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2024-08-11T15:42:20.000Z</published>
    <updated>2024-08-11T16:22:14.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络第二章-物理层"><a href="#计算机网络第二章-物理层" class="headerlink" title="计算机网络第二章 物理层"></a>计算机网络第二章 物理层</h2><blockquote><p>计算机学科基础：计算机网络第二章物理层的学习笔记</p></blockquote><span id="more"></span><h3 id="一-通信基础（✪）"><a href="#一-通信基础（✪）" class="headerlink" title="一.通信基础（✪）"></a>一.通信基础（✪）</h3><h4 id="1-基本概念（✠）"><a href="#1-基本概念（✠）" class="headerlink" title="1.基本概念（✠）"></a>1.基本概念（✠）</h4><ul><li>消息、数据和信号<ul><li>消息：需要由计算机处理和传输的文字、图片、音频和视频等内容。</li><li>数据是指传送信息的实体，计算机只处理二进制数据（0/1）</li><li>信号则是数据的电气或电磁表现，是数据在传输过程中的存在形式。</li></ul></li><li>数字信号和模拟信号<ul><li>离散的信号称为数字信号，是用一系列断续变化的电压脉冲或光脉冲来表示。<br>数字信号可看做基波与高次谐波的叠加。如二进制数</li><li>连续变化的信号称为模拟信号，用一系列连续变化的电磁波或电压信号来表示，如声音</li></ul></li><li>信道（信号传输的媒介）<ul><li>按照传输信号形式的不同：数字信道，模拟信道</li><li>按照传输介质的不同：无线信道，有线信道</li><li>按照通信双方的交互方式：单向通信、半双工通信、全双工通信<ul><li>单向通信：只能有一个方向的通信（无线电广播和电视广播）</li><li>半双工通信：发送信息不能同时进行（对讲机、总线型以太网）</li><li>全双工通信：可以同时通信（有线电话、交换式以太网）</li></ul></li></ul></li><li>基带信号和宽带信号<ul><li>由信源发出的原始信号称为基带信号，也就是基本频带信号。<ul><li>基带信号将数字信号1和0直接用高电平和低电平表示</li></ul></li><li>宽带信号是基带信号调制之后形成的频分复用模拟信号</li></ul></li><li>基带传输，频带传输与宽带传输<ul><li>基带传输：将基带信号直接传送到数字信道上（不需要进行调制，用于局域网）</li><li>频带传输：将基带信号进行调制后形成了模拟信号，之后送到模拟信道上传输<br>适用于远距离传输与无线传输</li><li>宽带传输<ul><li>借助频带传输，可将链路容量分解成两个或多个信道，每个信道可以携带不同的信号</li><li>宽带传输中所有的信道能同时互不干扰地发送信号，链路容量大大增加。</li><li>比如把信道进行频分复用，划分为2条互不相关的子信道，<br>分别在两条子信道上同时进行频带传输，链路容量就大大增加了</li></ul></li></ul></li><li>串行传输与并行传输<ul><li>串行传输：只有一条数据传输线路，数据逐比特依次传输（远距离通信通常采用串行传输）</li><li>并行传输：若干比特通过多条通信信道同时传输。并行传输的成本高，仅适用于短距离传输（计算机内部的数据传输）<ul><li>多条数据传输线路，数据传输线路的数量也称为数据总线宽度（8/16/32/64）。</li><li>计算机中的网卡具有串行传输和并行传输的功能，网卡可以进行串并转换。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/24/pSY43rD.png" alt="pSY43rD.png"></li></ul></li></ul></li></ul></li><li>同步传输和异步传输<ul><li>同步传输<ul><li>以比特为传输单位，数据块以比特流的形式传输，字节之间没有间隔，也没有起始位和终止位</li><li>要求收发双方对表示比特的信号的时间长度达成一致。接收方在比特信号的中间时刻进行采样，<br>收发双方时钟频率的误差累积会造成比特信号采样时刻的严重偏移。</li><li>在同步传输方式中实现收发双方的时钟同步，可以采取以下方法：<ul><li>外同步：在收发双方之间增加一条时钟线，多发一路时钟信号。</li><li>内同步：发送端将时钟信号编码到发送数据中一起发送。（如曼彻斯特编码和差分曼彻斯特编码都含时钟编码）</li></ul></li></ul></li><li>异步传输：以字节为传输单位，但字节之间的时间间隔并不固定，给每个字节添加起始位和结束位<br>接收端只在每个字节的起始处对字节内的比特实现同步。</li></ul></li><li>码元<ul><li>码元是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，<br>代表不同离散数值的基本波形，是数字通信中数字信号的计量单位</li><li>这个时长内的信号称为k进制码元，而该时长称为码元宽度。1码元可以携带若干比特的信息量<ul><li>例如，在使用二进制编码时，只有两种不同的码元：一种代表0状态，另一种代表1状态。</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/24/pSYqWK1.png" alt="pSYqWK1.png"></li></ul></li></ul></li><li>码元传输速率，信息传输速率（✪）<ul><li>速率也称数据率，指的是数据传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。</li><li>码元传输速率。又称波特率，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），<br>单位是波特(Bud)<ul><li>1波特表示数字通信系统每秒传输一个码元。码元可以是多进制的，也可以是二进制的，码元速率与进制数无关。</li></ul></li><li>信息传输速率。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的比特数，单位是比特/秒(b/s)。<ul><li>信息的传输速率=波特率*一个码元所含的比特数</li></ul></li><li>例题<ul><li>此时为曼彻斯特编码，每个比特中间会产生一次跳变，相当于是1个比特由两个码元表示，因此信息速率为$\frac{1}{2}$波特率<ul><li><img src="https://s1.ax1x.com/2023/07/31/pP9Cy7R.png" alt="pP9Cy7R.png"></li></ul></li></ul></li></ul></li></ul><h4 id="2-信号失真"><a href="#2-信号失真" class="headerlink" title="2.信号失真"></a>2.信号失真</h4><ul><li><p>任何实际的信道都是不理想的，信号在信道的传输中会不可避免的出现失真。</p></li><li><p>造成信号失真的主要因素</p><ul><li><p>码元的传输速率越高，信号经过传输后的失真就越严重</p></li><li><p>信号的传输距离越远，信号经过传输后的失真就越严重</p></li><li><p>噪音干扰越大，信号经过传输后的失真就越严重</p></li><li><p>传输媒体的质量越差，信号经过传输后的失真就越严重</p></li></ul></li></ul><h4 id="3-奈氏定理（✪）"><a href="#3-奈氏定理（✪）" class="headerlink" title="3.奈氏定理（✪）"></a>3.奈氏定理（✪）</h4><ul><li><p>奈氏定理解决的问题：避免码间串扰</p><ul><li>对于每一种信道来说，能通过的频率的范围是有限的，信号中的许多高频分量往往不能通过信道</li><li><p>如果数字信号中的高频分量在传输时受到衰减甚至不能通过信道，则接收端接收到的波形的前沿和后沿就变得不那么陡峭，<br>每一个码元所占的时间界限也不再明确，而是前后都拖了尾巴。<br>此时在接收端接收到的信号波形就失去了码元之间的清晰界限，这种现象成为码间串扰。</p></li><li><p>如果信道的频带越宽，则能够通过的信号的高频分量越多，那么码元的传输速率就可以更高，就不会导致码间串扰。</p></li><li>因此提出了奈氏准则：解决理想低通信道（无噪声，带宽受限）的频率带宽和该信道的最高码元传输速率的问题。</li></ul></li><li><p>奈氏定理内容</p><ul><li><strong>理想低通信道下的极限数据传输速率</strong>=$2W(码元/s)=2W1og_2V(单位为b/s)$</li><li>一般来说需要将以波特率为单位的速率转换为以比特每秒为单位的速率<ul><li>波特率B：码元传输速率=调制速率=波形数率=符号速率</li><li>信息的传输速率=波特率*一个码元具有的比特数量（信息量）</li><li>一个码元所携带的比特数量=$\log_{2}{X}$  (X为调制出的码元种数)</li><li>码元种数=一个码元所取的有效离散值=码元的波形个数</li></ul></li><li>W为理想低通信道的带宽</li><li>V表示每个码元离散电平的数目，即每个码元所带的信息量</li><li>在任何信道中，若码元的传输速率超过此上限(2倍带宽)，则会出现严重的码间串扰问题</li><li>总结：由于码元传输速率受奈氏准则的制约，所以要提高数据传输速率，就必须设法使每个码元携带更多比特的信息量，<br>此时就需要采用多元制的调制方法。</li></ul></li><li><p>例题</p><ul><li><img src="https://s1.ax1x.com/2023/01/28/pSUvGse.png" alt="pSUvGse.png"></li></ul></li></ul><h4 id="4-香农公式（✪）"><a href="#4-香农公式（✪）" class="headerlink" title="4.香农公式（✪）"></a>4.香农公式（✪）</h4><ul><li>香农公式解决的问题：带宽受限且在噪声干扰下的极限信息传输速率<ul><li>根据奈氏准则，在理想信道上，为了提升信道的传输速率，就需要使每个码元可以表示更多的信息量（提高每个码元携带比特的数量），可以采取更复杂信号调制方法实现。但是信息的传输速率并不能无限制的提高，因为有噪声的干扰。</li><li>香农公式推导出了频率带宽受限且有高斯白噪声干扰下的信道的极限信息传输速率，用此速率进行传输时，可以不产生误差</li></ul></li><li>香农公式内容<ul><li>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率：${C=W \log _{2}(1+\frac{S}{N})}$ </li><li>C: 信道的极限信息传输速率 (单位为${\mathbf{b} / \mathbf{s}}$)</li><li>W: 信道的频率带宽 (单位为${\mathrm{Hz}}$)</li><li>S: 信道内所传信号的平均功率</li><li>N: 信道内的高斯噪声功率</li><li>计算时公式中的信噪比$\frac{S}{N}$必须是无量纲的常数值<ul><li>如果题目中的信噪比没有单位，直接代入计算即可</li><li>如果题目中的信噪比的单位是db，则需要通过公式转换为无量纲的值后再代入此，$信噪比(单位分贝){=10 \log _{10}\left(\frac{S}{N}\right)}$</li></ul></li></ul></li><li><p>对于香农公式的说明</p><ul><li><p>如果已知信噪比的分贝值，需用公式求出$\frac{S}{N}$的值。</p></li><li><p>信道的频率带宽或信道中的信噪比越大，信道的极限信息传输速率就越高。</p></li><li><p>信道的实际传输速率要比香农公式中的极限传输速率低不少，因为信道还要受到各种脉冲干扰和信号衰减。</p></li><li>总结：在频带带宽一定的情况下，提高信道的传输速率需要采取多元制（更复杂的调制技术）并提高信噪比。</li></ul></li><li><p>例题</p><ul><li><p><strong>对于算极限数据传输速率的题目，如果出现信噪比而不涉及信号的状态，则只需要考虑利用香农公式来求解</strong><br><strong>如果在出现信噪比的同时还出现了信号的状态，则此时还需要用奈氏公式，计算后取速率较小的值</strong></p><ul><li><p>本题需要将两种公式分别列出后计算。由于信噪比的单位是分贝，此时需要用公式转换为无量纲的值</p><ul><li><img src="https://s1.ax1x.com/2023/01/28/pSUbMPU.png" alt="pSUbMPU.png"></li></ul></li><li><p>本题涉及了信号的状态数（二进制信号，说明一个比特有两个信号数）此题需要列出两种公式并选择其中最小的值作为最大的速率，信噪比无量纲，直接代入公式计算即可</p><ul><li><img src="https://s1.ax1x.com/2023/07/31/pPpvNtS.png" alt="pPpvNtS.png"></li></ul></li><li><p>本题只有信噪比给出不涉及码元与比特数之间的关系，直接用香农定理以及量纲转换求出即可，选C</p><ul><li><img src="https://s1.ax1x.com/2023/07/31/pPpzVPO.png" alt="pPpzVPO.png"></li></ul></li></ul></li></ul></li></ul><h4 id="5-编码与调制（✠）"><a href="#5-编码与调制（✠）" class="headerlink" title="5.编码与调制（✠）"></a>5.编码与调制（✠）</h4><ul><li>把数据变为数字信号称为编码，把数据变为模拟信号称为调制<ul><li>编码：对数字基带信号的波形进行变换，使其能够与信道特性相适应，调制后的信号仍是数字基带信号</li><li>调制：将数字基带信号的频率范围利用载波搬移到更高的频段，并转换为模拟信号，使其能够在模拟信道中传输。</li></ul></li><li>数字数据编码成为数字信号<ul><li>归零编码  (RZ)<ul><li>高电平表示1，低电平表示0</li><li>信号在每个码元期间(中间)会回归到零电平。</li><li>归零编码相当于将时钟信号编码在了数据之内，也称为自同步信号。</li><li>缺点：大部分的带宽为了传输归零而浪费掉了。</li></ul></li><li>非归零编码（NRZ）<ul><li>信号在每个码元期间不会回归到零电平。</li><li>此编码效率最高，但是需要增加时钟信号线来解决同步问题。</li></ul></li><li>反向非归零编码（NRZI）<ul><li>与非归零编码的区别在于用信号的翻转代表0，信号保持不变则代表1</li><li>既能传输时钟信号，又能尽量不损失系统带宽</li></ul></li><li>曼彻斯特编码（✪）<ul><li>在每个码元的中间时刻电平都会发生跳变（即可作为同步信号，又可作为数据信号）</li><li>自行定义向上跳变时和向下跳变时的表示数据。</li><li>比如设中间时刻上变化为0，向下为1。则直接看码元中间是向上还是向下，向上变化为0，向下变化为1。</li><li>10Mb/s的传统以太网采用的是曼彻斯特编码。</li><li>例<ul><li><img src="https://s1.ax1x.com/2023/07/31/pP9J8u4.md.png" alt="pP9J8u4.md.png"></li></ul></li></ul></li><li>差分曼彻斯特编码（✪）<ul><li>在每个码元的中间时刻都会进行跳变（仅作为同步信号）</li><li><strong>数据信号的表示在于每一个码元开始处是否有电平跳变，无跳变表示1，有跳变表示0</strong></li><li>可在题目中设置第一个码元是0还是1，之后的码元都可以根据波形来判断</li><li>在噪声干扰环境下比曼彻斯特编码更容易检测。</li><li>例<ul><li><img src="https://s1.ax1x.com/2023/07/31/pP9ARyT.md.jpg" alt="pP9ARyT.md.jpg"></li></ul></li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/30/pPpIkp6.png" alt="pPpIkp6.png"></li></ul></li></ul></li><li>数字数据调制成为模拟信号（✪）<ul><li>基本调制方法<ul><li>调幅(ASK)：通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。</li><li>调频(FSK)：通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。</li><li>调相(PSK)。通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/24/pSYOJ6s.png" alt="pSYOJ6s.png"></li></ul></li></ul></li><li>正交振幅调制(QAM)：在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。（✪）<ul><li>使一个码元可以表示多个比特的信息量。</li><li>因为载波的频率和相位是相关的，所以载波的频率和相位不能进行混合调制。<br>载波的振幅和相位可以结合起来一起调制，被称为正交振幅调制（QAM）</li><li>设波特率为B，采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输速率R为：$R = B \log _ { 2 } ( m n )$</li><li>例：易错，本题为无噪声环境，应该优先考虑奈氏定理=2<em>3\</em>$log_216$=24<ul><li><img src="https://s1.ax1x.com/2023/07/31/pP9EkX8.png" alt="pP9EkX8.png"></li></ul></li></ul></li></ul></li><li>模拟数据编码为数字信号（主要是脉冲编码调制PCM）（✪）<ul><li>这种编码方式最典型的例子是常用于对<strong>音频信号</strong>进行编码的脉冲编码调制(PCM)。它主要包括三个步骤，即采样、量化和编码。</li><li>采样是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。<ul><li>当采样的频率大于或等于模拟数据的频带带宽（最高变化频率）的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。（采样定理）</li></ul></li><li>量化是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li><li>编码是把量化的结果转换为与之对应的二进制编码。</li><li>例题<ul><li>求最大传输速率，此时24无效，大于2*8（不符合采样定理）$V=2<em>8</em>log_28=48$（无噪声可以用奈氏定理）<ul><li><img src="https://s1.ax1x.com/2023/07/31/pP9SufU.png" alt="pP9SufU.png"></li></ul></li><li>求最大的传输速率，但此时没有说是理想低通或无噪声信道下，不能用奈氏定理（因此不乘2）选B<ul><li><img src="https://s1.ax1x.com/2023/07/31/pP9pMUP.png" alt="pP9pMUP.png"></li></ul></li></ul></li></ul></li><li>模拟数据调制为模拟信号<ul><li>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。</li></ul></li></ul><h4 id="6-三种数据交换方式（✪）"><a href="#6-三种数据交换方式（✪）" class="headerlink" title="6.三种数据交换方式（✪）"></a>6.三种数据交换方式（✪）</h4><ul><li>电路交换（电话交换机的交换方式）<ul><li>电路交换的流程：建立连接、数据传输、连接释放（在数据传输的过程中，用户始终占用端到端的固定传输带宽）</li><li>电路交换不提供差错控制功能</li><li>电路交换的优点<ul><li><strong>传输时延较小：数据传输量较大时明显</strong></li><li>有序传输：不存在失序问题</li><li>没有冲突：不同的通信双方拥有不同的信道</li><li>适用范围广：既适用于传输模拟信号，又适用于传输数字信号</li><li>实时性强：通信双方之间的物理通路一旦建立，双方就可以随时通信</li><li>控制简单</li></ul></li><li>电路传输的缺点<ul><li>建立连接时间长：不利于计算机通信</li><li>线路独占：信道利用率低</li><li>灵活性差</li><li>难以规格化</li></ul></li><li>总结<ul><li>由于计算机之间的数据传输是突发式的，使用电路交换来传输计算机数据的效率很低</li><li>若要连续传送大量的数据，并且数据传送的时间远长于建立连接的时间，则电路交换具有更高的传输效率</li><li>用户线是电话用户专用的，电话交换机之间的中继线是许多用户共享的<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS1WkWQ.md.png" alt="pS1WkWQ.md.png"></li></ul></li></ul></li></ul></li><li>报文交换<ul><li>报文交换采用存储转发的方式，单位是报文（携带源地址，目的地址信息）<ul><li>存储转发：交换设备收到报文之后先存储整个报文，存储完成之后再选择链路转发</li></ul></li><li>报文交换的优点<ul><li>无需建立连接</li><li>动态分配链路</li><li>链路可靠性强</li><li>线路利用率高</li><li>提供多目标服务</li></ul></li><li>报文交换的缺点<ul><li>存在转发时延</li><li><strong>报文交换对报文的大小没有限制，需要网络结点有较大的存储空间</strong><ul><li>由于其对报文的大小没有限制，数据经过网络的传输延迟长而且不固定，因此报文交换不能用于语音数据传输</li></ul></li></ul></li></ul></li><li><p>分组交换</p><ul><li>分组交换采用存储转发的方式，限制了每次传送的数据块大小的上限，并且加上一些必要的控制信息（地址信息）构成分组（Packet）</li><li>分组交换的过程：网络结点根据控制信息把分组送到下一个结点，下一个结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。</li><li><p>分组交换的优点</p><ul><li>无建立时延</li><li>线路利用率高</li><li>相对于报文交换简化了存储（缓冲区）管理</li><li>加速传输（<strong>相较于报文交换而言</strong>）</li><li>减少了出错概率和重发数据量</li></ul></li><li><p>分组交换的缺点</p><ul><li>分组首部带来了额外的传输开销，增加时延</li><li>存储转发造成了一定的时延</li><li><strong>当分组交换采用数据报服务时，可能会出现失序，丢失或重复分组等问题</strong><ul><li>当分组交换采用虚电路时，有三个虚电路的过程</li></ul></li></ul></li></ul></li><li>区别<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS1fVhD.png" alt="pS1fVhD.png"></li></ul></li><li>计算分组交换时延（♚）<ul><li>计算分组交换时延时，首先计算出分组的数量，在第一个链路上需要计算所有分组的发送时延，之后经过的链路只需计算单个分组的发送时延</li><li>总发送时延=在一条链路上所有分组的发送时延+在一条链路上一个分组发送时延*路由器的数量（链路数-1）</li><li>报文交换的时延=在一条链路上的发送时延*链路数</li><li>例题：<ul><li>本题需要注意B=8b<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS15rUP.png" alt="pS15rUP.png"></li></ul></li></ul></li></ul></li></ul><h4 id="7-分组交换的两种方式（✪）"><a href="#7-分组交换的两种方式（✪）" class="headerlink" title="7.分组交换的两种方式（✪）"></a>7.分组交换的两种方式（✪）</h4><ul><li>数据报方式与虚电路方式均由网络层提供    </li><li><p>数据报交换（无连接的数据报方式）</p><ul><li><p>流程</p><ul><li>在端系统中的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据报分组(即网络层的PDU).</li><li>中间结点存储分组很短一段时间，找到最佳的路由后，尽快转发每个分组。</li><li>不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/31/pPpLoi4.png" alt="pPpLoi4.png"></li></ul></li></ul></li><li><p>数据报方式的特点</p><ul><li>不需要建立连接，可随时发送和接收</li><li>属于不可靠传输（没有确认机制，可能引发丢失与失序问题）</li><li>发送的分组需要包括源地址与目的地址，以便可以独立传输</li><li>存储转发具有排队时延，发生拥塞时，时延增大</li><li>网络具有冗余路径，对故障的适应能力强，可以用在出错率较高的传输系统</li><li>网络吞吐量较高</li><li>资源利用率较高</li></ul></li></ul></li><li><p>虚电路交换（面向连接的虚电路方式）</p><ul><li><p>流程：虚电路建立、数据传输与虚电路释放</p><ul><li><p>在分组发送之前，要求在发送方和接收方建立一条<strong>逻辑上相连的虚电路</strong>，并且连接一旦建立，就固定了虚电路所对应的物理路径。</p><ul><li>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路，以区别于本系统中的其他虚电路。</li><li>为进行数据传输，主机A与主机B之间先建立一条逻辑通路，主机A发出一个特殊的“呼叫请求”分组，该分组通过中间结点送往主机B，若主机B同意连接，则发送“呼叫应答”分组予以确认。</li></ul></li><li><p>虚电路建立后，主机A就可向主机B发送数据分组，主机B也可在该虚电路上向主机A发送数据。</p><ul><li>在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号，以区别于其他虚电路上的分组。</li><li>在虚电路网络中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。</li><li>数据的传输是双向进行的，上述信息是在虚电路的建立过程中确定的。</li></ul></li><li><p>传送结束后主机A通过发送“释放请求”分组来拆除虚电路，逐段断开整个连接。</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/31/pPpOiQI.png" alt="pPpOiQI.png"></li></ul></li></ul></li><li><p>虚电路传输的特点</p><ul><li>虚电路连接的建立和拆除需要时间开销，虚电路对于长时间、频繁的数据交换的效率较高</li><li>虚电路的路由选择体现在连接建立阶段，连接建立之后就确定了传输数据</li><li><strong>虚电路属于可靠连接（可靠性由网络保证，有确认机制），能够确保每个分组正确并且有序到达，并且还可以进行流量控制</strong></li><li>拓展性差，发生故障影响较大，不宜用在出错率较高的传输系统</li><li><strong>虚电路的分组首部不包含目的地址，包含的是虚电路表示符，开销较小</strong></li><li>每个结点到其它结点之间的链路可以同时有若干虚电路通过，也可以与多个结点之间建立虚电路（不需要对每条虚电路预分配带宽）<ul><li>每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务</li></ul></li></ul></li></ul></li><li>数据报服务和虚电路服务的区别<ul><li><img src="https://s1.ax1x.com/2023/08/02/pPP7jp9.png" alt="pPP7jp9.png"></li></ul></li></ul><h3 id="二-传输介质（✠）"><a href="#二-传输介质（✠）" class="headerlink" title="二.传输介质（✠）"></a>二.传输介质（✠）</h3><h4 id="1-各种传输介质"><a href="#1-各种传输介质" class="headerlink" title="1.各种传输介质"></a>1.各种传输介质</h4><h5 id="①导向型传输媒体"><a href="#①导向型传输媒体" class="headerlink" title="①导向型传输媒体"></a>①导向型传输媒体</h5><ul><li><p>双绞线</p><ul><li><p>把两根互相绝缘的铜导线按一定的密度互相绞合构成了双绞线</p></li><li><p>绞合可以减少对相邻导线的电磁干扰</p></li><li><p>对双绞线外部加上一层金属丝屏蔽层，则称为屏蔽双绞线电缆（STP），可进一步提高抗电磁干扰的能力</p><p>没有的话则为非屏蔽双绞线电缆（UTP）</p></li><li><p>双绞线的带宽取决于铜线的粗细和传输的距离</p></li><li><p>适用范围</p><ul><li>模拟传输和数字传输都可以使用双绞线</li><li>100BaseT 快速以太网使用的导向传输介质是双绞线</li></ul></li><li><p>双绞线对于模拟传输距离太长的话需要添加放大器设备，以便将衰减了的信号放大到合适的强度 </p><p>对于数字传输距离太长的话需要添加中继器设备，以便对失真的信号进行整形</p></li></ul></li><li><p>同轴电缆</p><ul><li>同轴电缆由内导体、绝缘层、外屏蔽层和外部保护层组成。</li><li><strong>同轴电缆具有较好的抗干扰性（屏蔽性更好），被广泛的用于高速率数据传输。</strong></li><li>同轴电缆一般有以下的两类：<ul><li>50Ω阻抗的基带同轴电缆：用于数字传输，局域网</li><li>75Ω阻抗的宽带同轴电缆：用于模拟传输，有线电视系统</li></ul></li></ul></li><li><p>光纤</p><ul><li><strong>光纤是光导纤维的简称，是用高透明度的石英玻璃拉成的柔软细丝，由包层（通常直径不超过125um）和纤芯（8—100um）组成的双层通信圆柱形传输媒体</strong></li><li>光纤通信是利用光脉冲在光纤中的传递来进行通信的，有光脉冲相当于比特1，没有相当于比特0。</li><li>光波在光纤中不断发生全反射，就可以沿着光纤传输下去<ul><li><img src="https://s1.ax1x.com/2023/01/24/pSY20YV.md.png" alt="pSY20YV.md.png"></li></ul></li><li><p>单模光纤和多模光纤</p><ul><li>有多个入射角度射入光纤时可产生多条光波在同一条光纤中传输（不断全反射），称为多模光纤。<ul><li>多模光纤的光源为发光二极管</li><li>光脉冲在多模光纤中传输时会逐渐展宽，造成失真，只适合在近距离传输</li></ul></li><li>当光纤的直径减小到只有一个光的波长，则光波会一直向前传播而不会发生多次反射，称为单模光纤。<ul><li>单模光纤的光源为半导体激光器，其制造成本较高</li><li>单模光纤的衰减较小，可以不必采用中继器，适合远距离传输</li></ul></li></ul></li><li><p>光纤的优点</p><ul><li>通信容量非常大，传输速率十分大</li><li>抗雷电和电磁干扰性能好。在有大电流脉冲干扰的环境下十分稳定</li><li>传输损耗小。中继距离长，对远距离传输十分经济</li><li>无串音干扰，保密性好。</li><li>体积小，重量轻。</li></ul></li></ul></li></ul><h5 id="②非导向型传输媒体"><a href="#②非导向型传输媒体" class="headerlink" title="②非导向型传输媒体"></a>②非导向型传输媒体</h5><ul><li>无线电波：具有较强的穿透能力，适用于无线局域网(WLAN)</li><li>微波、红外线和激光（高带宽无线通信）<ul><li>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz，因而通信信道的容量大</li><li>与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力</li><li>红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</li><li>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。<br>三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。<ul><li>卫星通信的优点是通信容量大、距离远、覆盖广，缺点是保密性差、端到端传播时延长。</li></ul></li></ul></li></ul><h4 id="2-物理层接口的特性（✠）"><a href="#2-物理层接口的特性（✠）" class="headerlink" title="2.物理层接口的特性（✠）"></a>2.物理层接口的特性（✠）</h4><ul><li>物理层实现的功能<ul><li>在各种传输媒体上传输比特流，进而给其上面的数据链路层提供透明传输比特流的服务<ul><li>透明传输比特流：数据链路层看不见（也无需看见）物理层究竟使用的是什么方法来传输比特流，<br>数据链路层只需享受物理层提供的传输比特流的服务即可。</li></ul></li><li>物理层为数据链路层屏蔽掉了各种传输媒体和通信手段的差异。</li></ul></li><li>物理层接口特性（✪）<ul><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：<strong>指明某条线上出现的某一电平的电压表示<u>何种意义</u>。</strong></li><li>过程特性：或称规程特性。指明对于不同功能的各种可能事件的出现顺序。</li></ul></li></ul><h3 id="三-物理层设备"><a href="#三-物理层设备" class="headerlink" title="三.物理层设备"></a>三.物理层设备</h3><h4 id="1-中继器（仅作用于信号的电气部分）"><a href="#1-中继器（仅作用于信号的电气部分）" class="headerlink" title="1.中继器（仅作用于信号的电气部分）"></a>1.中继器（仅作用于信号的电气部分）</h4><ul><li>中继器的主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后而产生的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。<ul><li>中继器的原理是信号再生，并非简单的将衰减的信号放大</li></ul></li><li>放大器和中继器都起放大作用，只不过放大器放大的是模拟信号，原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。</li><li>在一个由中继器或集线器互联的网络中，任意发送方和接收方最多只能经过4个中继器，5个网段</li><li>由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。<ul><li>只有具有存储-转发功能的网络设备才能够连接两个不同的协议</li><li>两个网段在物理层进行互联时要求数据传输速率必须相同，但是数据链路层协议可以不同</li></ul></li></ul><h4 id="2-集线器（Hub）"><a href="#2-集线器（Hub）" class="headerlink" title="2.集线器（Hub）"></a>2.集线器（Hub）</h4><ul><li>实质是一个多端口的中继器，组成共享式网络，但是在逻辑上仍然是一个总线型网络<br>集线器的一个端口收到数据之后，从除输入端口以外的所有端口广播出去</li><li>集线器的每个端口连接的网络部分是同一个网络的不同网段，只能在半双工状态工作，网络的吞吐率受到限制</li><li>多台计算机必然会发生同时通信的情形，集线器不能分割冲突域，<strong>所有集线器的端口都属于同一个冲突域</strong></li><li>集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。<ul><li>一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s=1.25Mb/s。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机网络第二章-物理层&quot;&gt;&lt;a href=&quot;#计算机网络第二章-物理层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络第二章 物理层&quot;&gt;&lt;/a&gt;计算机网络第二章 物理层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：计算机网络第二章物理层的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络第一章-计算机网络体系结构</title>
    <link href="http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2024-08-11T15:40:24.000Z</published>
    <updated>2024-08-11T16:15:25.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络第一章-计算机网络体系结构"><a href="#计算机网络第一章-计算机网络体系结构" class="headerlink" title="计算机网络第一章 计算机网络体系结构"></a>计算机网络第一章 计算机网络体系结构</h2><blockquote><p>计算机学科基础：计算机网络第一章计算机网络体系结构的学习笔记</p></blockquote><span id="more"></span><h3 id="一-计算机网络概述（✠）"><a href="#一-计算机网络概述（✠）" class="headerlink" title="一.计算机网络概述（✠）"></a>一.计算机网络概述（✠）</h3><h4 id="1-计算机网络的概念"><a href="#1-计算机网络的概念" class="headerlink" title="1.计算机网络的概念"></a>1.计算机网络的概念</h4><ul><li>计算机网络就是一些互连的、自治的计算机系统的集合。</li></ul><h4 id="2-计算机网络的组成"><a href="#2-计算机网络的组成" class="headerlink" title="2.计算机网络的组成"></a>2.计算机网络的组成</h4><ul><li>组成部分来看：由硬件、软件、协议三大部分组成</li><li>工作方式来看：由边缘部分与核心部分组成</li><li>功能组成上看：由通信子网和资源子网组成<ul><li>通信子网由各种<strong>传输介质、通信设备和相应的网络协议组成</strong>，它使网络具有数据传输、交换、控制和存储的能力，<br>实现联网计算机之间的数据通信。</li><li>资源子网是<strong>实现资源共享功能的设备及其软件</strong>的集合，<br>向网络用户提供共享其他计算机上的<u>硬件资源、软件资源和数据资源</u>的服务。</li></ul></li></ul><h4 id="3-计算机网络的功能"><a href="#3-计算机网络的功能" class="headerlink" title="3.计算机网络的功能"></a>3.计算机网络的功能</h4><ul><li>数据通信：作为最基本功能</li><li>资源共享</li><li>分布式处理（提高效率）</li><li>提高可靠性</li><li>负载均衡</li></ul><h4 id="4-计算机网络的分类"><a href="#4-计算机网络的分类" class="headerlink" title="4.计算机网络的分类"></a>4.计算机网络的分类</h4><ul><li><p>按网络的覆盖范围</p><ul><li><p>广域网（WAN）：几十千米到几千千米（因特网的核心部分），<strong>广域网使用交换技术</strong></p></li><li><p>城域网（MAN）：5到50km</p></li><li><p>局域网（LAN） ：1km以内，<strong>局域网使用广播技术</strong></p></li><li><p>个人网（PAN）：10m</p></li></ul></li><li><p>按传输技术分类：</p><ul><li><strong>广播式网络：局域网、无线、卫星通信网络</strong><br>所有联网计算机都共享一个信道</li><li><strong>点对点网络：广域网</strong><br>通过分组存储转发和路由机制交换数据</li></ul></li><li><p>按拓扑结构分类（取决于通信子网）</p><ul><li>总线型网络</li><li>星型网络</li><li>环形网络：令牌环局域网</li><li>网状网络：广域网</li></ul></li><li>按使用者分类：公有网、私有网</li><li>按交换技术分类：电路交换网络、报文交换网络(存储-转发网络)、分组交换网络(包交换网络)</li></ul><h4 id="5-计算机网络的性能指标（✪）"><a href="#5-计算机网络的性能指标（✪）" class="headerlink" title="5.计算机网络的性能指标（✪）"></a>5.计算机网络的性能指标（✪）</h4><h5 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h5><ul><li>单位（bit/s或bps）</li><li>需要注意相关的换算！<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS1h2i8.png" alt="pS1h2i8.png"></li></ul></li></ul><h5 id="2-带宽（最高数据率）"><a href="#2-带宽（最高数据率）" class="headerlink" title="2.带宽（最高数据率）"></a>2.带宽（最高数据率）</h5><ul><li>单位为bit/s，带宽指的是最高的数据率,表示网络的通信线路所能传送数据的能力</li><li>在描述通信线路中的传输速率时，一般速率遵守木桶效应：<br>数据传送的速率取主机的接口速率、线路带宽、交换机和路由器的接口速率中的最小者</li></ul><h5 id="3-吞吐量（实际的数据率）"><a href="#3-吞吐量（实际的数据率）" class="headerlink" title="3.吞吐量（实际的数据率）"></a>3.吞吐量（实际的数据率）</h5><ul><li>是指在单位时间之内通过某个网络或接口的实际数据量</li><li>吞吐量受网络带宽的限制</li></ul><h5 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h5><ul><li>网络中的时延由发送时延、传播时延、排队时延、以及处理时延构成<ul><li>图片<img src="https://s1.ax1x.com/2023/02/05/pS6JVit.jpg" alt="pS6JVit.jpg"></li></ul></li><li>发送时延（也称传输时延✪）<ul><li>指的是主机或路由器发送分组所耗费的时间，发送分组的第一个比特开始，到该分组最后一个比特发送完毕为止所耗费的时间</li><li>发送时延=分组长度/发送速率</li><li>在最后一个比特发送出去之后，此时之前已发送的比特正在陆续传播达到接收方，<br>而最后一个比特还需要经过一个传播时延的时间才能到达接收方。</li><li>发送一个分组时，往往在最后一个比特完全传出之后，前面传出的比特经过链路上的传输刚刚到达发送方。</li></ul></li><li>传播时延<ul><li>电磁波在链路（传播介质）上传播一定的距离所耗费的时间</li><li>传播时延=链路长度/电磁波在链路上传播的距离<ul><li>电磁波在自由空间上：$3*10^8 m/s$</li><li>在铜线和电缆中：$2.3*10^8 m/s$</li><li>在光纤中：$2*10^8 m/s$</li></ul></li></ul></li><li>排队时延<ul><li>分组进入路由器后，在路由器的输入队列中排队缓存并等待处理。<br>在路由器确定了分组的转发接口后，分组会在输出队列中排队缓存并等待转发。在排队缓存中所耗费的时间就是排队时延。</li><li>如果通信量过大，会使路由器的队列溢出</li></ul></li><li>处理时延<ul><li>一般是检查是否误码、提取首部目的地址、查找相应的转发接口等操作。</li></ul></li></ul><h5 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h5><ul><li>时延带宽积是传播时延和带宽的乘积，也称以比特为单位的链路长度，表示一段链路可以容纳的比特数量<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS1IuPf.png" alt="pS1IuPf.png"></li></ul></li></ul><h5 id="6-往返时间（RTT）"><a href="#6-往返时间（RTT）" class="headerlink" title="6.往返时间（RTT）"></a>6.往返时间（RTT）</h5><ul><li>往返时间是指从发送端发送数据分组开始，到发送端收到接收端发来的相应确认分组为止，总共耗费的时间。</li></ul><h5 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h5><ul><li>链路利用率（有百分之几的时间是被利用的）和网络利用率（所有链路的链路利用率的加权平均）</li><li>当某链路的利用率增加时，该链路引起的时延就会迅速增加</li><li>用以下的公式来表示：$D= \frac{D_0}{1-U}$   (D:网络当前的时延、$D_0$:网络空闲时的时延、U:网络利用率)<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS1oU0A.png" alt="pS1oU0A.png"></li></ul></li></ul><h5 id="8-丢包率"><a href="#8-丢包率" class="headerlink" title="8.丢包率"></a>8.丢包率</h5><ul><li>丢包率是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比例</li><li>在传输过程中出现误码或由于网络拥塞等造成的分组交换机根据丢弃策略主动丢弃。</li></ul><h4 id="6-因特网历史"><a href="#6-因特网历史" class="headerlink" title="6.因特网历史"></a>6.因特网历史</h4><ul><li><p>由单个阿帕网向互联网发展、逐步建成三级结构的互联网、逐步建成多层次ISP的因特网</p><ul><li><p>1969年，美国建立了第一个分组交换网：ARPANET</p></li><li><p>1983年，TCP/IP协议族成为ARPANET的标准协议（因特网的诞生时间）</p></li><li><p>1985年，美国建成了由主干网、地区网、校园网三级结构所构成的国家科学基金网（NSFNET）</p></li><li><p>1993年，因特网转变为由互联网服务提供者（Internet Service Provider）ISP来运营</p></li><li><p>1994年，万维网（WWW）技术在因特网上被广泛运用</p></li></ul></li><li><p>因特网已发展成基于ISP的多层次结构的互联网络</p><ul><li>第一层ISP：国际级</li><li>第二层ISP：区域级或国家级</li><li>第三层ISP：本地级</li></ul></li></ul><h4 id="7-因特网的标准化工作和管理机构"><a href="#7-因特网的标准化工作和管理机构" class="headerlink" title="7.因特网的标准化工作和管理机构"></a>7.因特网的标准化工作和管理机构</h4><ul><li>因特网的标准化工作的流程<ul><li>在成为互联网标准之前需要在网络上发布：RFC文档（Request for comments）</li><li>经过以下阶段才能变成因特网标准：因特网草案、建议标准（成为RFC文档）、因特网标准</li></ul></li><li>因特网的管理机构：因特网协会（ISOC）<ul><li>下设因特网体系结构委员会（IAB）并有两个子部门<ul><li>互联网工程部（IETF）</li><li>互联网研究部（IRTF）</li></ul></li></ul></li><li>专门制定计算机网络标准的组织：IEEE（Institute of Electrical and Electronics Engineers），电气与电子工程协会。</li></ul><h3 id="二-计算机网络的体系结构（✪）"><a href="#二-计算机网络的体系结构（✪）" class="headerlink" title="二.计算机网络的体系结构（✪）"></a>二.计算机网络的体系结构（✪）</h3><h4 id="1-常见的三种计算机网络的体系结构（✪）"><a href="#1-常见的三种计算机网络的体系结构（✪）" class="headerlink" title="1.常见的三种计算机网络的体系结构（✪）"></a>1.常见的三种计算机网络的体系结构（✪）</h4><ul><li><p>开放系统互联参考模型（OSI✪）</p><ul><li><p>由国际标准化组织（ISO）制订，分为7层</p></li><li><p>高三层统称为资源子网，相当于计算机系统，完成数据的处理等功能</p></li><li><p>低三层统称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能</p></li><li><p>物理层</p><ul><li>物理层的传输单位是比特，功能是在物理媒体上为数据端设备透明地传输原始比特流。</li><li>物理层主要定义数据终端设备(DTE)和数据通信设备(DCE)的物理与逻辑连接方法<br>所以物理层协议也称物理层接口标准，物理层协议也称物理层规程。</li><li>传输信息所用的物理媒体（双绞线、光缆、无线信道等），不属于物理层协议</li></ul></li><li><p>数据链路层</p><ul><li>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。</li><li>数据链路层的功能可以概括为<strong>物理寻址、封装成帧、差错控制、流量控制和传输管理等</strong>。<br>保证数据正确的顺序和完整性</li><li>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问<br>数据链路层的一个特殊的子层一一介质访问子层，就是专门处理这个问题的</li><li><strong>数据链路层提供的是点到点的通信</strong>（主机到主机之间的通信）</li></ul></li><li><p>网络层</p><ul><li><p>网络层的传输单位是IP数据报（分组），它关心的是通信子网的运行控制，</p><p>主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p></li><li><p>关键问题是对分组进行<strong>路由选择</strong>，并实现<strong>差错控制、流量控制、拥塞控制和网际互连</strong>等功能。</p></li><li><p>因特网是一个很大的互联网，它由大量异构网络通过路由器(Router)相互连接起来。</p><ul><li>因特网的主要网络层协议是无连接的网际协议(IP)和许多路由选择协议<br>因此因特网的网络层也称网际层或IP层。</li></ul></li></ul></li><li><p>传输层</p><ul><li>传输层也称运输层，传输单位是报文段(TCP)或用户数据报(UDP)</li><li>传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，<br>为端到端连接提供<strong>差错控制、流量控制、拥塞控制、服务质量、数据传输管理</strong>等服务。</li><li><strong>传输层提供的是端到端的通信</strong>（运行在不同主机的两个进程之间的通信）</li></ul></li><li><p>会话层：会话管理，也称为建立同步（SYN）</p><ul><li>这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步(SYN)。</li><li>会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步</li></ul></li><li><p>表示层：数据格式转换</p></li><li><p>应用层：提供用户和网络的接口。应用层为特定类型的网络应用提供访问OSI参考模型环境的手段</p></li></ul></li><li><p>TCP/IP参考模型（✪）</p><ul><li>分为四层：网络接口层、网际层（主机之间）、传输层（进程之间）、应用层（用户之间）</li><li>网络接口层：从主机或结点接收IP分组，并把它们发送到指定的物理网络上</li><li>网际协议IP是TCP/IP体系结构（因特网）中的核心协议<ul><li>进行路由选择，提供无连接不可靠的数据报服务</li><li>IP协议作为 TCP/IP体系结构中的核心协议, 一方面负责互连不同的网络接口, 也就是IP over everything；<br>另一方面为各种网络应用提供服务, 也就是Everything over IP。</li><li>TCP/IP 协议族图片<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS17QxO.png" alt="pS17QxO.png"></li></ul></li></ul></li><li>传输层：使发送端和目的端主机上的对等实体进行会话<ul><li>实现端到端通信，处理关于可靠性、流量控制和错误矫正等问题</li><li>传输控制协议(TCP)。它是面向连接的，<br>数据传输的单位是<strong>报文段，能够提供可靠的交付</strong>。</li><li>用户数据报协议(UDP)。它是无连接的，<br>数据传输的单位是<strong>用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”</strong>。</li></ul></li><li>应用层：包含所有的高层协议，如虚拟终端协议(Telnet)、文件传输协议(FTP)、<br>域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。</li></ul></li><li><p>原理参考模型：五层，物理层、数据链路层、网络层、传输层、应用层（学习时采用的模型）</p></li><li><p>OSI参考模型与TCP/IP模型的区别（✪）</p><ul><li>OSI参考模型在网络层支持无连接和面向连接的通信<br>但在传输层仅有面向连接的通信。</li><li>而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式<br>但传输层支持无连接和面向连接两种模式</li></ul></li></ul><h4 id="2-数据传输的过程"><a href="#2-数据传输的过程" class="headerlink" title="2.数据传输的过程"></a>2.数据传输的过程</h4><ul><li><p>主机发送报文（自顶向下逐层封装）：</p><ul><li>1.应用层: 根据HTTP协议的规定, 构建一个HTTP请求报文, 用来请求Web服务器执行相应的操作。<br>应用层将构建好的HTTP请求报文向下交付给运输层。</li><li>2.运输层: 给HTTD请求报文添加一个TCP首部， 将其封装成TCP报文段，TCP首部的主要作用是区分应用进程和实现可靠转输，运输层将封装好的TCP报文段向下交付给网络层。</li><li>3.网络层: 为TCP报文段添加一个IP首部, 将其封装成IP数据报。<br>IP首部的主要作用是IP寻址和路由。网络层将封装好的IP数据报向下交付给数据链路层。</li><li>4.数据链路层: 为IP数据报添加一个首部和一个尾部，将其封装成帧。帧首部和尾部的主要作用是MAC寻址和帧校验。<br>数据链路层将封装好的帧可下交付给物理层。</li><li>5.物理层: 并不认识帧的结构, 仅仅将其看作比特流, 以便将比特流转换成相应的电信号进行发送。<br>对于以太网, 物理层还会在比特流前添加前导码, 目的是使接收方的时钟同步, 并做好接收准备。<ul><li>注：物理层并不参与数据封装工作。</li></ul></li></ul></li><li><p>路由器处理报文（自低向下逐层解封）：</p><ul><li>1.接收口的物理层：将收到的电信号装换成比特流，并去掉前导码，然后将帧向上交给数据链路层。</li><li>2.接收口的数据链路层: 去掉帧的首部和尾部后, 将IP数据报向上交付给网络层。</li><li>3.网络层: 网络层从IP数据报的首部中提取出目的IP地址，根据目的IP地址查找自己的转发表，以便决定从哪个接口转发该IP数据<br>报。与此同时，还要对首部中的某些字段值（例如生存时间TTL字段的值）进行相应的修改，然后将该IP数据报向下交付给数据链路层。</li><li>4.转发口的数据链路层: 为IP数据报添加一个首部和一个尾部, 将其封装成帧，然后将帧向下交付给物理层。</li><li>5.转发口的物理层: 将帧看作比特流, 给其添加前导码后转变成相应的电信号发送出去。</li></ul></li><li><p>流程图</p><ul><li><img src="https://s1.ax1x.com/2023/01/17/pS1Hbng.png" alt="pS1Hbng.png"></li></ul></li></ul><h4 id="3-分层体系结构中的相关术语"><a href="#3-分层体系结构中的相关术语" class="headerlink" title="3.分层体系结构中的相关术语"></a>3.分层体系结构中的相关术语</h4><ul><li><p>计算机网络的各层及其协议的集合被称为体系结构</p><ul><li>分层描述了每层必须完成的功能，但是没有定义功能执行的方法<br>分层不涉及协议的内部实现细节    </li></ul></li><li><p>实体</p><ul><li>实体是指任何可发送或接收信息的硬件或软件进程</li><li>不同机器上的同一层称为对等层</li><li>同一层的实体称为对等实体</li></ul></li><li>PDU(协议数据单元)，由SDU、PCI组成<ul><li>服务数据单元（SDU）：层与层之间交换的数据单元称为服务数据单元</li><li>服务控制信息（PCI）：控制协议操作的信息</li><li>协议数据单元（PDU）：对等层之间传送的数据单元称为该层的协议数据单元</li></ul></li></ul><h4 id="4-协议、接口、服务（OSI参考模型的三个主要概念✪）"><a href="#4-协议、接口、服务（OSI参考模型的三个主要概念✪）" class="headerlink" title="4.协议、接口、服务（OSI参考模型的三个主要概念✪）"></a>4.协议、接口、服务（OSI参考模型的三个主要概念✪）</h4><ul><li><p>协议（✪）</p><ul><li><p><strong>协议是控制两个对等实体在”水平方向”进行”逻辑通信”的规则的集合</strong></p><ul><li>物理层对等实体使用物理层协议进行逻辑通信, 例如传统以太网使用曼彻斯特编码。</li><li>数据链路层对等实体使用数据链路层协议进行逻辑通信, 例如传统以太网使用 CSMA/CD协议。</li><li>网络层对等实体使用网络层协议进行逻辑通信, 例如IP协议。</li><li>运输层对等实体使用运输层协议进行逻辑通信, 例如TCP协议或UDP协议。</li><li>应用层对等实体使用应用层协议进行逻辑通信, 例如HTTP协议、FTP协议以及SMTP协议等。</li></ul></li><li><p><strong>协议三要素：语法、语义、同步</strong></p><ul><li>语法：语法用来定义数据与控制信息的结构与格式，以及数据出现的顺序<ul><li>比如说IP数据报文，其中的每一个小格子被称为字段或域。</li></ul></li><li>语义：语义解释控制信息每个部分的意义，规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应</li><li>同步：用来定义通信双方的时序关系，对事件发生的顺序进行详细说明<ul><li>例：此时为三次握手，展现先后关系<ul><li><img src="https://s1.ax1x.com/2023/01/19/pS8dFDe.png" alt="pS8dFDe.png"></li></ul></li></ul></li></ul></li></ul></li><li><p>接口与服务访问点（SAP）</p><ul><li>接口是同一结点内相邻两层间交换信息的连接点</li><li>同一结点相邻两层的实体通过服务访问点（SAP）进行交互</li><li>各层的SAP<ul><li>物理层：网卡接口</li><li>数据链路层：MAC地址（网卡地址）或帧的类型字段</li><li>网络层：IP地址（网络地址）或IP数据报首部的协议字段</li><li>传输层：端口号</li><li>应用层：用户界面</li></ul></li></ul></li><li><p>服务（✪）</p><ul><li>服务的基本概念<ul><li><strong>在协议的控制下，两个对等实体在水平方向上的逻辑通信使得本层能够向上一层提供服务。</strong></li><li>要实现本层协议，还需要使用下面一层所提供的服务，其下面的一层称为服务提供者</li><li>协议是水平的，而服务是垂直的。</li><li>实体看得见下层提供的服务，但并不知道实现该服务的具体协议。下层的协议对上层的实体是透明的。<ul><li>网络层享受链路层提供的服务，并给传输层提供服务。</li></ul></li></ul></li><li>服务原语：<strong>上层要使用下层所提供的服务，必须通过与下层交换一些命令，这些命令称为服务原语。</strong><ul><li>分为请求、指示、响应、证实四类</li></ul></li><li>服务的分类<ul><li>面向连接服务与无连接服务<ul><li>面向连接服务（分为连接建立、数据传输和连接释放三个阶段）<ul><li>通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行</li><li>传输结束后释放连接和所占用的资源。</li><li>TCP就是一种面向连接服务的协议</li></ul></li><li>无连接服务（尽最大努力交付）<ul><li>通信双方不需要先建立连接，直接发送数据即可，是一种不可靠的服务</li><li>IP，UDP为无连接服务</li></ul></li></ul></li><li>可靠服务与不可靠服务<ul><li>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</li><li>不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的<br>地，是一种尽力而为的服务。</li></ul></li><li>有应答服务与无应答服务<ul><li>应答由传输系统内部自动实现，如文件传输服务</li><li>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现<br>如www服务</li></ul></li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/01/17/pS3A6vF.png" alt="pS3A6vF.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;计算机网络第一章-计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络第一章-计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络第一章 计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络第一章 计算机网络体系结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：计算机网络第一章计算机网络体系结构的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第八章-排序</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/</id>
    <published>2024-08-11T14:19:41.000Z</published>
    <updated>2024-08-11T16:12:34.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第八章-排序"><a href="#数据结构第八章-排序" class="headerlink" title="数据结构第八章 排序"></a>数据结构第八章 排序</h2><blockquote><p>计算机学科基础：数据结构第八章排序的学习笔记</p></blockquote><span id="more"></span><h3 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1.排序的基本概念"></a>1.排序的基本概念</h3><ul><li>评价指标<ul><li>稳定性：关键字相同的元素经过排序后<strong>相对顺序</strong>是否会改变</li><li>时间复杂度、空间复杂度</li></ul></li><li>分类<ul><li>内部排序：数据都存放在内存中<ul><li>一般内部排序算法在执行过程中都需要进行比较和移动两种操作（但是基数排序不基于比较）</li></ul></li><li>外部排序：数据无法全部同时存放在内存中</li></ul></li></ul><h3 id="2-插入排序（✪）"><a href="#2-插入排序（✪）" class="headerlink" title="2.插入排序（✪）"></a>2.插入排序（✪）</h3><ul><li><p>直接插入排序</p><ul><li><p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p></li><li><p>流程</p><ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjN6gJ.png" alt="pCjN6gJ.png"></li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;  <span class="comment">//每次都比较该位置的前驱，看是否小于前驱</span></span><br><span class="line">            temp=A[i];  <span class="comment">// temp暂存</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;A[j]&gt;temp;--j)<span class="comment">//检查前面排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j]; <span class="comment">//所有大于temp的元素都向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接插入排序的性能分析</p><ul><li>空间效率：空间复杂度为O(1)</li><li>时间复杂度：主要来自对比关键字、移动元素，若有n个元素，则需要n-1趟处理<ul><li>最好时间复杂度为O(n)（全部顺序）<ul><li>最好的情况下做 n-1次关键字的比较，也就是执行n-1趟，每趟只比较一次，此时不需要移动元素</li></ul></li><li>最坏/平均时间复杂度为O($n^{2}$) (全部逆序)<ul><li>直接插入排序在最坏的情况下做 n(n-1)/2次关键字的比较，此时移动次数也达到最大</li></ul></li></ul></li><li>稳定性：为稳定的排序算法</li><li>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</li></ul></li></ul></li><li><p>折半插入排序</p><ul><li><p>算法思想：先用折半查找找到应该插入的位置，再移动元素</p><ul><li><p>当low&gt;high时折半查找停止，应将[Iow,i-1]内的元素全部右移，并将A[0]复制到Iow所指位置</p></li><li><p>当A[mid]==A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置</p></li></ul></li><li><p>流程</p><ul><li>如此时向前插入8位置的55，需要在1-7个位置之间进行折半查找<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCOdDEV.png" alt="pCOdDEV.png"></li></ul></li><li>此时通过折半查找，找到其应该插入的位置为5，则将6-7的元素统一后移一位，并在5位置插入55<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCOdc34.png" alt="pCOdc34.png"></li></ul></li></ul></li><li><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>,i&lt;=n;i++)&#123; <span class="comment">//依次将A[2]到A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i]; <span class="comment">//A[0]作为暂存位</span></span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>; <span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;<span class="comment">//折半查找</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>; <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>; <span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span> <span class="comment">//查找右半子表</span></span><br><span class="line">            <span class="comment">//注意：一直到Iow&gt;high时才停止折半查找。当mid所指元素等于当前元素时，</span></span><br><span class="line"><span class="comment">//应继续令Iow=mid+1,以保证“稳定性”。最终应将当前元素插入到Iow所指位置(即high+1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;i&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];    <span class="comment">//插入操作</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>折半插入排序的性能分析</p><ul><li>折半插入排序的比较次数与原始状态无关，仅取决于n</li><li><p>折半插入排序仅减少了比较元素的次数，约为O($nlog_{2}{n}$)</p></li><li><p>折半插入排序没有改变元素的移动次数，时间复杂度仍然是O($n^{2}$)，依赖于原始状态</p></li></ul></li></ul></li><li><p>希尔排序（缩小增量排序）</p><ul><li><p>算法思想：先追求表中元素部分有序，再逐渐逼近全局有序</p><ul><li>设置增量为d的子表，把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序。<br>之后进行增量的缩小再进行一次这样的排序，当整个表中的呈现基本有序时，再对全体记录进行一次直接插入排序</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCO0aT0.png" alt="pCO0aT0.png"></li></ul></li></ul></li><li><p>流程</p><ul><li>第一趟排序之后<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCO0rpF.png" alt="pCO0rpF.png"></li></ul></li><li>第二趟排序之后<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCO07Xd.png" alt="pCO07Xd.png"></li></ul></li><li>第三趟排序之后<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCO0jtf.png" alt="pCO0jtf.png"></li></ul></li></ul></li><li><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>) <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123; <span class="comment">//若前序较大，需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];<span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j]; <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>]<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希尔排序的性能分析</p><ul><li>空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)</li><li>时间效率：当n在某个特定范围时，希尔排序的时间复杂度约为O($n^{1.3}$)，在最坏情况下希尔排序的时间复杂度为O($n^{2}$)</li><li>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，希尔排序是一种不稳定的排序方法。</li><li>适用性：希尔排序算法<strong>仅适用于线性表为顺序存储的情况</strong>。</li></ul></li></ul></li></ul><h3 id="3-交换排序（✪）"><a href="#3-交换排序（✪）" class="headerlink" title="3.交换排序（✪）"></a>3.交换排序（✪）</h3><ul><li><p>冒泡排序</p><ul><li>算法思想：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置<ul><li>从后往前（或从前往后）两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换它们，直到序列比较完。<br>称这样过程为“一趟”冒泡排序。</li><li>下一趟冒泡时，前一趟确定的最小元素不再参与比较，<br>每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置</li><li>最多做n-1趟冒泡就能把所有元素排好序。</li></ul></li><li>流程<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjBBU1.png" alt="pCjBBU1.png"></li></ul></li><li>代码实现<ul><li><img src="https://s1.ax1x.com/2023/07/24/pCO6peH.png" alt="pCO6peH.png"></li></ul></li><li>冒泡排序的性能分析<ul><li>空间复杂度：仅使用了常数个辅助单元，因而空间复杂度为O(1).</li><li>时间复杂度<ul><li>当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换）从而直接跳出循环，<br>比较次数为n-1，移动次数为0，从而最好情况下的时间复杂度为O($n$)</li><li>当初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较，<br>而且每次比较后都必须移动元素3次来交换元素位置，此时<ul><li>比较次数：$\frac{n(n-1)}{2}$，移动次数：$\frac{3n(n-1)}{2}$</li><li>最坏情况下的时间复杂度O($n^{2}$)</li></ul></li><li>平均时间复杂度为O($n^{2}$)</li></ul></li><li>稳定性：冒泡排序是一种稳定的排序方法</li><li>适用于顺序表和链表</li><li>快速排序一趟会确定一个元素最终的位置</li></ul></li></ul></li><li><p>快速排序</p><ul><li><p>算法思想：分治法</p><ul><li>在待排序表L[1..n]中任取一个元素pivot作为枢轴(或基准，<strong>通常取首元素</strong>)</li><li>通过一趟排序将待排序表划分为独立的两部分L[1……k-1]和L[k+1……n]，使得L[1……k-1]中的所有元素小于pivot，<br>L[k+1……n]中的所有元素大于等于pivot，则<strong>pivot放在了其最终位置L(k)上，这个过程称为一次“划分”</strong>。</li><li>然后分别<strong>递归地对两个子表重复上述过程</strong>，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</li></ul></li><li><p>代码实现（掌握）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序（表长为n，初始的low为表头0，high为表尾n-1）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">()</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;<span class="comment">//当low=high时，此时递归跳出</span></span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low,high); <span class="comment">//进行一次分治划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);<span class="comment">//划分左子表(上一次划分后返回的之前枢纽存放的最终位置的左边一位在划分左子表时作为&quot;high&quot;，low为当前递归工作栈的存放位置)</span></span><br><span class="line">        QuickSort(A,Pivotpos+<span class="number">1</span>,high);   <span class="comment">//划分右子表(上一层划分后返回的之前枢纽存放的最终位置的右边一位在划分右子表时作为&quot;low&quot;,high为当前递归工作栈的存放位置)</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];   <span class="comment">//将当前表中的low作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;<span class="comment">//当low=high时，说明此轮的枢纽已经搜索到了最终的位置，跳出此轮枢纽的循环</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)  <span class="comment">//从后往前找到比枢纽更小的元素，将其移动到左边</span></span><br><span class="line">            --high;</span><br><span class="line">        A[low]=A[high];   <span class="comment">//在high位置上比枢纽小的元素移动到当前low的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)   <span class="comment">//从前往后找到比当前枢纽更大的元素，将其移动到右边</span></span><br><span class="line">            ++low;</span><br><span class="line">        A[high]=A[low];  <span class="comment">//在low位置上比枢纽更大的元素移动到当前的high位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;     <span class="comment">//进行一次分治算法后，枢纽存放的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;       <span class="comment">//返回枢纽存放的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>流程</p><ul><li>第一轮分治法时，递归工作栈中的low为0，high为7，此时将49作为枢纽，将high指针左移，找到比枢纽小的元素移动到low指针处，<br>之后又将low指针右移，找到比枢纽大的元素移动到high指针处。</li><li>互相进行以上操作，直到low=high时，此时就找到了枢纽元素的最终位置。并返回当前的枢纽指针位置，进行左子表的新一轮递归操作。<ul><li>初始情况<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCO5Bh4.png" alt="pCO5Bh4.png"></li></ul></li><li>第一趟递归操作<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjsLrD.png" alt="pCjsLrD.png"></li></ul></li></ul></li><li>第二轮分治法时，递归工作栈中的low为0，high为之前的枢纽位置3减1为2，此时选择27为枢纽进行操作<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCO5XE8.png" alt="pCO5XE8.png"></li></ul></li><li>到了处理右子表时，递归的工作栈中low为之前的枢纽3加1为4，high为7，此时选择76为枢纽进行操作<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCOIm8J.png" alt="pCOIm8J.png"></li></ul></li></ul></li><li><p>快速排序的性能分析</p><ul><li>算法表现主要取决于递归深度若每次“划分”越均匀，则递归深度越低。“划分”越不均匀，递归深度越深</li><li>空间复杂度：最好空间复杂度：O($log_{2}n$)，最坏空间复杂度：O($n$)</li><li><p>时间复杂度：</p><ul><li>最好时间复杂度：O($nlog_{2}n$)，每次选的枢轴元素都能将序列划分成均匀的两部分</li><li>最坏时间复杂度：O($n^{2}$​)，若序列原本就有序或逆序，则时空复杂度最高，可优化，尽量选择<br>可以把数据中分的枢轴元素。</li></ul></li><li><p>快速排序是所有内部排序算法中平均性能最优的算法</p></li><li>快速排序是一种不稳定的排序</li></ul></li><li><p>例题</p><ul><li>判断快速排序时速度最快和最慢的情况<ul><li>此时需要判断以枢纽为中心的两边所划分的元素个数是否平均，<br>小于枢纽的元素的个数和大于枢纽的元素的个数的比例越不平均，所耗时越多</li><li>速度最慢显然是D选项，均为有序排序时，速度最快时看大于和小于枢纽的数的比例，<br>A，C选项的比例1:1；B选项为5:1，<br>再从AC选项里面选择进行一趟快速排序（A：9,5,7,21,25,23,30；B:5,9,17,21,25,23,30）<br>此时A的左右子表都满足与新枢纽的比例为1:1，但是B的左右子表关于新枢纽的比例均为2:0，选A<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCOHtTP.png" alt="pCOHtTP.png"></li></ul></li></ul></li><li>判断不可能是快速排序第2趟排序的结果的序列，利用快速排序一趟会确定一个元素最终的位置，<br>此时写出有序序列与选项作比较，此时只需要选项中有两个在相应位置上契合的元素即可<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCOOeje.png" alt="pCOOeje.png"></li></ul></li><li>除了需要满足上面的条件，还需要满足此时有一个符合的元素位于边界<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCOOo8K.png" alt="pCOOo8K.png"></li></ul></li></ul></li></ul></li></ul><h3 id="4-选择排序（✪）"><a href="#4-选择排序（✪）" class="headerlink" title="4.选择排序（✪）"></a>4.选择排序（✪）</h3><ul><li><p>简单选择排序</p><ul><li><p>算法思想：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列<br>每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min=i;     <span class="comment">//记录最小元素的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;  <span class="comment">//在A[i……n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])<span class="comment">//如果存在更小的元素，则更新最小元素的位置</span></span><br><span class="line">                min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">            swap(A[i],A[min]);   <span class="comment">//交换位置，此时该趟中最小的元素到了i位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单选择排序性能分析</p><ul><li>空间复杂度：O(1)</li><li>时间复杂度：O($n^{2}$)</li><li>无论有序、逆序、还是乱序，一定需要n-1趟处理</li><li>元素间比较的次数与序列的初始状态无关，始终是$n(n-1)/2$次，因此时间复杂度始终是O($n^{2}$)</li><li>简单选择排序是一种不稳定的排序算法</li><li>适用于顺序表和链表</li></ul></li></ul></li><li><p>堆排序</p><ul><li><p>堆（堆是用来排序的，他的查找效率很低）</p><ul><li><strong>从二叉树的任意结点出发到根的路径上所经过的所有结点序列按其关键字有序，则此二叉树是根</strong></li><li><p>大根堆与小根堆</p><ul><li><p>若${n}$个关键字序列${L[1 \ldots n]}$满足下面某一条性质, 则称为堆（Heap）</p><ul><li>若满足:${\mathrm{L}(\mathrm{i}) \geqslant \mathrm{L}(2 \mathrm{i})}$且${\mathrm{L}(\mathrm{i}) \geqslant \mathrm{L}(2 \mathrm{i}+1) (1 \leq i \leq n / 2)—}$大根堆（大顶堆）    </li><li>若满足:${\mathrm{L}(\mathrm{i}) \leqslant \mathrm{L}(2 \mathrm{i})}$且${\mathrm{L}(\mathrm{i}) \leqslant \mathrm{L}(2 \mathrm{i}+1) (1 \leq i \leq n / 2) —}$小根堆（小顶堆）</li></ul></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/25/pCXeqsJ.png" alt="pCXeqsJ.png"></li></ul></li></ul></li></ul></li><li><p>流程</p><ul><li>建立大根堆<ul><li>可以将堆看做是一个完全二叉树，大根堆就是根结点的关键字大于左右孩子结点，<br>此时可以对于一个给定的初始的序列建立大根堆，之后方便进行选择排序</li><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，<br>如果不满足，则进行调整，在顺序存储的完全二叉树中, 非终端结点编号  $\mathbf{i} \leq\lfloor n / 2\rfloor$</li><li>从编号为$\lfloor n / 2\rfloor$的分支结点开始从后往前检查，检查当前结点是否满足根≥左、右，<br>若不满足，将当前结点与更大的一个孩子互换</li><li>之后依次这样处理前面序号的非终端结点，<br>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整(小元素不断“下坠”)</li><li>图片（注：初始序列为：（53,17,78,9,45,65,87,32），初始对$\lfloor n / 2\rfloor$位置开始检查，从后往前检查）<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjcjZF.png" alt="pCjcjZF.png"></li></ul></li></ul></li><li>进行堆排序<ul><li>在建立大根堆完成之后，每一趟将堆顶关键字与待排序序列中的最后一个元素交换（将堆顶元素加入有序子序列）</li><li>并将待排序元素序列再次调整为大根堆(小元素不断“下坠”)</li><li>在经过n-1趟之后得到基于“大根堆”的堆排序的“递增序列”</li><li>图片<ul><li>此时已建立好堆排序，此时将堆顶元素87与最后一个元素9进行互换，87输出到最后位<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCX1S74.png" alt="pCX1S74.png"></li></ul></li><li>互换之后，此时9在完全二叉树中破坏了大堆根，此时应该进行调整，使最小的元素坠入底端，9与78互换<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCX1ZnO.png" alt="pCX1ZnO.png"></li></ul></li><li>互换之后，还需要使其与下一层更大的65进行互换<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCX113t.png" alt="pCX113t.png"></li><li>此时互换后，重新形成了一个大根堆，如果继续进行下一趟排序的话，<br>此时已经变成有序序列的第8号元素所在的关键字87不参与排序，此时的len减一为7。78将输出，与7位置上的53互换<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCX18jf.png" alt="pCX18jf.png"></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>代码实现（了解）</p><ul><li><p>建立大根堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">//从后向前调整所有的非终端结点</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以K为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k];   <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿关键字较大的根结点的子节点向下筛选，若超出原数组长度，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])<span class="comment">//此时取关键字更大的其中子节点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//此时根结点的值较大，则停止筛选</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[K]=A[i];  <span class="comment">//将被筛选中的结点调整到双亲结点上</span></span><br><span class="line">            k=i;<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];    <span class="comment">//筛选完成后，被筛选的节点放入最终的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现根排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span><span class="comment">//建立大根堆</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span><span class="comment">//将以k为根的子树调整大根堆</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;<span class="comment">//堆排序的完整逻辑</span></span><br><span class="line">    BuildMaxHeap(A,len);<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);<span class="comment">//堆顶元素和堆底元素进行互换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>堆的插入</p><ul><li>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。<br>新元素就这样一路“上升”，直到无法继续上升为止</li><li>删除时，被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止</li><li>向具有n个结点的堆中插入一个新元素的时间复杂度为O($log_{2}n$)，删除一个元素的时间复杂度为O($log_{2}n$)</li><li>例题<ul><li>按照插入的方法，逐个插入即可，此时选B<ul><li><img src="https://s1.ax1x.com/2023/07/25/pCXhNlR.png" alt="pCXhNlR.png"></li><li><img src="https://s1.ax1x.com/2023/07/25/pCXhU61.png" alt="pCXhU61.png"></li></ul></li></ul></li></ul></li><li><p>堆排序的性能分析</p><ul><li>空间效率: 仅使用了常数个辅助单元, 所以空间复杂度为${O(1)}$</li><li>时间效率: 建堆时间为${O(n)}$, 之后有${n-1}$次向下调整操作, 每次调整的时间复杂度为${O(h)}$,<br>故在最好、最坏和平均情况下, 堆排序的时间复杂度为${O\left(n \log _{2} n\right)}$</li><li>堆排序是一种不稳定的排序方法</li></ul></li></ul></li></ul><h3 id="5-归并排序和基数排序（✪）"><a href="#5-归并排序和基数排序（✪）" class="headerlink" title="5.归并排序和基数排序（✪）"></a>5.归并排序和基数排序（✪）</h3><ul><li><p>归并排序（可以作为外部排序）</p><ul><li><p>算法思想</p><ul><li>把两个或多个<strong>已经有序</strong>的序列合并成一个新的有序表</li><li>m路归并，每选出一个元素需要对比关键字m-1次</li><li>将两个各有N个元素的有序表合并成一个有序表，最少的比较次数是N次（一个表中的最小元素大于另一个表的最大元素时），<br>最多的比较次数是2N-1次（两个表中的元素依次间隔地比较时）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjPZh4.png" alt="pCjPZh4.png"></li></ul></li></ul></li><li><p>流程（在内部排序中一般选择二路归并）</p><ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjPucR.png" alt="pCjPucR.png"></li></ul></li><li><p>例题</p><ul><li>第一趟为2个一组，第二趟为4个一组，每组内部排序即可，选B<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjeUmj.png" alt="pCjeUmj.png"></li></ul></li></ul></li><li><p>代码实现（了解）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//定义辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并算法</span></span><br><span class="line">Void <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k]; <span class="comment">//将A中所有元素复制到辅助元素B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) <span class="comment">//此时有等于号的原因是使两个元素相等时，优先使用靠前的那一个（稳定性）</span></span><br><span class="line">            A[k]=B[i++];   <span class="comment">//将较小的复制到A的位置，之后前半部分的指针位加一</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[K]=B[j++];<span class="comment">//将较大的复制到A的位置，之后后半部分的指针位加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) </span><br><span class="line">        A[k++]=B[i++]; <span class="comment">//若第一个辅助表没有检测完，则直接复制到原表的尾部</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=hige)</span><br><span class="line">         A[k++]=B[j++]; <span class="comment">//若第二个辅助表没有检测完，则直接复制到原表的尾部</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归的归并算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>; <span class="comment">//从序列的中间划分出子序列</span></span><br><span class="line">        MergeSort(A,low,mid);<span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,high);<span class="comment">//整体归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>归并排序的性能分析</p><ul><li>空间复杂度${=O(n)}$, 来自于辅助数组${\mathbf{B}}$</li><li>${\mathrm{n}}$个元素进行2路归并排序, 归并趟数${=\left\lceil\log _{2} n\right\rceil}$，每路归并时间复杂度为${O(n)}$, 则算法的时间复杂度为${O\left(n \log _{2} n\right)}$</li><li>归并排序是一种稳定的排序算法</li></ul></li></ul></li><li><p>基数排序</p><ul><li>算法思想<ul><li>基数排序不是基于比较的排序算法，是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法，<br>通常基于链式存储实现</li><li>最高位优先法（MSD）：按关键字位权重递减（先看最高位）；最低位优先法（LSD）：按关键字位权重递增（先看个位）</li><li>采用最低位优先法进行基数排序的流程<ul><li>将整个关键字拆分为d位(或“组”)</li><li>按照各个关键字位权重递增的次序(如：个、十、百)，做d趟“分配”和“收集”，<br>若当前处理的关键字位可能取得r个值，则需要建立r个队列</li><li>分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配耗时O(n)</li><li>收集：把各个队列中的结点依次出队并链接。一趟收集耗时O(r)</li></ul></li></ul></li><li>流程<ul><li>最低位优先法，分为三元组（个、十、百）<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjAgoV.png" alt="pCjAgoV.png"></li></ul></li><li>进行第一趟的分配，将个位满足相应关键字位的元素入队（先进先出）<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjAOJO.png" alt="pCjAOJO.png"></li></ul></li><li>进行第一趟收集，使这些元素依次出队<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjE9eI.png" alt="pCjE9eI.png"></li></ul></li><li>进行第二趟分配与第三趟分配，最终得到相应的结果</li></ul></li><li>基数排序的性能分析<ul><li>基数排序擅长解决的问题<ul><li>数据元素的关键字可以方便地拆分为d组，且d较小</li><li>每组关键字的取值范围不大，即”较小</li><li>数据元素个数n较大</li></ul></li><li>基数排序只能对int型进行排序，无法对float型以及double型进行排序</li><li>空间复杂度：取决于分组队列的情况，r个队列，空间复杂度为O(r)</li><li>时间复杂度：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，时间复杂度为O($d(n+r)$），<br>它与序列的初始状态无关。</li><li>基数排序是一种稳定的排序</li></ul></li></ul></li></ul><h3 id="6-各种内部排序算法的比较及应用（✪）"><a href="#6-各种内部排序算法的比较及应用（✪）" class="headerlink" title="6.各种内部排序算法的比较及应用（✪）"></a>6.各种内部排序算法的比较及应用（✪）</h3><ul><li>各种内部算法的比较<ul><li>时间复杂度分析<ul><li>平均时间复杂度为O($n^{2}$)：直接插入排序、折半插入排序、简单选择排序、冒泡排序<ul><li>直接插入排序、冒泡排序最好情况下的时间复杂度为：O($n$)（在基本有序的情况下）</li><li>简单选择排序与序列的初始状态无关</li></ul></li><li>平均时间复杂度为O($nlog_2n$)：快速排序、堆排序、归并排序<ul><li>快速排序的最坏时间复杂度为：O($n^{2}$)（在基本有序的情况下）</li><li>堆排序和归并排序的在最好、最坏和平均情况下, 堆排序的时间复杂度为：${O\left(n \log _{2} n\right)}$</li></ul></li><li>希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间</li><li>基数排序的时间复杂度取决于划分的组数d、组内的队列数r、元素数量n，时间复杂度为：O($d(n+r)$)</li></ul></li><li>空间复杂度分析<ul><li>空间复杂度为O($1$)：插入排序（直接插入、折半插入、希尔排序）、冒泡排序、选择排序（简单选择排序、堆排序）<br>仅需要借助常数个辅助空间</li><li>空间复杂度为O($log_2{n}$)：快速排序需要借助一个递归工作栈<ul><li>快速排序在最坏情况下的空间复杂度可能达到O($n$)</li></ul></li><li>空间复杂度为O($n$)：归并排序</li></ul></li><li>稳定性分析<ul><li>稳定的排序算法：直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序<ul><li>平均时间复杂度为O($nlog_2n$)的排序只有归并排序</li></ul></li><li>不稳定的排序算法：希尔排序、快速排序、选择排序（简单选择排序、堆排序）</li></ul></li><li>过程特征分析<ul><li>排序趟数与序列的原始状态的关系<ul><li><strong>趟数与原始序列状态无关：插入类、选择类的排序、基数排序</strong><ul><li>直接插入排序(每次固定插入一个元素)、简单选择排序(每次都选出一个最大/最小的元素) 均为n-1趟排序</li><li>基数排序：每趟都要进行分配和收集，排序趟数固定为d</li></ul></li><li><strong>趟数与原始序列状态有关：交换类的排序(冒泡排序、快速排序)</strong><ul><li>冒泡排序如果为顺序，只需要进行一趟排序（本趟无元素交换）；若为逆序需要进行n-1趟排序</li><li>快速排序若每趟的枢纽元素都能平均的划分两个子序列则需要的趟数最少，若原始序列有序，则需要的趟数最多</li></ul></li></ul></li><li>比较次数与序列的原始状态的关系<ul><li><strong>比较次数与序列的原始状态无关：折半插入排序、选择类的排序(简单选择排序、堆排序)</strong><ul><li>折半插入排序的比较次数仅取决于表中的元素个数n</li><li>简单选择排序的关键字比较次数恒为：n(n−1)/2次</li></ul></li><li><strong>比较次数与序列的原始状态有关：直接插入排序、希尔排序、冒泡排序、快速排序</strong><ul><li>直接插入排序最好只做n-1次关键字比较（顺序时），最坏做n(n−1)/2次关键字比较（逆序时）</li><li>冒泡排序顺序时比较次数为n-1次，逆序时比较次数为n(n−1)/2次</li></ul></li></ul></li><li>移动次数与序列的原始状态的关系<ul><li><strong>元素的移动次数与序列的原始状态无关：基数排序</strong></li><li>元素的移动次数与序列的原始状态有关：直接插入排序、折半排序、冒泡排序、快速排序、简单选择排序<ul><li>直接插入排序在顺序的情况下，不需要移动元素；若逆序需要移动大量元素</li><li>冒泡排序有序时不需要移动元素；若逆序时需要移动3n(n-1)/2次</li><li>快速排序若每趟的枢纽元素都能平均的划分两个子序列则需要的移动的次数少，<br>若原始序列有序，则需要移动的次数最多</li><li>简单选择排序在有序的情况下不需要移动元素</li></ul></li></ul></li><li>每趟排序结束后都至少能确定一个元素的最终位置的排序算法：冒泡排序、快速排序、简单选择排序、堆排序</li></ul></li></ul></li><li>内部排序算法的应用<ul><li>基于关键字个数n选择排序算法<ul><li>若n较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，<br>因而当记录本身信息量较大时，用简单选择排序较好。</li><li>若n较大，则应采用时间复杂度为O($nlog_2{n}$)的排序方法：快速排序、堆排序或归并排序。<br>快速排序被认为是目前基于比较的内部排序方法中最好的方法</li><li>当待排序的关键字随机分布时，快速排序的平均时间最短。<br>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。</li><li>若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li></ul></li><li>若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。</li><li>若要求排序稳定且时间复杂度为O($log_2{n}$)，则可选用归并排序。<ul><li>但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。<br>先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。</li></ul></li><li>在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，<br>因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要O($nlog_2{n}$)的时间。</li><li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。<ul><li>但是希尔排序和堆排序利用顺序存储的随机访问特性，如果将其换为链式存储结构其时间复杂度将增加</li></ul></li></ul></li></ul><h3 id="7-外部排序（✪）"><a href="#7-外部排序（✪）" class="headerlink" title="7.外部排序（✪）"></a>7.外部排序（✪）</h3><ul><li><p>外部排序的基本概念与方法</p><ul><li>外部排序的基本概念<ul><li>外部排序：数据元素太多，无法一次全部读入内存进行排序。</li><li>因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，<br>在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序。</li></ul></li><li>外部排序的方法<ul><li>外部排序通常采用归并排序法。它包括两个阶段：<ul><li>根据内存缓冲区大小，将外存上的文件分成若干长度为L的子文件，依次读入内存并利用内部排序方法对它们进行排序<br>并将排序后得到的有序子文件重新写回外存，<strong>称这些有序子文件为<u>归并段</u>或顺串</strong></li><li>对这些归并段在内存中进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。</li></ul></li><li>使用“归并排序”的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序</li><li>在内存中，归并后的对象顺序存放在输出缓冲区中，若缓冲区的对象存满，则将其顺序写到输出归并段中并清空缓冲区</li><li>若某个输入缓冲区中的对象在移动到输出缓冲区之后为空，则从其对应的输入归并段中再读取下一块，继续参加归并</li></ul></li><li>外部排序进行归并的流程<ul><li>内存读取外存的子文件进行内部排序，将排序好的有序子文件依次返回外层，这些有序子文件又称为归并段<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjLMSf.png" alt="pCjLMSf.png"></li></ul></li><li>经过16次读和16次写之后，由于经过了内存中的内部排序，此时在外存中形成了初始归并段<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjO8gK.png" alt="pCjO8gK.png"></li><li>此时对这8个初始归并段在内存中进行第一趟归并，需要读16次，写16次<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjXKsS.png" alt="pCjXKsS.png"></li></ul></li><li>在进行了第一趟归并之后，形成了4个新的归并段，之后需要对这4个归并段在内存中进行进一步的归并（第二趟归并）<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjXCrD.png" alt="pCjXCrD.png"></li></ul></li><li>此时对这4个归并段在内存中进行归并操作，依旧需要读16次，写16次，最后会形成一个新的2个归并段，<br>此时再进行一次归并即可得到最终的有序序列<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjX6Rx.png" alt="pCjX6Rx.png"></li></ul></li></ul></li></ul></li><li><p>外部排序的优化</p><ul><li>在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果同时存放在内存中，<br>因此需要不停地将数据读出、写入磁盘，这会消耗大量的时间<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjLzng.png" alt="pCjLzng.png"></li></ul></li><li>多路平衡归并<ul><li>${\mathrm{k}}$路平衡归并的概念<ul><li>最多只能有${\mathrm{k}}$个段归并为一个</li><li>每一趟归并中, 若有${\mathrm{m}}$个归并段参与归并, 则经过这一趟处理得到${\lceil\mathrm{m} / \mathrm{k}\rceil}$个新的归并段</li><li>图片<ul><li>4路平衡归并<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCvSMUe.png" alt="pCvSMUe.png"></li></ul></li><li>4路归并<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCvSGvt.png" alt="pCvSGvt.png"></li></ul></li></ul></li></ul></li><li>可以用多路归并的方法进行优化，采用4路归并时，只需要两趟归并，总读写次数为=32*2+32=96<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCjjmk9.png" alt="pCjjmk9.png"></li></ul></li><li>在做m路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置2m个输入缓冲区和2个输出缓冲区<br>以便在执行内部归并时，能同时进行输入输出操作。若仅设置m个输入缓冲区，则仅能进行串行操作，无法并行处理。</li></ul></li></ul></li><li><p>对于优化归并趟数(读写次数)的分析</p><ul><li>对r个初始归并段，做k路归并，则归并树可用K叉树来表示</li><li>若树高为h，则归并趟数$=\mathbf{h}-\mathbf{1}=\left\lceil\log _{k} r\right\rceil $<ul><li>推导：${\mathrm{k}}$叉树第${\mathrm{h}}$层最多有${k^{h-1}}$个结点，则${r \leq k^{h-1},(\mathrm{h}-1)}$最小${=\left\lceil\log _{k} r\right\rceil}$</li><li>由此，k越大，r越小，则归并趟数越少，读写次数越少</li></ul></li><li>可以增加输入缓冲区的数量来提高$K$（归并路数），即实现多路归并，但是会产生一些负面影响<ul><li>k路归并时，需要开辟k个输入缓冲区，内存开销增加。</li><li>每挑选一个关键字需要对比关键字(k-1)次，内部归并所需时间增加（可以设置败者树来解决此问题）</li></ul></li><li>可以减少初始归并段数量$r$来减少归并趟数，<br>生成初始归并段的“内存工作区”越大，初始归并段越长，此时初始归并段的数量越少<ul><li>若共${\mathbf{N}}$个记录, 内存工作区可以容纳${\mathrm{L}}$个记录, 则初始归并段数量  $\mathrm{r}=\lceil N / L\rceil$</li><li>可用“置换-选择排序”进一步减少初始归并段数量</li></ul></li></ul></li></ul></li><li><p>败者树</p><ul><li>败者树可以在多路归并时减少每挑选一个关键字时的比较次数，提高内部归并的时间</li><li>对于k路归并，第一次构建败者树时，需要对比关键字k-1次<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCvp6Wd.png" alt="pCvp6Wd.png"></li></ul></li><li>有了败者树, 选出最小元素, 对于每一次比较只需对比关键字${\left\lceil\log _{2} k\right\rceil}$次 <ul><li><img src="https://s1.ax1x.com/2023/07/26/pCv9pY4.png" alt="pCv9pY4.png"></li></ul></li><li>例题<ul><li><img src="https://s1.ax1x.com/2023/07/27/pCvX4EQ.png" alt="pCvX4EQ.png"></li></ul></li></ul></li><li><p>置换-选择排序（生成初始归并段的优化方法）</p><ul><li>使用置换-选择排序，可以让每个初始归并段的长度超越内存工作区大小的限制</li><li>在内存工作区中传入待排序文件的关键字，内存工作区满了之后，选择其中最小的输出，<br>此时设置MINIMAX记录输出关键字的信息，下一个输出的关键字必须大于MINIMAX，否则无法输出<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCv90cn.png" alt="pCv90cn.png"></li></ul></li><li>三个关键字都小于MINIMAX时，均无法输出，此时第一个归并段构建完成，可以构建下一个新的归并段<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCv94j1.png" alt="pCv94j1.png"></li></ul></li><li>最后将构建出数量r较少的初始归并段<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCv9X3d.png" alt="pCv9X3d.png"></li></ul></li></ul></li><li><p>最佳归并树</p><ul><li><p>归并过程中的磁盘I/O次数=归并树的WPL*2</p><ul><li><img src="https://s1.ax1x.com/2023/07/26/pCvP5TK.png" alt="pCvP5TK.png"></li></ul></li><li><p>最佳归并树指此时的I/O时间最小的树，可以由构造哈夫曼树的方法来构造</p><ul><li>此时将归并段看做树的带权结点选取最小的组合来构造</li><li>2路归并的最佳归并树<ul><li><img src="https://s1.ax1x.com/2023/07/26/pCviEmq.png" alt="pCviEmq.png"></li></ul></li><li>多路归并的最佳归并树<ul><li><img src="https://s1.ax1x.com/2023/07/27/pCvXWDS.png" alt="pCvXWDS.png"></li></ul></li></ul></li><li><p>k叉归并的最佳归并树一定是严格k叉树，即树中只有度为k、度为0的结点</p></li><li><p>对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的“虚段”，再进行k叉哈夫曼树的构造</p><ul><li><img src="https://s1.ax1x.com/2023/07/27/pCvXBAH.png" alt="pCvXBAH.png"></li></ul></li><li><p>如何判断初始归并段的数量无法构成严格k叉归并树以及需要添加虚段的数量</p><ul><li><img src="https://s1.ax1x.com/2023/07/27/pCvX3N9.png" alt="pCvX3N9.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第八章-排序&quot;&gt;&lt;a href=&quot;#数据结构第八章-排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构第八章 排序&quot;&gt;&lt;/a&gt;数据结构第八章 排序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第八章排序的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第七章-查找</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/</id>
    <published>2024-08-11T14:19:11.000Z</published>
    <updated>2024-08-11T16:03:48.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第七章-查找"><a href="#数据结构第七章-查找" class="headerlink" title="数据结构第七章 查找"></a>数据结构第七章 查找</h2><blockquote><p>计算机学科基础：数据结构第七章查找的学习笔记</p></blockquote><span id="more"></span><h3 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1.查找的基本概念"></a>1.查找的基本概念</h3><ul><li>查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，<br>可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种<ul><li>①查询某个特定的数据元素是否在查找表中</li><li>②检索满足条件的某个特定的数据</li><li>③在查找表中插入一个数据元素</li><li>④从查找表中删除某个数据元素</li></ul></li><li>静态查找表和动态查找表<ul><li>若一个查找表的操作只涉及上述操作①和②，则无须动态地修改查找表，此类查找表称为静态查找表。</li><li>与此对应，需要动态地插入或删除的查找表称为动态查找表。<br>适合静态查找表的查找方法有顺序查找、折半查找、散列查找等，<br>适合动态查找表的查找方法有二叉排序树的查找、散列查找等。</li></ul></li><li>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</li><li>平均查找长度（<strong>ASL</strong>）：在查找过程中，一次查找的长度是指需要比较的关键字次数，<br>而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。</li></ul><h3 id="2-顺序查找和折半查找（✪）"><a href="#2-顺序查找和折半查找（✪）" class="headerlink" title="2.顺序查找和折半查找（✪）"></a>2.顺序查找和折半查找（✪）</h3><ul><li><p>顺序查找（线性查找，适用于顺序表和链表）</p><ul><li><p>一般线性表的顺序查找</p><ul><li><p>加入哨兵的线性查找，算法从尾部开始查找，此时在0号位设置一个哨兵，查找失败则返回0，<br>无需判断是否越界，提高程序效率</p><ul><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//顺序表</span></span><br><span class="line">    <span class="type">int</span> *elem;<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;   <span class="comment">//表长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST,ElemType Key)</span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key; <span class="comment">//0号位置存哨兵</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;i--) <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>平均查找长度：查找成功时：ASL=$\frac{n+1}{2}$，查找失败时为：ASL=$n+1$</p></li></ul></li><li><p>有序表的顺序查找</p><ul><li>可以设置查找判定树<ul><li>成功结点的关键字对比次数=结点所在层数</li><li>失败结点的关键字对比次数=其父节点所在层数</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/19/pC7kJsS.png" alt="pC7kJsS.png"></li></ul></li></ul></li></ul></li><li><p>平均查找长度：查找成功时：ASL=$\frac{n+1}{2}$，查找失败时为：ASL=$\frac{n}{n+1}+\frac{n}{2}$</p></li><li><p>顺序查找的时间复杂度：O(n)</p></li></ul></li><li><p>折半查找（二分查找，仅适用于<strong>有序的顺序表</strong>✪）</p><ul><li><p>此时设定中间指针(mid=(low+high)/2)，向下取整。如果较小则high=mid-1，在左边的区间再进行折半查找；<br>如果较大则low=mid+1,在右边的区间再进行折半查找。</p></li><li><p>代码实现（中间指针向下取整）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>; <span class="comment">//取有序表的中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;   <span class="comment">//查找成功则返回当前位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low=mid+<span class="number">1</span>; <span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>折半查找的判定树</p><ul><li>性质（当$\operatorname{mid}{=\lfloor(} low +   high ) / 2\rfloor$时）<ul><li>如果当前Iow和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</li><li>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</li><li>每个结点值均大于其左子结点值，小于其右子结点值</li><li>此二叉树时一颗平衡二叉树，并且有性质：右子树结点数—左子树结点数=0或1</li><li>折半查找的判定树中，只有最下面一层是不满的，元素个数为${\boldsymbol{n}}$时树高${h=\left\lceil\log _{2}(n+1)\right\rceil}$<ul><li>折半查找不成功时的最多比较次数为树的高度，最少比较次数为树的高度减一<ul><li>此时由${h=\left\lceil\log _{2}(16+1&gt;2^{4})\right\rceil}$最多需要比较5次，最少需要比较4次<img src="https://s1.ax1x.com/2023/07/20/pCHyCUf.png" alt="pCHyCUf.png"></li></ul></li></ul></li><li>若有序序列有个n元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点<br>（失败结点的数量=成功结点所构成的树的空链域数量=n+1）</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/19/pC7Exr8.png" alt="pC7Exr8.png"></li></ul></li><li>关于折半查找二叉树的例题<ul><li>例1，已知关键字的个数，求查找成功的平均复杂长度和查找失败的平均复杂长度<ul><li>此时构造判定树，采用（$\operatorname{mid}{=\lfloor(} low +   high ) / 2\rfloor$写出中间的点，<br>再根据左小右大确定两边的范围，再某段范围里通过公式求出两边的点的中间的点）<ul><li><img src="https://s1.ax1x.com/2023/07/20/pCHyxWF.png" alt="pCHyxWF.png"></li></ul></li></ul></li><li>例2，判断是否能成为折半查找中关键字的比较序列<ul><li>此时直接写出相关的判定树，之后对各元素存在的合理性进行判断，<br>A选项中200后的450说明之后的数都应该比200大，但是之后出现了180，此时不满足判定树的原理<ul><li><img src="https://s1.ax1x.com/2023/07/20/pCH6XnA.png" alt="pCH6XnA.png"></li></ul></li></ul></li></ul></li></ul></li><li><p>折半查找的时间复杂度：$O ( \log _ { 2 } n )$</p></li></ul></li><li><p>分块查找（索引顺序查找,了解）</p><ul><li><p>概述</p><ul><li>将查找表分为若干块，块内的元素可以无序，但是块间的元素必须是有序的，<br>前一个块中的最大关键字小于后一个块中所有记录的关键字</li><li>之后建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，<br>索引表按关键字有序排序。</li><li>对索引表进行折半查找时，若索引表中不包含目标关键字，则折半查找最终停在low&gt;high,要在Iow所指分块中查找</li></ul></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/20/pCH0oY4.png" alt="pCH0oY4.png"></li></ul></li><li><p>分块查找的平均时间复杂度分析（一般只分析分块查找的顺序查找索引表下的ASL）</p><ul><li><strong>当每个分块内部元素的数量（s）等于元素总数开根时<script type="math/tex">\sqrt{n}</script>时，（此时s=b=$\sqrt{n}$）此时其查找时间最小</strong></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/20/pCHBwcR.png" alt="pCHBwcR.png"></li></ul></li></ul></li><li><p>分块矩阵的相应例题</p><ul><li><p>例1，利用分块矩阵顺序查找索引查找表的公式来计算查找成功的平均查找长度，$A S L = \frac { b + 1 } { 2 } + \frac { s + 1 } { 2 }$，<br>b和s分别是块内的单元数和分块的数量，选B</p><ul><li><img src="https://s1.ax1x.com/2023/07/20/pCHcK9U.png" alt="pCHcK9U.png"></li></ul></li><li><p>例2，分析在什么条件下的分块查找的平均查找长度最小并计算，此时需要满足：块数=块长=$\sqrt{元素总数}=255$，<br>这个时候可以在索引项和索引表中都采取<strong>折半查找</strong>的方式，来计算最小的平均查找长度：${A S L=\left\lceil\log _{2}(255+1)\right\rceil + \left\lceil\log _{2}(255+1)\right\rceil}=16$</p><ul><li><img src="https://s1.ax1x.com/2023/07/20/pCHcRC8.png" alt="pCHcRC8.png"></li></ul></li></ul></li></ul></li></ul><h3 id="3-树形查找（✪）"><a href="#3-树形查找（✪）" class="headerlink" title="3.树形查找（✪）"></a>3.树形查找（✪）</h3><ul><li><p>二叉排序树（BST✪）</p><ul><li><p>二叉排序树的定义</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又各是一棵二叉排序树。</li><li>注：空树也是二叉排序树</li><li>进行中序遍历，可以得到一个递增的有序序列</li></ul></li><li><p>二叉排序树的查找</p><ul><li><p>从根结点开始，沿某个分支逐层向下比较的过程</p></li><li><p>若树非空，目标值与根结点的值比较</p><ul><li>若相等，则查找成功</li><li>若小于根结点，则在左子树上查找，否则在右子树上查找。</li></ul></li><li><p>查找成功，返回结点指针；查找失败返回NULL</p></li><li><p>代码实现（了解）</p><ul><li><p>二叉排序树的非递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> Key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;Key!=T-&gt;key)&#123;  <span class="comment">//若树空或等于根结点的值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)  <span class="comment">//小于根结点的值，在左子树上查找</span></span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;  <span class="comment">//大于根结点的值，则在右子树上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉排序树的递归算法（空间复杂度较高，执行效率较低）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key); <span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key); <span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>二叉排序树的插入</p><ul><li><p><strong>将二叉排序树T1的<u>先序遍历序列</u>依次插入初始为空的树中，所得到的二叉排序树T2和T1的形态完全相同。</strong></p></li><li><p><strong>在二叉排序树中插入一个结点的时间复杂度为O(n)</strong></p></li><li><p>插入结点的过程如下：若原二叉排序树为空，则直接插入，否则，若关键字k小于根结点值，则插入到左子树，<br>若关键字k大于根结点值，则插入到右子树。</p></li><li><p>代码实现（了解）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BiTree &amp;T,keyType k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;<span class="comment">//此时原树为空，新插入的结点为根节点</span></span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode)); </span><br><span class="line">        T-&gt;data=k;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回1，插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(K==T-&gt;data)<span class="comment">//树中存在相同关键字的结点，此时插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;data) <span class="comment">//新结点会插入到此时结点的左子树中</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//新结点会插入到此时结点的右子树中</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二叉排序树的构造</p><ul><li><p>从一颗空树出发，依次输入元素，并将其插入到二叉树中的合适位置</p></li><li><p>代码实现（了解）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BiTree &amp;T,keyType str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>; <span class="comment">//初始时为空树</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        BST_INsert(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二叉排序树的删除</p><ul><li>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</li><li>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li><li>若结点z有左、右两棵子树，则令z的直接后继（直接前驱）替代z，然后从二叉排序树中删去这个直接后继（直接前驱）<br><strong>这里的直接后驱指的是右子树中进行中序遍历的第一个数，直接前驱指的是左子树中进行中序遍历的最后一个数</strong>）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/20/pCHfwm4.png" alt="pCHfwm4.png"></li></ul></li></ul></li><li><p>二叉排序树的查找效率分析</p><ul><li>二叉排序树的查找效率，主要取决于树的高度。若树高h，找到最下层的一个结点需要对比h次</li><li>若二叉排序树的左、右子树的高度之差的绝对值不超过1(为平衡二叉树时)，它的平均查找长度为O($log_{2}n$)。</li><li>若二叉排序树是一个只有右（左）孩子的单支树（类似有序的单链表），则其平均查找长度为O(n)。<ul><li>用逐点插入法构建二叉排序树，若先后插入的关键字有序，此时二叉排序树的深度最大</li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHfLjS.png" alt="pCHfLjS.png"></li></ul></li></ul></li></ul></li><li><p>平衡二叉树（AVL树✪）</p><ul><li><p>平衡二叉树的定义</p><ul><li>平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：<br>它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。</li><li>结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</li></ul></li><li><p>平衡二叉树的插入</p><ul><li><p>概述</p><ul><li>每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。</li><li><strong>若导致了不平衡，则先找到插入路径上<u>离插入结点最近的</u>平衡因子的绝对值大于1的结点A，</strong><br><strong>再对以A为根的子树（最小不平衡子树），在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</strong><ul><li>此时找到距离插入点最近的平衡因子的绝对值大于1的点为序号70，LL插入，此时则应该变动70的左子树68进行右上旋</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHvN3F.png" alt="pCHvN3F.png"></li></ul></li></ul></li><li><strong>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡</strong></li></ul></li><li><p>四种调整的情况</p><ul><li><p>LL：在A的左孩子的左子树中插入导致不平衡</p><ul><li><p>进行右单旋转，将A的左孩子右上旋</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHbUcn.png" alt="pCHbUcn.png"></li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f是双亲结点，gf是f的双亲结点</span></span><br><span class="line">f-&gt;lchild=p-&gt;rchild;</span><br><span class="line">p-&gt;rchild=f;</span><br><span class="line">gf-&gt;lchild/rchild=p</span><br></pre></td></tr></table></figure></li></ul></li><li><p>RR：在A的右孩子的右子树中插入导致不平衡</p><ul><li><p>进行左单旋转，将A的右孩子左上旋</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHbH9H.png" alt="pCHbH9H.png"></li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f-&gt;rchild=p-&gt;lchild;</span><br><span class="line">p-&gt;lchild=f;</span><br><span class="line">gf-&gt;lchild/rchild=p;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>LR：在A的左孩子的右子树中插入导致不平衡</p><ul><li>在A的左孩子的右子树插入导致A不平衡，<strong>将A的左孩子的右孩子先左上旋再右上旋</strong>（此时这里的A为66，绝对值大于1）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHXGbq.png" alt="pCHXGbq.png"></li></ul></li></ul></li><li><p>RL：在A的右孩子的左子树中插入导致不平衡</p><ul><li>在A的右孩子的左子树插入导致A不平衡，<strong>将A的右孩子的左孩子先右上旋再左上旋</strong>（此时这里的A为50(绝对值大于1)）</li><li>图片1<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHXdGF.png" alt="pCHXdGF.png"></li></ul></li><li>图片2<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCHjZQJ.png" alt="pCHjZQJ.png"></li></ul></li></ul></li></ul></li></ul></li><li><p>平衡二叉树的删除</p><ul><li>步骤<ul><li>①删除结点(方法同“二叉排序树”)</li><li>②向上看是否导致存在不平衡，若没有则结束</li><li>③找最小不平衡子树下，“个头”最高的儿子、孙子</li><li>④根据孙子相对于最小不平衡子树的根结点的位置，使用相关方法调整平衡(LL/RR/LR/RL)<ul><li>孙子在LL:儿子右单旋</li><li>孙子在RR:儿子左单旋</li><li>孙子在LR:孙子先左旋，再右旋</li><li>孙子在RL:孙子先右旋，再左旋</li></ul></li><li>⑤如果不平衡向上传导，继续②<ul><li>对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</li></ul></li></ul></li><li>例子：此时删除32后向上找到44不平衡，向下找到44最高的儿子和孙子78、50。孙子的情况是RL，<br>则此时对其先右上旋再左上旋，调整为平衡二叉树<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCbSqgO.png" alt="pCbSqgO.png"></li></ul></li><li>对于一个平衡二叉树如果删除一个结点后再插入（不管是叶结点还是分支结点）此时树可能会发生改变；<br>对于一个二叉排序树，删除叶子结点后再插入此时树不变，删除分支结点后再插入树会发生改变。</li></ul></li><li><p>平衡二叉树的查找</p><ul><li>在查找过程中，查找次数不会超过平衡二叉树的深度</li><li>在平衡二叉树上，树上任一结点的左子树和右子树的高度之差不超过 1 。</li><li>假设以${n_{h}}$表示深度为${h}$的平衡树中含有的最少结点数。则有${n_{0}=0, n_{1}=1, n_{2}=2}$, 并且有${n_{h}=n_{h-1}+n_{h-2}+1}$<ul><li>本题用此方法递推计算（1,2,4,7,12,20）构建5层平衡二叉树至少需要12个顶点，<br>构建6层平衡二叉树至少需要20个顶点，因此含有15个顶点的平衡二叉树的最大深度为5</li><li>平衡二叉树总结点数最小时，所有非叶节点的平衡因子都为1</li></ul></li><li>含有$\mathrm{n}   个结点的平衡二叉树深度最小值为 \left\lfloor\log _{2} \mathrm{n}\right\rfloor+1$</li><li>平衡二叉树的平均查找长度为${O\left(\log _{2} n\right)}$</li></ul></li></ul></li><li><p>红黑树（RBT✪）</p><ul><li>红黑树的定义：一种特殊的二重排序树<ul><li>红黑树RBT，插入/删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。<br>即便需要调整，一般都可以在常数级时间内完成</li><li>平衡二叉树：适用于以查为主、很少插入/删除的场景</li><li>红黑树：适用于频繁插入、删除的场景，实用性更强</li><li>结点的黑高：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数</li></ul></li><li>红黑树的五个特点（左根右，根叶黑，不红红，黑路同）<ul><li>每个结点或是红色，或是黑色的</li><li>根节点是黑色的</li><li>叶结点(这里指NULL和结点失败结点)均是黑色的</li><li>不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</li><li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li></ul></li><li>红黑树的结论<ul><li>从根节点到叶结点的最长路径不大于最短路径的2倍<ul><li>当从根到任意一个叶结点的简单路径最短时，这条路径必然全部由黑结点构成</li><li>当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时两者的数量相同</li><li>红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过2</li></ul></li><li>有n个内部节点的红黑树高度 h≤$2log_{2}(n+1)$</li><li>根节点黑高为h的红黑树，内部结点数（关键字）至少有$2^{h}-1$个</li><li>红黑树查找操作时间复杂度=O($log_{2}n$)，查找效率与AVL树同等数量级</li></ul></li><li>红黑树的插入<ul><li>插入结点的方法，注：一般插入时违背的是“不红红”<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCbViRA.png" alt="pCbViRA.png"></li></ul></li><li>例子<ul><li><img src="https://s1.ax1x.com/2023/07/21/pCbVnIg.png" alt="pCbVnIg.png"></li></ul></li></ul></li></ul></li></ul><h3 id="4-B树与B-树（✪）"><a href="#4-B树与B-树（✪）" class="headerlink" title="4.B树与B+树（✪）"></a>4.B树与B+树（✪）</h3><ul><li><p>B树（✪）</p><ul><li><p>B树的性质</p><ul><li>m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。</li><li>一棵m阶B树或为空树，或为满足如下特性的m叉树<ul><li><strong>树中每个结点至多有$m$棵子树，即至多含有$m-1$个关键字。</strong></li><li>若根结点不是叶结点，则至少有两棵子树。</li><li><strong>除根结点外的所有非叶结点至少有$ \lceil m / 2\rceil $棵子树，即至少含有$ \lceil m / 2\rceil-1 $个关键字。</strong></li><li>满足左&lt;中&lt;右的性质</li><li>所有叶节点都出现在同一层次上，并且不带信息（即为查找失败结点）</li><li>${\mathrm{n}}$个关键字的B树必有${\mathrm{n}+1}$个叶子结点</li><li>注：判断B树的类型，需要看其中关键字最多的结点判断是几阶</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCqrBkV.png" alt="pCqrBkV.png"></li></ul></li></ul></li></ul></li><li><p>B树的最小高度和最大高度（此时一般不包括最后一层叶子结点的层数）</p><ul><li>对于n个关键字，m阶B树的最小高度<ul><li>在每一层中含有最多的结点数并且在每一个结点中含有最多的关键字数</li><li>此时关键字的数量满足：$n \leqslant(m-1)\left(1+m+m^{2}+\cdots+m^{h-1}\right)=m^{h}-1$</li><li>此时可算出最小的高度： $h \geqslant \log _{m}(n+1)$</li></ul></li><li>对于n个关键字，m阶B树的最大高度<ul><li>在每一层中含有最小的结点数并且在每一个结点中含有最少的关键字数</li><li>此时让各层的分叉尽可能的少, 即根节点只有 2 个分叉, 其他结点只有${\lceil m / 2\rceil}$个分叉</li><li>各层结点至少有：第一层 1、第二层 2、第三层${2\lceil\mathrm{m} / 2\rceil \ldots}$第h层${2(\lceil\mathrm{m} / 2\rceil)^{h-2}}$，<br>则第h+1层共有叶子结点（失败结点）${2(\lceil m / 2\rceil)^{h-1}}$个</li><li>${\mathrm{n}}$个关键字的B树必有${\mathrm{n}+1}$个叶子结点, 则${n+1 \geq 2(\lceil m / 2\rceil)^{h-1}}$, 即${h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1}$</li><li>此时可算出最大的高度：$h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1$</li></ul></li><li>含$\mathrm{n}$个关键字的$\mathrm{m叉B} 树, 满足 \log _{m}(n+1) \leq h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1$</li></ul></li><li><p>B树的插入</p><ul><li>首先定位元素插入的位置，新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</li><li>如果再插入关键字后，结点中的关键字数量没有超过上限，此时直接插入即可<br>（如阶为5的B树的关键字范围为2—4，在一个结点中最多有4个，最少有2个关键字）</li><li>在插入key后, 若导致原结点关键字数超过上限, 则从中间位置${(\lceil\mathrm{m} / 2\rceil)}$将其中的关键字分为两部分,<br>左部分包含的关键字放在原结点中, 右部分包含的关键字放到新结点中, 中间位置${(\lceil{m} / 2\rceil)}$的结点插入原结点的父结点</li><li>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，<br>进而导致B树高度增1。</li><li>图片<ul><li>图1<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCqy956.png" alt="pCqy956.png"></li></ul></li><li>图2<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCqyi8O.png" alt="pCqyi8O.png"></li></ul></li></ul></li></ul></li><li><p>B树的删除</p><ul><li><p>若被删除关键字在非终端节点，则用直接前驱或直接后继来替代被删除的关键字</p><ul><li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li><li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li><li><img src="https://s1.ax1x.com/2023/07/23/pCqy8MQ.png" alt="pCqy8MQ.png"></li></ul></li><li><p>若被删除关键字在终端节点，此时分为下列三种情况</p><ul><li>删除后的结点中的关键字的数量不低于低于下限${\lceil m / 2\rceil-1}$时，则直接删除该关键字</li><li>（兄弟够借）<ul><li>删除后结点的关键字数量将低于下限${\lceil m / 2\rceil-1}$，且与结点相邻的右（或左）兄弟结点的关键字个数还很宽裕，</li><li>此时删除该结点后，将其对应的一个父节点的关键字转移到此处，并将右兄弟或左兄弟的一个关键字转移到此父节点</li><li>去借右兄弟：<ul><li>此时删除38，此时其右兄弟够用，将父结点关键字49下移来替换38，<br>并且将右兄弟关键字70上移到原来的父节点关键字处</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCq6Ces.png" alt="pCq6Ces.png"></li></ul></li></ul></li><li>去借左兄弟<ul><li>此时删除90，其左兄弟够用，使父结点关键字88下移，再将左兄弟结点关键字87上移</li><li>图片1<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCq68fK.png" alt="pCq68fK.png"></li></ul></li><li>图片2<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCq6d0A.png" alt="pCq6d0A.png"></li></ul></li></ul></li></ul></li><li>(兄弟不够借)<ul><li>若被删除关键字所在结点删除关键字后少于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均${\lceil m / 2\rceil-1}$, </li><li>则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</li><li>在合并过程中, 双亲结点中的关键字个数会减 1，此时可能需要对双亲结点进行相关操作<ul><li>若双亲结点不是根结点, 且关键字个数减少到${\lceil m / 2\rceil-2}$, 则又要与它自己的兄弟结点进行调整或合并操作,<br>并重复上述步骤, 直至符合${B}$树的要求为止。</li><li>若其双亲结点是根结点且关键字个数减少至 0 (根结点关键字个数为 1 时, 有 2 棵子树) , 则直接将根结点删除,<br>合并后的新结点成为根</li></ul></li><li>流程<ul><li>此时删除49，但是其右兄弟的关键字数量已经不够借，<br>此时删除49之后将父结点关键字70下移以及和其右兄弟结点的两个关键字合并到一起<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCq6TpT.png" alt="pCq6TpT.png"></li></ul></li><li>此时合并之后，上方的父结点中的关键字数量已经少于下限，此时也需要合并，<br>可将父结点82与其右兄弟结点中的87,93关键字合并到一起，此时根节点为空，删除根结点即可<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCq6vA1.png" alt="pCq6vA1.png"></li><li><img src="https://s1.ax1x.com/2023/07/23/pCqcu38.png" alt="pCqcu38.png"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>B+树（适用于数据库）</p><ul><li><p>B+树的性质</p><ul><li>每个分支结点最多有m棵子树（孩子结点）</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有${\lceil\mathrm{m} / 2\rceil}$棵子树。</li><li>结点的子树个数与关键字个数相等。</li><li>所有<strong>叶结点</strong>包含<strong>全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，<br>并且相邻叶结点按大小顺序相互链接起来。（支持顺序查找）</li><li>所有分支结点中仅包含它的各个子结点中关键字的<strong>最大值</strong>及指向其<strong>子结点的指针</strong>。</li><li><p>B+树含有两个头指针，一个指向根结点，一个指向关键字最小的叶结点，<br>可以进行从最小关键字开始的顺序查找以及从根结点开始的多路查找</p><ul><li>在B+树中进行的多路查找，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，<br>直到叶结点上的该关键字为止。在B+树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。</li></ul></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/23/pCqcdvF.png" alt="pCqcdvF.png"></li></ul></li></ul></li><li><p>B+树与B树的区别</p><ul><li>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；<br>而在B树中，具有n个关键字的结点含有n+1棵子树。</li><li>在B+树中，每个结点（非根内部结点）的关键字个数n的范围是 ${\lceil\mathrm{m} / 2\rceil} ≤n≤m$ (而根结点：$1≤n≤m$)；<br>而在B树中，每个结点（非根内部结点）的关键字个数n的范围是${\lceil\mathrm{m} / 2\rceil}-1≤n≤m-1$ (根结点：$1≤n≤m-1$)</li><li>在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；<br>而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。</li><li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，<br>非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>B树的结点中都包含了关键字对应的记录的存储地址</li></ul></li></ul></li></ul><h3 id="5-散列表（✪）"><a href="#5-散列表（✪）" class="headerlink" title="5.散列表（✪）"></a>5.散列表（✪）</h3><ul><li>散列表的基本概念<ul><li>散列表 (哈希表，Hash Table)：是一种数据结构。根据关键字而直接进行访问的数据结构。<br>散列表建立了关键字和存储地址之间的一种直接映射关系。</li><li>散列函数（哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，<br>记为Hash(key)=Addr (这里的地址可以是数组下标、索引或内存地址等)</li><li>冲突和同义词：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，<br>这些发生碰撞的不同关键字称为同义词</li></ul></li><li>散列表的构造<ul><li>进行构造的要点<ul><li>定义域必须涵盖所有可能出现的关键字，值域不能超出散列表的地址范围</li><li>尽可能减少冲突。散列函数计算出来的地址应尽可能均匀分布在整个地址空间。</li><li>散列函数应尽量简单，能够快速计算出任意一个关键字对应的散列地址</li></ul></li><li>四种构造的方法<ul><li>除留余数法：H(key)=key%p<ul><li>散列表表长为m，取一个不大于m但最接近或等于m的质数p</li><li>如表长为13，16，p可以均选13</li><li>只要关键字为整数就适用</li></ul></li><li>直接定址法：H(key)=key或H(key)=a*key+b<ul><li>其中，和b是常数。这种方法计算最简单，且不会产生冲突。<br>若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li><li>适用场景：关键字分布基本连续</li></ul></li><li>数字分析法：选取数码分布较为均匀的若干位作为散列地址<ul><li>每个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；<br>而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。</li><li>适用场景：关键字集合已知，且关键字的某几个数码位分布均匀</li></ul></li><li>平方取中法：取关键字的平方值的中间几位作为散列地址<ul><li>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀。</li><li>适用场景：关键字的每位取值都不够均匀。</li></ul></li></ul></li></ul></li><li>处理冲突的方法<ul><li>开放定址法：如果发生冲突，就给新元素找另一个空闲的位置<ul><li>数学递推公式为：$H _ { i } = ( H ( k e y ) + d _ { i } ) \% m$（m为散列表表长）</li><li>其中$d_{i}$为增量序列（偏移量），通过四种方法可以进行选择</li><li>采用“开放定址法”时，删除元素不能简单地将被删元素的空间置为空，<br>否则将截断在它之后的探测路径，可以做一个“已删除”标记，<strong>进行逻辑删除</strong>。</li><li>理想情况下，若散列表表长=m,则最多发生m-1次冲突即可“探测”完整个散列表。</li><li>线性探测法<ul><li>$d_{i}=0,1,2,3……m-1$</li><li>可以探测到散列表的每一个地址，但是容易造成大量元素在相邻的散列地址上聚集，大大降低查找效率</li><li>堆积问题是由于同义词之间或非同义词之间发生冲突导致的</li><li><strong>当从散列表中删除一个记录时，不应将这个记录的所在位置置为空，因为这将会影响后面的查找，逻辑删除即可</strong></li></ul></li><li>平方探测法（又称为二次探测法）<ul><li>${d_{i}=0^{2}, 1^{2},-1^{2}, 2^{2},-2^{2}, \ldots, k^{2},-k^{2}}$。 其中${k \leq m / 2}$</li><li>采用平方探测法，至少可以探测到散列表中一半的位置，即便散列表中有空闲位置，也未必能插入成功</li><li>若散列表长度m是一个可以表示成4k+3的素数(如7、11、19)，平方探测法就能探测到所有位置</li><li>可以有效避免堆积的问题</li></ul></li><li>双散列法<ul><li>${d_{i}=\mathbf{i} \times \operatorname{hash}_{2}(k e y)}$</li><li>双散列法未必能探测到散列表的所有位置。双散列法的探测覆盖率取决于第二个散列函数hash2(key)设计的是否合理。</li><li>若hash2(key)计算得到的值与散列表表长m互质，就能保证双散列发可以探测所有单元</li><li>令表长m本身就是质数，hash2(key)=m-(key%m)，此时无论key值是多少，hash2(key)和m一定互质</li></ul></li><li>伪随机序列法：d是一个伪随机序列，由程序员人为设计</li></ul></li><li>拉链法（链地址法）<ul><li>适用于经常进行插入和删除的情况</li><li>查找长度是指的查找时与相应关键字的对比次数</li><li>如此时要找40，此时需要在1处的链表查找4次，未能找到<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCqqPvd.png" alt="pCqqPvd.png"></li></ul></li></ul></li></ul></li><li>散列查找及性能分析<ul><li>先求得散列地址，在散列地址上已有关键字且与查找的关键字不同时，使用相关方法进行冲突处理。<br>若散列地址上没有关键字此时查找失败。若散列地址上的关键字与被查找关键字相等，此时查找成功，返回相应的地址</li><li>散列表的查找效率主要取决于：散列函数，处理冲突的方法和装填因子</li><li>装填因子a，定义为一个表的装满程度：$a=\frac{表中记录数n}{散列表长度m}$</li><li>散列表的平均查找长度依赖于散列表的装填因子$a$，而不直接依赖于n或m。<br>直观地看，$a$越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。</li><li>例题：求查找失败的平均查找长度就是查到表中的空地址时，即查找失败，此时虽然表中有序号为7的元素，<br>但是由于散列为7的余数，此时只会在0-6的范围内有相对应的地址，但是查询的时候会查到序号为8的地方。<ul><li><img src="https://s1.ax1x.com/2023/07/23/pCLSwHH.png" alt="pCLSwHH.png"></li><li><img src="https://s1.ax1x.com/2023/07/23/pCLSDUA.png" alt="pCLSDUA.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第七章-查找&quot;&gt;&lt;a href=&quot;#数据结构第七章-查找&quot; class=&quot;headerlink&quot; title=&quot;数据结构第七章 查找&quot;&gt;&lt;/a&gt;数据结构第七章 查找&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第七章查找的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第六章-图</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE/</id>
    <published>2024-08-11T14:18:52.000Z</published>
    <updated>2024-08-11T15:09:56.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第六章-图"><a href="#数据结构第六章-图" class="headerlink" title="数据结构第六章 图"></a>数据结构第六章 图</h2><blockquote><p>计算机学科基础：数据结构第六章图的学习笔记</p></blockquote><span id="more"></span><h3 id="1-图的定义（✪）"><a href="#1-图的定义（✪）" class="headerlink" title="1.图的定义（✪）"></a>1.图的定义（✪）</h3><ul><li><p>定义</p><ul><li>图G由顶点集V和边集E组成，记为G=(V,E)</li><li>其中V(G)表示图G中顶点的有限非空集（称为图的阶）；E(G)表示图G中顶点之间的关系（边）集合。</li><li>图不能是空图，顶点集不能为空，但是边集可以为空</li><li><strong>对于一个具有n个顶点和e条边的图，若采用边集数组表示，则边集数组中的单元数至少为2e个</strong></li></ul></li><li><p>一些关于图的概念</p><ul><li>无向图：若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为(v,w)或(w,v)。</li><li>有向图：若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是项点的有序对，记为<v,w>，<br>其中v,w是顶点，v称为弧尾，w称为弧头，<y,w>称为从v到w的弧，也称v邻接到w。</y,w></v,w></li><li>简单图、多重图：不存在重复边且不存在顶点到自身的边，则图G即为简单图，否则为多重图</li><li>度<ul><li>对于无向图，顶点v的度是指依附于顶点v的边的条数，<br><strong>无向图的全部顶点的度的和等于边数的两倍（无向图所有顶点的度之和为偶数）</strong></li><li>对于有向图，顶点v的度分为入度和出度，<strong>有向图的全部顶点的入度之和与出度之和相等，并且等于边数。</strong></li><li>例题<ul><li>此时直接利用相关的关系，所有顶点的度数之和等于边数量的两倍（4*5+3*4+2<em>(n-9)=23\</em>2）选D<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIG4Ln.png" alt="pCIG4Ln.png"></li></ul></li></ul></li></ul></li><li>路径与回路<ul><li>路径：由顶点和相邻顶点序偶构成的边所形成的序列<ul><li>注意：由不同顶点所形成的序列不是路径的定义</li></ul></li><li>回路（环）：第一个顶点和最后一个顶点相同的路径称为回路或环<ul><li><strong>有n个顶点和n条边的无向图一定是有环的</strong></li><li><strong>如果有向图中存在拓扑排序，则其一定是无环的</strong></li></ul></li><li>简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。<ul><li>最短路径一定是简单路径</li></ul></li><li>简单回路：除第一个项点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li><li>路径长度：路径上边的数目</li><li>点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。<br>若从u到v根本不存在路径，则记该距离为无穷(∞)。</li></ul></li><li>连通与强连通<ul><li>无向图中，若从项点v到项点w有路径存在，则称顶点v和顶点w之间是连通的</li><li>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的<strong>（可以去和回）</strong></li></ul></li><li>连通图与强连通图<ul><li>连通图：任意两个顶点之间都是连通的无向图，则称为连通图否则为非连通图。<ul><li><strong>对于n个顶点的无向图G，若G是连通图，则最少有n-1条边</strong><ul><li>注意理解：是G为连通图可以推导出该无向图至少有n-1条边</li><li>此题选D<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIJKFf.png" alt="pCIJKFf.png"></li></ul></li><li>此题选D，这时肯定构成了回路，但是不一定是连通图<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCI1Bq0.png" alt="pCI1Bq0.png"></li></ul></li></ul></li><li><strong>若其为非连通图无向图，则最多可能有$\frac {n ( n - 1 ) } {2} $条边</strong><ul><li>如果出现由n-1个完全无向图与另外一个单独顶点的极端情况，此时只需加1，<br>则可以确保这n个顶点可以构成无向连通图<ul><li>本题即为（5*4）/2+1=11，选D<img src="https://s1.ax1x.com/2023/07/16/pCIGGa6.png" alt="pCIGGa6.png"></li></ul></li></ul></li></ul></li><li>强连通图：任意一对顶点之间都是强连通的有向图。<ul><li><strong>对于n个顶点的有向图G，若其为强连通图，则最少有n条边（形成回路）</strong></li></ul></li></ul></li><li>连通分量与强联通分量<ul><li>连通分量：无向图的极大连通子图（<strong>必须连通且尽可能包含更多的顶点和边</strong>）<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIKLDK.png" alt="pCIKLDK.png"></li></ul></li><li>强连通分量：有向图的极大强连通子图（<strong>必须强连通且尽可能包含更多的边</strong>）<ul><li>注：若一个图存在环，则其一定<strong>含有</strong>顶点数大于1的强连通分量</li><li><img src="https://s1.ax1x.com/2023/07/16/pCIKOHO.png" alt="pCIKOHO.png"></li></ul></li></ul></li><li>子图与生成子图<ul><li>设有两个图G=(V,E)和G1=(V1,E1),若V1是V的子集，且E1是E的子集，则称G1是G的子图。<ul><li>此时需要V1和E1先相互对应，即构成了图。如下面的描述错误<img src="https://s1.ax1x.com/2023/07/16/pCI3ffg.png" alt="pCI3ffg.png"></li></ul></li><li>若有满足V(G)=V(G1)的子图G,则称其为G的生成子图。<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIKRBT.png" alt="pCIKRBT.png"></li></ul></li></ul></li><li>生成树与生成森林<ul><li>连通图的生成树是包含图中全部顶点的一个极小连通子图<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIMCvt.png" alt="pCIMCvt.png"></li></ul></li><li>生成森林<ul><li>非连通图中，连通分量的生成树构成了非连通图的生成森林<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIMFDf.png" alt="pCIMFDf.png"></li></ul></li></ul></li><li>边的权、带权图（网）<ul><li>边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</li><li>带权图/网：边上带有权值的图称为带权图，也称网。</li><li>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li></ul></li></ul></li><li>几种特殊的图<ul><li>完全图<ul><li>无向完全图：无向图中任意两个顶点之间都存在边，共有条$\frac {n ( n - 1 ) } {2} $边</li><li>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，共有$n(n-1)$条边</li><li><strong>讨论拥有n个顶点的无向图需要多少条边才能确保形成一个连通图，</strong><br><strong>此时常常考虑为由n-1个顶点之间形成的完全无向图与另外一个单独结点的组合时，再添加一条边，使这两部分相连。</strong></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCI8Obt.png" alt="pCI8Obt.png"></li></ul></li></ul></li><li>树：不存在回路，且连通的无向图，n个顶点的树，必有n-1条边。n个顶点的图，若边大于n-1,则一定有回路</li><li>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图</li></ul></li></ul></li></ul><h3 id="2-图的存储（✪）"><a href="#2-图的存储（✪）" class="headerlink" title="2.图的存储（✪）"></a>2.图的存储（✪）</h3><ul><li><p>邻接矩阵法（二维数组实现的顺序存储方式✪）</p><ul><li><p>使用邻接矩阵存储，是指用一个一维数组存储图中项点的信息，<br>用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p></li><li><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100 <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum]; <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//临接矩阵，存放边的关系</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum; <span class="comment">//图的当前顶点数和边数、弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure></li><li><p>邻接矩阵存储有向图与无向图</p><ul><li>值为1时边之间有关系，为0时无关系</li><li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。（只需存储上下三角矩阵的元素）</li><li>对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是顶点的度数</li><li>对于有向图，邻接矩阵的第i行非零元素的个数正好是顶点i的出度，第i列非零元素的个数正好是顶点i的入度</li><li>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(n)</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCI0HFs.png" alt="pCI0HFs.png"></li></ul></li></ul></li><li><p>邻接矩阵存储带权图</p><ul><li>∞元素和0元素表示两边之间不邻接，非零数表示相应的权值</li><li><img src="https://s1.ax1x.com/2023/07/16/pCIB1pt.png" alt="pCIB1pt.png"></li></ul></li><li><p>邻接矩阵的相关性质</p><ul><li><strong>邻接矩阵表示法的空间复杂度为O($n^{2}$),其中n为图的顶点数。</strong></li><li><strong>稠密图适合使用邻接矩阵的存储表示。</strong></li><li><strong>邻接矩阵关于利用矩阵乘法计算路径条数的的重要性质</strong><ul><li>矩阵的平方相当于求路径长度为2的路径条数：此时从B到B路径长度为2的路径条数为3<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIBakj.png" alt="pCIBakj.png"></li></ul></li><li>矩阵的立方相当于求路径长度为3的路径条数，此时从B到C路径长度为3的路径条数为4<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIBD10.png" alt="pCIBD10.png"></li></ul></li></ul></li></ul></li></ul></li><li><p>邻接表法（顺序+链式存储✪）</p><ul><li>对图G中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点$v_{i}$的边(对于有向图则是以顶点为尾的弧)，<br>这个单链表就称为顶点$v_{i}$的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表）</li><li>顶点表结点由顶点域(data)和指向第一条邻接边的指针(firstarc)构成，<br>边表（邻接表）结点由邻接点域(adivex)和指向下一条邻接边的指针域(nextarc)构成。</li><li>图片<ul><li>存储无向图<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCI2btS.png" alt="pCI2btS.png"></li></ul></li><li>存储有向图<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIRrcj.png" alt="pCIRrcj.png"></li></ul></li></ul></li><li>特点<ul><li><strong>若G为无向图，则所需的存储空间为O(V+2E)</strong>，<strong>若G为有向图，则所需的存储空间为O(V+E)</strong>。<br>前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。（n个顶点的无向图的邻接表最多含有n(n-1)个边表顶点）</li><li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。<ul><li>在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)</li><li>如果要确定两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li></ul></li><li>在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数，<br>但求其顶点的入度则需要遍历全部的邻接表（<strong>在有向图的邻接表中，顶点v在边表的出现次数等于顶点v的入度</strong>）</li><li>图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，<br>它取决于建立邻接表的算法及边的输入次序。</li></ul></li><li>邻接表与邻接矩阵的对比<ul><li><img src="https://s1.ax1x.com/2023/07/16/pCIRw4S.png" alt="pCIRw4S.png"></li></ul></li></ul></li><li><p>十字链表（只能用于存储有向图）</p><ul><li>空间复杂度为O(V+E)，此时要找顶点的出边顺着绿色路线，要找入边顺序橙色路线。</li><li><img src="https://s1.ax1x.com/2023/07/17/pCoFIu4.png" alt="pCoFIu4.png"></li></ul></li><li><p>邻接多重表（只能用于存储无向图）</p><ul><li>空间复杂度为O(V+E)，删除边和顶点很方便</li><li><img src="https://s1.ax1x.com/2023/07/17/pCoAAoR.png" alt="pCoAAoR.png"></li></ul></li></ul><h3 id="3-图的遍历（选择题考点，代码了解即可✪）"><a href="#3-图的遍历（选择题考点，代码了解即可✪）" class="headerlink" title="3.图的遍历（选择题考点，代码了解即可✪）"></a>3.图的遍历（选择题考点，代码了解即可✪）</h3><ul><li><p>定义：图的遍历是从图的某一顶点出发，按照某种搜索方法沿着图中的边对图的所有顶点访问一次且仅访问一次。</p></li><li><p>广度优先搜索（BFS）</p><ul><li>特点<ul><li><strong>与二叉树的层序遍历完全一致，都是利用队列进行遍历操作，出队时将其相邻元素入队</strong><br>（使用数组标记已经入队的顶点不用在入队）</li><li>同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一</li><li>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</li><li>空间复杂度最坏情况下为：O(V)</li></ul></li><li>要点<ul><li>找到与一个顶点相邻的所有顶点</li><li>标记哪些顶点被访问过（visited数组）</li><li><strong>需要一个辅助队列，用队列来暂存刚访问过的结点</strong></li></ul></li><li>代码实现<ul><li><img src="https://s1.ax1x.com/2023/07/17/pCoeoDO.png" alt="pCoeoDO.png"></li><li><img src="https://s1.ax1x.com/2023/07/17/pCoef81.png" alt="pCoef81.png"></li></ul></li><li>时间复杂度分析<ul><li>采用邻接表时<ul><li>访问 |V| 个顶点需要O(|V|)的时间 </li><li>查找各个顶点的邻接点共需要O(|E|)的时间, 时间复杂度${=O(|V|+|E|)}$</li></ul></li><li>采用邻接矩阵时<ul><li>访问${|\mathbf{V}|}$个顶点需要${O(|\mathbf{V}|)}$的时间</li><li>查找每个顶点的邻接点都需要${O(|V|)}$的时间, 而总共有${|\mathbf{V}|}$个顶点的时间复杂度${=O\left(|V|^{2}\right)}$</li></ul></li></ul></li><li>广度优先生成树<ul><li>同一个图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，<br>但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。</li><li><img src="https://s1.ax1x.com/2023/07/17/pConPOK.png" alt="pConPOK.png"></li></ul></li></ul></li><li>深度优先搜索（DFS）<ul><li>特点：<strong>与树的先序遍历类似，采用根左右的顺序，需要借助于栈，最坏的空间复杂度为O(V)</strong></li><li>要点：此时不需要队列，但是需要借助于函数调用栈以及标记哪些顶点被访问过的visited数组</li><li>代码实现<ul><li><img src="https://s1.ax1x.com/2023/07/17/pColTSJ.png" alt="pColTSJ.png"></li></ul></li><li>时间复杂度分析<ul><li>采用邻接矩阵：查找每个顶点的邻接点所需的时间为${O(| V|)}$，故总的时间复杂度为${O\left(| V^{2}\right)}$。</li><li>采用邻接表：查找所有顶点的邻接点所需的时间为${O(|E|)}$, 访问顶点所需的时间为${O(|V|)}$,<br>此时, 总的时间复杂度为${O(|V|+|E|)}$。</li></ul></li><li>利用邻接表找出深度优先遍历的顺序<ul><li>此时的具体方法是，首先找到开始的顶点的那条链，遍历一个之前没有遍历到的元素时，从此元素的链继续开始遍历，<br>如果此链遍历完成，那么退回上一个链继续进行上述有关操作。<ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo1MXn.png" alt="pCo1MXn.png"></li></ul></li></ul></li><li>深度优先生成树<ul><li>同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一</li><li>同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</li></ul></li></ul></li><li>图的遍历与图的连通性<ul><li>对于无向图遍历调用BFS/DFS函数的次数<ul><li>若其为连通的，只需要一次遍历即可</li><li><strong>若其为非连通的，此时的遍历次数为其连通分量的数量。</strong></li></ul></li><li>对于有向图遍历调用BFS/DFS函数的次数<ul><li>此时情况不确定，若起始顶点到其他各顶点都有路径，则只需调用次1BFS/DFS函数</li><li>对于强连通图，从任一结点出发都只需调用1次BFS/DFS</li></ul></li></ul></li></ul><h3 id="4-图的应用（✪）"><a href="#4-图的应用（✪）" class="headerlink" title="4.图的应用（✪）"></a>4.图的应用（✪）</h3><ul><li><p>求最小生成树问题（✪）</p><ul><li>最小生成树的概念<ul><li>对于一个<strong>带权连通无向图</strong>G=(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。<br>若T为R中边的权值之和最小的那棵生成树，则T称为G的最小生成树(Minimum-Spanning-Tree,MST)。</li><li><strong>最小生成树可能不是唯一的，树形可能不唯一（因为图中可能存在权值相等的边）</strong><ul><li>只要无向连通图中没有权值相同的边，则其最小生成树唯一，此说法正确</li><li>只要无向连通图中有权值相同的边，则其最小生成树一定不唯一，此说法错误<br>（此时若无向图本身就是一颗树，则最小生成树就是其本身，此时唯一）</li></ul></li><li><strong>最小生成树的边的权值之和总是唯一的（代价唯一且最小）</strong></li><li>最小生成树的边数为顶点数量减一</li><li>最小生成树的算法基于贪心算法的策略</li></ul></li><li>Prim算法<ul><li>概述：从某一个顶点开始构建生成树，之后选择一个与当前树中的集合距离最近的顶点纳入生成树，<br>直到所有顶点都纳入为止。</li><li>此时若顶点数量为n，则此时生成的最小生成树的边数为n-1</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo6e4e.png" alt="pCo6e4e.png"></li></ul></li><li>普里姆算法的特点<ul><li>时间复杂度：O($V^{2}$)，只与顶点有关，不依赖于边</li><li>适合求解边稠密图的最小生成树</li></ul></li></ul></li><li>kruskal算法<ul><li>概述：按边来构建最小生成树，每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）<br>直到所有结点都连通</li><li>图片：如此图中，第二次选择的边为权值最小的边，权值为2<ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo6dvn.png" alt="pCo6dvn.png"></li></ul></li><li>克鲁斯卡尔算法的特点<ul><li>时间复杂度：O($|E|log_{2}E$)，只与边的数量有关，与顶点的数量无关</li><li>适合求边稀疏图而顶点多的图的最小生成树</li></ul></li></ul></li></ul></li><li><p>求最短路径问题（✪）</p><ul><li><p>最短路径的定义</p><ul><li>从一个顶点到图中其余任意一个顶点的一条路径（可能不止一条）所经过边上的权值之和，<br>定义为该路径的（带权）路径长度，（带权）路径长度最短的称为最短路径</li><li>最短路径一定是简单路径</li></ul></li><li><p>求单源最短路径（分为有权图和无权图的求法）</p><ul><li><p>BFS(广度优先)算法求<strong><u>无权图</u></strong>的单源最短路径问题（无权图相当于每一条边的权值都为1）</p><ul><li><p>概述：就是对广度优先搜索的小修改，在visit访问一个顶点时，修改其最短路径长度d【】并在path【】记录前驱结点</p></li><li><p>代码实现</p><ul><li><strong>由顶点2开始时，2到8的最短路径长度=d[8]=3，通过path数组可知，2到8的最短路径为：8&lt;一7&lt;一6&lt;一2</strong></li><li><img src="https://s1.ax1x.com/2023/07/17/pCogyp4.png" alt="pCogyp4.png"></li></ul></li></ul></li><li><p>Dijkstra算法求<strong><u>有权图</u></strong>单源最短路径问题</p><ul><li>概述<ul><li><strong>首先需要设置三个数组（与起始顶点相邻的点的最短路径长度修改为边上的权值，并修改路径前驱为起始点，</strong><br><strong>其余的都设置为最短路径长度为无穷（起始点自身的最短路径长度设置为0），路径前驱为-1）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCoRPPO.png" alt="pCoRPPO.png"></li></ul></li><li><strong>第一轮：循环遍历所有顶点，优先选择还没有确定最短路径长度并且此时的最短路径长度最小的点进行修改，</strong><br><strong>此时此点为V4，将final值设置为true。并且再进行对其它相邻点的遍历，</strong><br><strong>此时V1需要变动（最短路径长度修改为8，路径前驱修改为4，但是这个时候还不能修改其标志位）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCoRwJU.png" alt="pCoRwJU.png"></li></ul></li><li><strong>第二轮，在V4遍历完成以后，此时应该开始优先遍历第二个最短路径长度最小的顶点V3，</strong><br><strong>V3修改其标志位，在V3处可以将V2的最短路径的值修改为13，此时前驱变为V3。</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCoRfJO.png" alt="pCoRfJO.png"></li></ul></li><li><strong>第三轮，在V3遍历完成之后，选择V1进行遍历，此时修改其标志位，</strong><br><strong>并且此时可以修改V2的最短路径长度为9，并将其前驱改变为V3.</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCoRqTP.png" alt="pCoRqTP.png"></li></ul></li><li><strong>求最短路径的长度时，即为dist数组中的值，求最短路径经过的顶点序列时，根据path数组的值往前推出</strong><ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTbyAe.png" alt="pCTbyAe.png"></li></ul></li></ul></li><li>特点<ul><li><strong>时间复杂度为O(|$V^{2}$|)</strong></li><li>不适用于边上带有负权值的图</li></ul></li></ul></li></ul></li><li><p>Floyd算法求各<u><strong>顶点之间</strong></u>最短路径问题</p><ul><li>概述：使用的是动态规划的思想，通过设置中转点依次来求解，<br>此时需要两个矩阵（一个表示最短路径，另一个表示中转点）</li><li>特点<ul><li><strong>时间复杂度为O($V^{3}$)</strong></li><li>可以用于计算负权值带权图的计算，但是不适用于带有“负权回路”的图（有负权值的边组成回路），这种图有可能没有最短路径</li></ul></li><li><strong>最短路径的表中首先把存在直接联系的的路径长度写上，之后将中转点矩阵中的值均设为-1</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo4AtP.png" alt="pCo4AtP.png"></li></ul></li><li><strong>之后规定可以将V0作为中转点，按照表格依次进行遍历，需要满足两个顶点之间经过此中转点之后的路径长度小于原来的长度。此时v2到v1的路径可以修改为11，并且中转矩阵所对应的相关值修改为中转点0</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo43t0.png" alt="pCo43t0.png"></li></ul></li><li><strong>遍历完成后，之后规定可以将V1,V0作为中转点，此时可以修改v0到v2的相关值</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo4w7R.png" alt="pCo4w7R.png"></li></ul></li><li><strong>最后将v0、v1、v2均设置为中转点，此时可以将v1到v0的相关值进行修改</strong><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo4Dtx.png" alt="pCo4Dtx.png"></li></ul></li><li>代码实现<ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo4T9f.png" alt="pCo4T9f.png"></li></ul></li></ul></li><li><p>三种求最短路径的算法之间的差异</p><ul><li><img src="https://s1.ax1x.com/2023/07/17/pCo593T.png" alt="pCo593T.png"></li></ul></li></ul></li><li><p>求有向无环图描述表达式问题（DAG图，了解）</p><ul><li>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图(Directed Acyclic Graph)</li><li><p>有向无环图可以描述含有公共子式的表达式。并可将重复出现的子表达式共享，节省存储空间</p></li><li><p>解题思路</p><ul><li>首先根据规则先画好基本的有向无环图<ul><li><img src="https://s1.ax1x.com/2023/07/18/pCTGNzF.png" alt="pCTGNzF.png"></li></ul></li><li>之后逐层的合体相同的运算符（该层的运算符的两个指向边都分别对应到相同的元素就合并）<ul><li><img src="https://s1.ax1x.com/2023/07/18/pCTGWsH.png" alt="pCTGWsH.png"></li></ul></li></ul></li></ul></li><li><p>求拓扑排序问题（主要是会手算✪）</p><ul><li>AOV网 （一种有向无环图）<ul><li><strong><u>顶点</u>表示活动的网络的有向图</strong>，有向边${<V_{i},V_{j}>}$表示活动${V_{i}}$必须先于活动${V_{j}}$进行</V_{i},V_{j}></li></ul></li><li>拓扑排序：找到做事的先后顺序（<strong>同时可以判断图中是否存在回路</strong>）<ul><li>拓扑排序的特点（当且仅当满足以下的条件时）<ul><li>每个顶点出现且只出现一次</li><li>若顶点A在序列中排在顶点B的前面，则在图中不存在从J顶点B到顶点A的路径。</li></ul></li><li>拓扑排序的流程<ul><li>从AOV网中选择一个没有前驱(入度为0)的顶点并输出。</li><li>从网中删除该顶点和所有以它为起点的有向边。</li><li>重复之前的操作直到当前的AOV网为空或当前网中不存在无前驱的顶点（说明此时存在回路）为止。</li></ul></li><li>拓扑排序算法代码实现（DFS(深度优先遍历)也可以得出相应的拓扑排序序列，了解）<ul><li><strong>建立两个数组，分别表示当前顶点的入度情况以及记录生成拓扑的序列，<br>且用一个栈保存度为0的待处理顶点，也可以用队列</strong><br><strong>首先填写入度表中的各顶点的值，并将有向无序图中入度为0的点依次入栈，该图中有两个顶点0、2可依次入栈</strong><ul><li><img src="https://s1.ax1x.com/2023/07/18/pCTYbrQ.png" alt="pCTYbrQ.png"></li></ul></li><li><strong>之后首先弹出栈顶的顶点2，将拓补序列的第一号位修改为2并移动计数指针（序列的第一号即为2）</strong><br><strong>，此时将2的后继结点“3、4”的入度减一，由于此时3、4的入度还不为0，因此暂时不能入栈）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/18/pCTtZPx.png" alt="pCTtZPx.png"></li></ul></li><li><strong>按照上述过程，此时再将栈顶的顶点0弹出，此时顶点1的入度减一，作为入度为0的顶点入栈，</strong><br><strong>之后依次类推，最后的拓扑顺序为：2、0、1、3、4</strong></li><li><strong>进行如果最后的计数指针的数量等于顶点数，此时就得到了相应的拓扑排序序列，</strong><br><strong>否则说明有向无序图中存在环路，无法进行排序，不是AOV网</strong></li></ul></li><li><strong>时间复杂度：采用邻接表时为${O(|V|+|E|)}$，若采用邻接矩阵, 则需${O\left(|V|^{2}\right)}$</strong></li></ul></li><li><strong>逆拓扑排序则是以没有出度的顶点开始排序，此时可以使用DFS(深度优先遍历)的算法进行操作得出逆拓扑排序序列，</strong><br><strong>此时在顶点退栈前输出序列</strong></li><li>拓扑排序算法的相关注意事项<ul><li><strong>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</strong></li><li><strong>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一（但是也不是绝对的，如下面的例题中有经典的反例）</strong></li><li>若各个顶点已经排在一个<strong>线性有序</strong>的序列中，每个顶点有<strong>唯一的前驱后继</strong>关系，则拓扑排序的结果是唯一的<ul><li>判断：若有向无环图的拓扑序列唯一，则可以唯一确定此图（X），可举出下面的反例<ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTLOmV.png" alt="pCTLOmV.png"></li></ul></li></ul></li><li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，<br>生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵</li><li><strong>但对于一般的图来说，若其邻接矩阵是三角矩阵（不存在环），则存在拓扑序列，反之则不一定成立。</strong><ul><li>反之成立的条件是此有向图的拓扑排序序列是有序的</li></ul></li></ul></li><li>例题<ul><li>例题1：本题选D，此时可以举出一个经典的反例如下图<ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTL3i4.png" alt="pCTL3i4.png"><ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTLsWd.png" alt="pCTLsWd.png"></li></ul></li></ul></li><li>例题2：此题选D，此时不能排成一个拓扑序列说明该图中存在环，AC选项用一个三角形环就可以排除；<br>对于B选项，连通图是指需要任意两个端点之间可以互相到达的图，如果此时用一个三角形环外加从外面指向一个单独顶点的线，<br>此时该单独顶点无法到达其它顶点，故不是强连通图。只有D满足相关的情况<ul><li>若一个有向图的顶点不能排成一个拓扑序列（即存在环路），则可以判定该有向图<strong>含有</strong>顶点数大于1的强连通分量。<br>这是因为环路中的顶点构成了至少一个强连通分量，并且强连通分量中的顶点数大于1。</li><li><img src="https://s1.ax1x.com/2023/07/19/pCTO4nx.png" alt="pCTO4nx.png"></li></ul></li><li>例题3，找到拓扑排序的所有序列，用逐次列举的方法来找，不用去考虑机算方法，可以通过画圈辅助判断<ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTvBnI.png" alt="pCTvBnI.png"></li></ul></li></ul></li></ul></li><li><p>求关键路径问题（✪）</p><ul><li>AOE网概念（一种有向无环图）<ul><li>在带权有向图中, <u>以顶点表示事件</u>, <strong>以有向边表示活动</strong>，以边上的权值表示完成该活动的开销（如完成活动所需的时间），<br>称之为<strong>用边表示活动的网络</strong>,简称AOE网 (Activity On Edge NetWork)</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/18/pCTUdEj.png" alt="pCTUdEj.png"></li></ul></li></ul></li><li>AOE网的两个性质<ul><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。<br>另外，有些活动是可以并行进行的</li></ul></li><li>源点与汇点<ul><li>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；</li><li>也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li></ul></li><li>关键路径与关键活动（<strong>求关键路径是以拓扑排序为基础的</strong>）<ul><li><strong>从源点到汇点的有向路径可能有多条，所有路径中，具有<u>最大路径长度</u>的路径称为关键路径</strong></li><li><strong>关键路径上的活动称为关键活动，它是决定整个工程的关键因素</strong></li><li><strong>完成整个工程的最短时间就是关键路径的长度（关键路径上各活动花费开销的总和），</strong><br><strong>若关键活动不能按时完成，则整个工程的完成时间就会延长（在关键路径上的活动的时间延长多少，整个工程的时间也就随之延长多少）</strong></li><li><strong>可以通过加快关键活动（减少关键活动的时间）来缩短整个工程的工期。</strong><br><strong>但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</strong></li><li><strong>网络图的关键路径并不唯一，且对于有几条关键路径的网，</strong><br><strong>缩短关键路径上任意一个或多个只包括在一条关键路径的关键活动的持续时间并不能缩短关键路径的长度，</strong><br><strong>需要缩短那些包括在<u>所有</u>关键路径上的关键活动的持续时间才能缩短关键路径的长度。</strong><ul><li>关于缩短关键路径长度的例题<ul><li>例题1，本题选择C，对于关键路径长度来说，增加是可以增大关键路径长度的，<br>但是缩短需要在一定的条件下才能缩短关键路径长度<ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTomM8.png" alt="pCTomM8.png"></li></ul></li><li>例题2，本题选择C，该题的关键路径经过计算得出为：b,d,c,g；b,d,e,h；b,f,h。<br>此时只有C选项的f与d可以同时作用到三条关键路径上，其它的选项只能作用到其中的一条或两条。<ul><li><img src="https://s1.ax1x.com/2023/07/19/pCTonsS.png" alt="pCTonsS.png"></li></ul></li></ul></li></ul></li></ul></li><li>求关键路径与关键活动以及相关的参数（<strong>求关键路径同时也可以判断图中是否存在回路</strong>）<ul><li>注意区别事件(顶点)的最早/最迟开始时间与活动(弧)的最早/最迟开始时间。<ul><li>时间余量=下一个顶点的最迟开始时间-活动持续时间—起始顶点的最早开始时间</li><li>顶点（事件）的最迟开始时间等于=起始顶点的最早开始时间+时间余量</li><li>弧（活动）的最早开始时间等于：弧的起始顶点的最早开始时间</li><li>弧（活动）的最迟开始时间等于：下一个顶点的最迟发生时间—该活动的持续时间</li></ul></li><li><img src="https://s1.ax1x.com/2023/07/19/pCTHwdg.jpg" alt="pCTHwdg.jpg"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第六章-图&quot;&gt;&lt;a href=&quot;#数据结构第六章-图&quot; class=&quot;headerlink&quot; title=&quot;数据结构第六章 图&quot;&gt;&lt;/a&gt;数据结构第六章 图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第六章图的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第五章-树与二叉树</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-08-11T14:18:28.000Z</published>
    <updated>2024-08-11T14:37:25.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h2><blockquote><p>计算机学科基础：数据结构第五章树与二叉树学习笔记</p></blockquote><span id="more"></span><h3 id="1-树的基本概念（✠）"><a href="#1-树的基本概念（✠）" class="headerlink" title="1.树的基本概念（✠）"></a>1.树的基本概念（✠）</h3><ul><li><p>①树的定义：</p><ul><li>树是n(n≥0)个结点的有限集，是一种递归定义的数据结构。当n=0时，称为空树。</li><li>在任意一棵非空树中应满足<ul><li>有且仅有一个特定的称为根的结点。</li><li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2……Tm<br>其中每个集合本身又是一棵树，并且称为根的子树。</li></ul></li></ul></li><li><p>②树的基本术语</p><ul><li>结点的关系图谱：祖先、子孙、双亲（父节点）（根结点是唯一没有双亲的结点）<br>孩子、兄弟（有相同双亲的结点）、堂兄弟（同一层非同父节点）</li><li>路径和路径长度。<ul><li>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数；</li><li>树的路径长度是从树根到每个结点的路径长度的<u>总和</u>（路径只能是由上往下的，同一层之间不存在路径）</li></ul></li><li>结点的深度、层次（从上往下数）；结点的高度（从下往上数）；树的高度（或深度）是树中结点的最大层数</li><li>度：<strong>一个结点的孩子个数</strong>；<br>树的度：树中结点的最大度数<ul><li>如度为4的树：存在某结点至少有4个孩子结点（而不是至少在某一层正好有4个结点）</li><li>度大于0：分支节点（每个结点的分支数就是该结点的度）</li><li>度等于0：叶子节点</li></ul></li><li>有序树与无序树（从左到右有无次序）</li><li>森林：森林是m(m≥0)棵互不相交的树的集合</li></ul></li><li>③树的性质（选择题考点✪）<ul><li>树的结点数=总度数+1（总度数也等于分支数）<ul><li>例，此题选B，由总度数+1=结点数，叶子结点个数=总度数-其它非叶子结点的结点个数<ul><li><img src="https://s1.ax1x.com/2023/07/11/pCWf6u6.png" alt="pCWf6u6.png"></li></ul></li></ul></li><li>区分度为m的树和m叉树<ul><li><img src="https://s1.ax1x.com/2023/07/11/pCWcsPI.png" alt="pCWcsPI.png"></li></ul></li><li>度为m的树第i层最多有$m^{i-1}$个结点(i≥1)；m叉树第i层最多有$m^{i-1}$个结点 (i≥1)</li><li>高度为h的m叉树最多有$\frac{m^{h}-1}{m-1}$个结点（由等比数列求和公式得）</li><li>高度为h的m叉树最少有h个结点；高度为h，度为m的树最少有h+m-1个结点<ul><li>此时也可以反过来说，度为m，结点数为n的树，高度最多为n-m+1</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/11/pCW2f4s.png" alt="pCW2f4s.png"></li></ul></li></ul></li><li>具有n个结点的m叉树（或度为m）的最小高度为    $\left\lceil\log _{m}(n(m-1)+1)\right\rceil$<ul><li><img src="https://s1.ax1x.com/2023/07/11/pCWR9KK.png" alt="pCWR9KK.png"></li></ul></li></ul></li></ul><h3 id="2-二叉树（✪）"><a href="#2-二叉树（✪）" class="headerlink" title="2.二叉树（✪）"></a>2.二叉树（✪）</h3><ul><li><p>①二叉树的定义</p><ul><li>二叉树是n(n≥0)个结点的有限集合，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）</li><li>或者为空二叉树，即n=0</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。<br>左子树和右子树又分别是一棵二叉树（二叉树是有序树，左右次序不能颠倒）</li></ul></li><li><p>②特殊的二叉树</p><ul><li>满二叉树<ul><li>一棵高度为h，且含有$2^{h}-1$个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点</li><li>满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2，不存在度为1的结点</li><li>按层序从1开始编号，结点ⅰ的左孩子为2i，右孩子为2i+1，结点i的父节点 ⌊i/2⌋（如果有的话）</li></ul></li><li>完全二叉树<ul><li>高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</li><li>若i ≤ ⌊n/2⌋，则结点i为分支结点，否则为叶结点。</li><li><strong>若一棵完全二叉树中的结点无左孩子，则其必是叶节点</strong></li><li>叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排列在该层最左边的位置上。</li><li>若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li><li>按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点。</li><li>若结点数n为奇数，则每个分支结点都有左孩子和右孩子；</li><li>若n为偶数，则编号最大的分支结点(编号为n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/11/pCfAsD1.png" alt="pCfAsD1.png"></li></ul></li></ul></li><li>二叉排序树<ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上的所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又各是一棵二叉排序树。</li><li><strong>将二叉排序树的<u>先序序列</u>中的关键字依次插入初始为空的树中，所得到的二叉排序树与原二叉排序树是相同的</strong></li></ul></li><li>平衡二叉树：树上任意一个结点的左子树和右子树的深度之差不超过1。<ul><li><strong>对于高度为n的平衡二叉树，最少需h(n)个结点，最多需要2n-1个结点。</strong></li><li><strong>h(n)=h(n-1)+h(n-2)+1</strong></li><li><strong>h(0)=0，h(1)=1，h(2)=2</strong></li></ul></li></ul></li><li><p>③二叉树的性质（选择题考点♚）</p><ul><li><strong>非空二叉树上的叶结点数等于度为2的结点数加1，即$n_{0}=n_{2}+1$</strong><ul><li>可由$n=n_{0}+n_{1}+n_{2}$与$n=n_{1}+2n_{2}+1$得来</li></ul></li><li><strong>二叉树第i层上至多有$2^{i-1}$个结点(i≥1)</strong></li><li><strong>高度为h的二叉树至多有$2^{h}-1$个结点（满二叉树），最少有$2^{h-1}$个结点</strong></li><li><strong>具有n个${(n&gt;0)}$ 结点的完全二叉树的高度h为${\left\lceil\log _{2}(n+1)\right\rceil}$ 或 $\left\lfloor\log _{2} n\right\rfloor+1$</strong><ul><li><img src="https://s1.ax1x.com/2023/07/12/pCfVgpD.png" alt="pCfVgpD.png"></li></ul></li><li><strong>第i个结点所在层次为${\left\lceil\log _{2}(n+1)\right\rceil}$ 或 $\left\lfloor\log _{2} n\right\rfloor+1$</strong></li><li>对于<strong>完全二叉树</strong>，可以由节点数推出各类结点的数量情况，分为结点总数n为奇数或偶数<ul><li>完全二叉树的度为1的结点数量最多为1，$n_{1}=1或0$</li><li>当n=2k时，此时$n_{1}=1,n_{0}=k,n_{2}=k+1$ <strong>（完全二叉树有偶数个结点时，叶子结点的个数为总结点数除以2）</strong></li><li>当n=2k-1时，此时$n_{1}=0,n_{0}=k,n_{2}=k+1$<strong>（有奇数个结点时，叶子结点的个数为总结点数+1再除以2）</strong></li><li>完全二叉树如果所有的非空结点都有两个子节点，说明其有奇数个结点，此时结点总数=2*叶子节点总数-1</li></ul></li><li>有关性质例题的考察<ul><li>例题1：这种题通过画出二叉树的情况来找规律即可，选B<ul><li><img src="https://s1.ax1x.com/2023/07/12/pCfxZ9I.png" alt="pCfxZ9I.png"></li></ul></li><li>例题2：给出完全二叉树具体一层的叶结点数量，求最多和最少得结点总数<br>（重要信息：完全二叉树的叶结点只有可能存在于最后一层和倒数第二层）<ul><li>结点数量最少时，该层即为最后一层，如此题为前五层满二叉树+8=39，</li><li>结点数量最多时，该层为倒数第二层，如此题为总七层-8*2=111</li><li><img src="https://s1.ax1x.com/2023/07/12/pCfzZa4.png" alt="pCfzZa4.png"></li></ul></li><li>例题3：最小高度往往是满二叉树时，存放该二叉树至少需要的结点数量（最坏的情况，也为满二叉树时）分别选C、A<ul><li><img src="https://s1.ax1x.com/2023/07/12/pChSuTg.png" alt="pChSuTg.png"></li><li><a href="https://imgse.com/i/pChSmm8"><img src="https://s1.ax1x.com/2023/07/12/pChSmm8.png" alt="pChSmm8.png"></a></li></ul></li></ul></li></ul></li><li><p>④二叉树的存储结构</p><ul><li><p>二叉树的顺序存储</p><ul><li><p>对于完全二叉树，顺序存储的结构较为合适，此时可以较好的反映出结点之间的逻辑关系，也能节省存储空间</p><ul><li><a href="https://imgse.com/i/pCfHGVI"><img src="https://s1.ax1x.com/2023/07/12/pCfHGVI.png" alt="pCfHGVI.png"></a></li></ul></li><li><p>对于一般的二叉树，需要用0来表示并不存在的空结点，以便于反映二叉树的逻辑结构，但是此时会浪费较多的存储空间</p><ul><li><img src="https://s1.ax1x.com/2023/07/12/pCfHYIP.png" alt="pCfHYIP.png"></li></ul></li></ul></li><li><p>二叉树的链式存储</p><ul><li><p>又称为<strong>二叉链表</strong>，由数据域，左指针域，右指针域组成</p></li><li><p><strong>n个结点的二叉链表共有n+1个空链域，有n-1个非空链域</strong><br>链域是指左指针或右指针</p></li><li><p>关于三叉链表：再定义一个父指针指向父节点，方便查找（在后序线索树中可找到后序后继结点）</p></li><li><p>链式存储的代码实现</p><ul><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree</span><br></pre></td></tr></table></figure></li><li><p>初始化以及插入节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BiTree root=<span class="literal">NULL</span>; <span class="comment">//定义一颗空树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data=<span class="number">1</span>;</span><br><span class="line">root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchlid=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data=<span class="number">2</span>;</span><br><span class="line">p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild=p; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="3-二叉树的遍历（✪）"><a href="#3-二叉树的遍历（✪）" class="headerlink" title="3.二叉树的遍历（✪）"></a>3.二叉树的遍历（✪）</h3><ul><li><p>三种基本遍历</p><ul><li><p>如中序遍历，先递归遍历左子树，再访问根节点，再递归遍历右子树，二叉树为空则什么都不做。</p></li><li><p>这三种遍历方法的时间复杂度都是O(n)，每个结点都会被访问一次</p></li><li><p><strong>二叉树的前中后序遍历中，所有叶节点的顺序完全相同</strong></p></li><li><p><strong>若一个二叉树的先序和后序序列正好相反，则该二叉树的高度等于结点数，只有一个叶节点</strong></p></li><li><p>先序序列与中序序列的关系相当于，以先序序列为入栈次序，以中序队列为出栈次序</p></li><li><p>先序序列为a,b,c,d，求不同二叉树的个数（使用卡特兰数的公式$\frac{1}{n+1}C^{n}_{2n}$）</p></li><li><p>可用递归子树思想的方法来求出遍历次序</p><ul><li><img src="https://s1.ax1x.com/2023/07/12/pChpkEF.png" alt="pChpkEF.png"></li></ul></li></ul></li><li><p>先序遍历（NLR，根左右）<br>在前序遍历的二叉树中，任何结点的子树的所有结点都是直接跟在该结点的之后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     visit(T);</span><br><span class="line">     preOrder(T-&gt;lchild);</span><br><span class="line">     preOrder(T-&gt;rchild);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历（LNR，左根右）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     InOrder(T-&gt;lchild);</span><br><span class="line">     visit(T);</span><br><span class="line">     InOrder(T-&gt;rchild);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历（LRN，左右根，可找到从子孙到祖先的路径）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     PostOrder(T-&gt;lchild);</span><br><span class="line">     PostOrder(T-&gt;rchild);</span><br><span class="line">     visit(T);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求树的深度</p><ul><li><img src="https://s1.ax1x.com/2023/07/12/pCh9ydO.png" alt="pCh9ydO.png"></li></ul></li><li><p>层次遍历二叉树</p><ul><li><img src="https://s1.ax1x.com/2023/07/13/pChf03j.png" alt="pChf03j.png"></li></ul></li><li><p>由遍历构造二叉树</p><ul><li>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树，需要和中序遍历组合才行</li><li>前序加中序确定二叉树结构<ul><li>以前序序列的第一个单位为准，在中序遍历中确定其左右子树，之后的子树的根节点都以前序遍历靠前的元素为准</li><li><img src="https://s1.ax1x.com/2023/07/13/pCh7prj.png" alt="pCh7prj.png"></li></ul></li><li>后序加中序确定二叉树结构<ul><li>以后序遍历的最后一个元素为准，在中序遍历中确定其左右子树，之后的子树的根节点都以后序遍历靠后的元素为准</li><li><img src="https://s1.ax1x.com/2023/07/13/pCh7iaq.png" alt="pCh7iaq.png"></li></ul></li><li>层序加中序确定二叉树结构<ul><li><img src="https://s1.ax1x.com/2023/07/13/pChHXjg.png" alt="pChHXjg.png"></li></ul></li></ul></li></ul><h3 id="4-线索二叉树（选择题考点，代码无需掌握✪）"><a href="#4-线索二叉树（选择题考点，代码无需掌握✪）" class="headerlink" title="4.线索二叉树（选择题考点，代码无需掌握✪）"></a>4.线索二叉树（选择题考点，代码无需掌握✪）</h3><ul><li><p>作用：方便从一个结点出发，找到其前驱、后继，<br>此时先序线索二叉树和中序线索二叉树进行遍历时不需要栈的支持（进行）递归，但是后序线索二叉树仍需要栈的支持</p><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4wIUI.png" alt="pC4wIUI.png"></li></ul></li><li><p><strong>线索：指向前驱和后继的指针，n个结点的二叉树含有n+1个空指针</strong><br><strong>n个结点的线索二叉树含有n+1个线索</strong></p></li><li><p><strong>二叉树的线索化就是将二叉链表中的空指针改为指向前驱或后驱的线索</strong><br><strong>按照遍历的顺序进行，如果指针已经指向相应结点则不变动，如果没有空指针就跳过）</strong></p></li><li><p>存储结构</p><ul><li>在普通二叉树结点的基础上，增加标志位：Itag和rtag （等于0此结点有孩子，等于1此结点被线索化）</li><li>ltag\==1时，表示Ichild指向前驱；Itag\==0时，表示Ichild指向左孩子</li><li>rtag\==1时，表示rchild指向后继；rtag\==0时，表示rchild指向右孩子</li></ul></li><li><p>线索化二叉树（代码了解即可）</p><ul><li><p>线索二叉树的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;  <span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure></li><li><p>中序线索化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>; <span class="comment">//设定当前访问结点的前驱，并初始化</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  <span class="comment">//线索化非空二叉树</span></span><br><span class="line">        InThread(T,pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>; <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>; <span class="comment">//改变其标志符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre); <span class="comment">//递归，线索化左子树（按照中序遍历，先遍历左子树）</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;  <span class="comment">//若当前结点左子树为空时，建立前驱线索,左指针指向前驱</span></span><br><span class="line">            P-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p; <span class="comment">//建立前驱节点的后继线索</span></span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p; <span class="comment">//完成以上操作之后，将前驱结点指向当前所遍历到的结点</span></span><br><span class="line">        InThread(p-&gt;rchild,pre); <span class="comment">//递归线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于先序线索化而言只需要将其线索化左子树的操作写在前面，中间是根结点的操作，最后是线索化右子树的操作</p><ul><li>注：此时在ltag==0时，才能对左子树先序线索化</li></ul></li><li><p>对于后序线索化而言只需要将其线索化左子树的操作写在前面，中间是线索化右子树的操作，最后是根结点的操作</p></li></ul></li><li><p>线索二叉树的遍历（会推出各种遍历序列即可✪）</p><ul><li><p>中序线索二叉树的遍历</p><ul><li><p>进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。</p></li><li><p>首先找到中序线索二叉树的第一个结点 （最左下的结点，不一定为叶节点）</p><ul><li><p>代码实现（求中序线索二叉树中中序序列下的第一个结点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;lchild; (遍历找到最左下的结点，不一定是叶结点)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>之后找中序后继结点</p><ul><li><p>若此时p-&gt;rtag==1,则next=p-&gt;rchild （此时右链为线索，指向其后继）</p></li><li><p><strong>p-&gt;ratg==0时，此时右子树不为空，则遍历右子树的第一个访问结点（右子树最左下的结点为其后继）</strong></p></li><li><p>代码实现（求中序线索二叉树中结点p在中序序列下的后继）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode *<span class="title function_">Nexttnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild); <span class="comment">//不为空，找到其右子树的最左下角的结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//右标志为1直接返回线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>遍历中序二叉树的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line">visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序线索二叉树找到中序前驱</p><ul><li>若此时p-&gt;ltag==1，此时直接返回左线索</li><li>若此时p-&gt;ltag==0，则p结点的左子树中，最右下角的结点就是其前驱结点</li><li><img src="https://s1.ax1x.com/2023/07/14/pC4dIpT.png" alt="pC4dIpT.png"></li></ul></li></ul></li><li><p>先序线索二叉树的遍历</p><ul><li><p>先序线索二叉树的先序后继</p><ul><li>若右标志位为0时，首先看先序线索二叉树有无左孩子，如果有的话，就是其先序后继，如果只有右孩子没有左孩子，那么右孩子为其先序后继</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4wFHA.png" alt="pC4wFHA.png"></li></ul></li></ul></li><li><p>先序线索二叉树不能在左标志位为0的情况下找到先序前驱</p></li></ul></li><li><p>后序线索二叉树的遍历</p><ul><li><p>后序线索二叉树找后序前驱</p><ul><li>若左标志位为0时，此时如果其有右孩子，那么此右孩子为其后序前驱，如果只有左孩子没有右孩子，那么左孩子为其后序前驱</li><li><img src="https://s1.ax1x.com/2023/07/14/pC4wqxS.png" alt="pC4wqxS.png"></li></ul></li><li><p>后序线索二叉树找后序后继</p><ul><li>如果此时右标志位为0，则不能有效的找到后序后继</li><li>此时可以用三叉链表来找到其后序后继<ul><li><img src="https://s1.ax1x.com/2023/07/14/pC40yZj.png" alt="pC40yZj.png"></li></ul></li></ul></li></ul></li><li><p>三种线索二叉树遍历的总结</p><ul><li>对于中序线索二叉树来说可从任意结点进行遍历和逆向遍历；对于前序线索二叉树来说，只可进行顺向遍历；对于后序线索二叉树来说，只可进行逆向遍历</li><li><img src="https://s1.ax1x.com/2023/07/14/pC402iq.png" alt="pC402iq.png"></li></ul></li></ul></li></ul><h3 id="5-树、森林（✪）"><a href="#5-树、森林（✪）" class="headerlink" title="5.树、森林（✪）"></a>5.树、森林（✪）</h3><ul><li><p>树的存储结构（✪）</p><ul><li><p>双亲表示法（顺序存储✪）</p><ul><li><p>这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。<br>根结点下标为0，其伪指针域为-1。</p></li><li><p>特点：该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，<br>但求结点的孩子时则需要遍历整个结构。</p></li><li><p>适用于找父节点较多找孩子结点较少的树，如并查集</p></li><li><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">//树中最多的结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE]; <span class="comment">//双亲表示法</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC45BlQ.png" alt="pC45BlQ.png"></li></ul></li></ul></li><li><p>孩子表示法（顺序存储+链式存储）</p><ul><li><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表<br>叶结点的孩子链表为空表</p></li><li><p>用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针</p></li><li><p>特点：这种存储结构寻找子女的操作非常直接，而寻找双亲的操作需要遍历个结点中孩子链表指针域所指向的n个孩子链表，适用于服务流程树。</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child; <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r; <span class="comment">//结点数与根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC45OfO.png" alt="pC45OfO.png"></li></ul></li></ul></li><li><p>孩子兄弟表示法（链式存储✪）</p><ul><li><p>又称为二叉树表示法，即以二叉链表作为树的存储结构，<br>包括结点值，<strong>指向结点第一个孩子的结点指针，以及指向结点下一个兄弟结点的指针</strong></p></li><li><p>特点：易于查找孩子，但是不易于查找双亲，可以方便实现树转换成二叉树的操作。</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4qwEd.png" alt="pC4qwEd.png"></li></ul></li></ul></li></ul></li><li><p>树、森林与二叉树的转换（会画✪）</p><ul><li>树转换为二叉树：<strong>转换后的二叉树一定没有右子树</strong><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4LLSP.png" alt="pC4LLSP.png"></li></ul></li><li>森林转换为二叉树<ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4Lxeg.png" alt="pC4Lxeg.png"></li></ul></li><li>二叉树转换为树<ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4OJmD.png" alt="pC4OJmD.png"></li></ul></li><li>二叉树转换成森林<ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4OB1P.png" alt="pC4OB1P.png"></li></ul></li></ul></li><li><p>树和森林的遍历（✪）</p><ul><li>树的遍历<ul><li>先根遍历<strong>（等同于对相应二叉树的先序遍历）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4j9x0.png" alt="pC4j9x0.png"></li></ul></li><li>后根遍历<strong>（等同于对相应二叉树的中序遍历）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4jirT.png" alt="pC4jirT.png"></li></ul></li><li>层序遍历<ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4jFqU.png" alt="pC4jFqU.png"></li></ul></li></ul></li><li>森林的遍历<ul><li>先序遍历<strong>（等同于对所对应的二叉树依次进行先序遍历）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4jdQP.png" alt="pC4jdQP.png"></li></ul></li><li>中序遍历<strong>（等同于对所对应的二叉树依次进行中序遍历）</strong><ul><li><img src="https://s1.ax1x.com/2023/07/14/pC4jwsf.png" alt="pC4jwsf.png"></li></ul></li></ul></li></ul></li></ul><h3 id="6-树与二叉树的应用（✪）"><a href="#6-树与二叉树的应用（✪）" class="headerlink" title="6.树与二叉树的应用（✪）"></a>6.树与二叉树的应用（✪）</h3><ul><li><p>哈夫曼树和哈夫曼编码</p><ul><li>带权路径长度：从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度。<br>树中所有叶结点的带权路径长度之和称为该树的带权路径长度（WPL）。</li><li>哈夫曼树<ul><li>在含有个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树</li><li>哈夫曼树的构造<ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/15/pC5gv7T.png" alt="pC5gv7T.png"></li></ul></li><li>注：如果之后的两个单独的叶子结点的构造出的权值比它于树的根构造出的权值更小，那么两个叶子结点先自行构造<ul><li>如此题选C，此时9和12先进行自行的构造<img src="https://s1.ax1x.com/2023/07/16/pCIAbGV.png" alt="pCIAbGV.png"></li></ul></li></ul></li><li>特点<ul><li><strong>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</strong></li><li><strong>构建过程中共创建了n-1个新结点（非叶结点），哈夫曼树的结点总数为2n-1</strong><ul><li>如此题：度为m,此时若含有n个叶子结点，则总的需要处理的结点数为n-1个，此时每次将处理m-1个，因此非叶子结点的数量为$\frac{n-1}{m-1}$<img src="https://s1.ax1x.com/2023/07/16/pCIVe6U.png" alt="pCIVe6U.png"></li></ul></li><li><strong>哈夫曼树中不存在度为1的结点。</strong></li><li><strong>哈夫曼树并不唯一，但WPL必然相同且为最优</strong></li></ul></li></ul></li><li>哈夫曼编码（一种被广泛应用而且非常有效的数据压缩编码）<ul><li>固定长度编码与可变长度编码<ul><li>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。</li><li>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。</li><li>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</li></ul></li><li>前缀编码：若没有一个编码是另一个编码的前缀，则成为前缀编码，此时将不会产生歧义<ul><li>采用的前一位数的编码将会影响后一位数的编码<ul><li>例题<img src="https://s1.ax1x.com/2023/07/16/pCIAfKg.png" alt="pCIAfKg.png"></li><li><img src="https://s1.ax1x.com/2023/07/16/pCIA4bj.png" alt="pCIA4bj.png"></li></ul></li></ul></li><li>通过哈夫曼编码可以构造哈夫曼树，此时最大编码长度为树的带权路径长度（WPL），并且可以算出压缩的数据率<ul><li><img src="https://s1.ax1x.com/2023/07/15/pC52mND.png" alt="pC52mND.png"></li></ul></li></ul></li></ul></li><li><p>并查集（集合逻辑结构）</p><ul><li><p>集合的表示：要将元素划分为互不相交的子集。可以用互不相交的树，来表示多个集合</p></li><li><p>存储结构：使用双亲表示法，双亲指针指向其父节点的序号</p><ul><li><img src="https://s1.ax1x.com/2023/07/15/pC570F1.png" alt="pC570F1.png"></li></ul></li><li><p>基本操作</p><ul><li><p>初始化：将所有元素初始化为-1。</p><ul><li><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE]; <span class="comment">//双亲指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span>; <span class="comment">//初始化时，数组指针设置为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查操作（时间复杂度为 O(n)）</p><ul><li><p>如何查到某个元素属于哪个集合：可以通过树的根结点来判断</p></li><li><p>如何判断两个元素之间的关系：通过对比各自所在的树的根结点来判断</p></li><li><p>代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)<span class="comment">//循环寻找x的根（一般设置为-1）</span></span><br><span class="line">        x=S[x]; </span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//此时找到x的根，返回之</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>并操作（时间复杂度为 O(1)，并操作n个独立元素为一个集合则需要O($n^{2}$)）</p><ul><li><p>让一棵树成为另一棵树的子树即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> ROOt2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>; <span class="comment">//此时要求两个是不同的集合</span></span><br><span class="line">    S[Root2]=Root1; <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>对并查集的并操作作优化</p><ul><li>此时将根结点的值设置为负数（表示其树的结点的总数，有利于将较小的树合并到更大的树，可以控制高度不变）</li><li>当合并时，小树的双亲指针变为大树的数组下标，此时大树的指针需要累加结点总数</li><li>进行优化之后，查操作的时间复杂度可变为：$O ( \log _ { 2 } n )$</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/07/15/pC5HUc8.png" alt="pC5HUc8.png"></li></ul></li></ul></li><li><p>对并查集的进一步优化（优化查操作）</p><ul><li><img src="https://s1.ax1x.com/2023/07/15/pC5bn5n.png" alt="pC5bn5n.png"></li></ul></li><li><p>并查集的优化后的时间复杂度的变化</p><ul><li><img src="https://s1.ax1x.com/2023/07/15/pC5bQ2V.png" alt="pC5bQ2V.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第五章-树与二叉树&quot;&gt;&lt;a href=&quot;#第五章-树与二叉树&quot; class=&quot;headerlink&quot; title=&quot;第五章 树与二叉树&quot;&gt;&lt;/a&gt;第五章 树与二叉树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第五章树与二叉树学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第四章-串</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/</id>
    <published>2024-08-11T14:14:28.000Z</published>
    <updated>2024-08-11T14:17:41.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第四章-串"><a href="#数据结构第四章-串" class="headerlink" title="数据结构第四章-串"></a>数据结构第四章-串</h2><blockquote><p>计算机学科基础：数据结构第四章串的学习笔记</p></blockquote><span id="more"></span><h3 id="1-串的定义（特殊的线性表，了解）"><a href="#1-串的定义（特殊的线性表，了解）" class="headerlink" title="1.串的定义（特殊的线性表，了解）"></a>1.串的定义（特殊的线性表，了解）</h3><ul><li>定义：串是由零个或多个字符组成的有限序列（串的数据对象限定为字符集）</li><li>串中字符的个数n称为串的长度。n=0时的串称为空串</li><li>串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。（以子串作为操作对象）</li><li>某个字符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。</li><li>两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。</li></ul><h3 id="2-串的模式匹配（串的定位操作✪）"><a href="#2-串的模式匹配（串的定位操作✪）" class="headerlink" title="2.串的模式匹配（串的定位操作✪）"></a>2.串的模式匹配（串的定位操作✪）</h3><ul><li><p>子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。</p></li><li><p>KMP算法（选择题考点✪）</p><ul><li><p>每次匹配失败之后，无需回溯主串指针，根据next数组的对应关系来决定当前的模式串的指针设置<br>next数组只与模式串有关，与主串无关</p></li><li><p>利用next数组控制指针回溯的举例</p><ul><li>此时在第五个元素匹配失败之后，只需要将模式串指针移动到2位置继续与主串的5位置比较<ul><li><img src="https://s1.ax1x.com/2023/07/11/pCW1ak9.png" alt="pCW1ak9.png"></li></ul></li><li>移动之后的情况如下<ul><li><img src="https://s1.ax1x.com/2023/08/04/pPFsrZR.png" alt="pPFsrZR.png"></li></ul></li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]; <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时间复杂度：O(m+n)</p></li></ul></li><li><p>求next数组（选择题考点，手算方法♚）</p><ul><li>next[j]的含义是在子串的第j个字符与主串发生失配时，则跳到子串的next[j]位置重新与主串当前位置进行比较</li><li>求解方法：<ul><li>首先1号2号位分别固定是0和1</li><li>若要比较第n位，在上方写出比较字符，只写出其中n-1位前的值（如比较第3位则只需要写出前2位）<br>下方平行地写出模式串完整字符</li><li>此时在比较字符的第n位之前画一个竖线，开始进行比较，在下方的模式串进行后移</li><li>当后移到某一位时，模式串能与上方的比较字符完全匹配时，此时记录当前的模式串位数为next数组中对应位的值<br>如果模式串已经全部后移出竖线右侧，说明此时next数组的值为1</li></ul></li><li>完全匹配的展示<ul><li><img src="https://s1.ax1x.com/2023/08/04/pPFcaz8.png" alt="pPFcaz8.png"></li></ul></li><li>例：比较第4位的情况<ul><li>此时画到第四位之前，将模式串逐步后移检查，此时会后移两位才能完全匹配<ul><li><img src="https://s1.ax1x.com/2023/08/04/pPFcmPx.png" alt="pPFcmPx.png"></li></ul></li><li>后移到模式串的第一位a时，此时与上方的比较字符的a匹配，此时为第2位，记录在next数组中的序号4位置<ul><li><img src="https://s1.ax1x.com/2023/08/04/pPFctit.png" alt="pPFctit.png"></li></ul></li></ul></li></ul></li><li><p>对KMP算法的进一步优化（将next数组转变成nextval数组）</p><ul><li><p>nextval数组概述</p><ul><li>首先需要先把模式串的next数组算出来，初始的nextval数组可以确定第一个序号的值为0</li><li>此时从前往后（序号2开始）依次观察每个序号对应的next的值所对应的序号的模式串<br>如下方的序号2的next数组的值为1，1的序号下的模式串为a</li><li><p>若其next数组所对应的序号的模式串的与当前序号的模式串相同，<br>此时新建立的nextval的值改为其next数组所对应序号的nextval数组的值（2的nextval改为0）<br>否则与原来的next数组的值一致</p></li><li><p>转换流程（依次转换）</p><ul><li><img src="https://s1.ax1x.com/2023/07/11/pCWaD1J.png" alt="pCWaD1J.png"></li></ul></li></ul></li><li><p>注意：比较字符相同后，赋值是赋予nextval数组的值，而非原数组的值，如下题选C</p><ul><li><img src="https://s1.ax1x.com/2023/07/11/pCWBegg.png" alt="pCWBegg.png"></li></ul></li><li><p>如果next数组最初的指针是从-1开始，则第一第二序号赋值为-1,0，之后的序号的指针起始位是0，如下题选C；</p><ul><li><img src="https://s1.ax1x.com/2023/07/11/pCWBkUP.png" alt="pCWBkUP.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第四章-串&quot;&gt;&lt;a href=&quot;#数据结构第四章-串&quot; class=&quot;headerlink&quot; title=&quot;数据结构第四章-串&quot;&gt;&lt;/a&gt;数据结构第四章-串&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第四章串的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第三章-栈,队列和数组</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88-%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88-%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2024-08-11T13:50:54.000Z</published>
    <updated>2024-08-11T14:12:53.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第三章-栈，队列和数组"><a href="#数据结构第三章-栈，队列和数组" class="headerlink" title="数据结构第三章-栈，队列和数组"></a>数据结构第三章-栈，队列和数组</h2><blockquote><p>计算机学科基础：第三章栈，队列和数组的学习笔记</p></blockquote><span id="more"></span><h3 id="1-栈（✪）"><a href="#1-栈（✪）" class="headerlink" title="1.栈（✪）"></a>1.栈（✪）</h3><h4 id="栈的基本概念（操作受限的线性表）"><a href="#栈的基本概念（操作受限的线性表）" class="headerlink" title="栈的基本概念（操作受限的线性表）"></a>栈的基本概念（操作受限的线性表）</h4><ul><li>栈的定义：只允许在一端进行插入或删除操作的线性表</li><li>栈顶是允许进行插入删除操作的那一端</li><li>栈的特点：后进先出</li><li>卡特兰数：n个不同元素进栈，出栈元素的不同排列的个数为： $(\frac{1}{n+1})*C_{2n}^n$</li><li><strong>无论是顺序栈还是链栈，出入栈的时间复杂度都为O(1)</strong></li></ul><h4 id="顺序栈（✪）"><a href="#顺序栈（✪）" class="headerlink" title="顺序栈（✪）"></a>顺序栈（✪）</h4><ul><li><p>概念：采用顺序存储的栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，<br>同时附设一个指针(top)指示当前栈顶元素的位置。</p></li><li><p>指针的变化（具体问题具体分析）</p><ul><li>指针的设置：S.top，初始时设置S.top=-1，栈顶元素：S.data[S.top]</li><li>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素</li><li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1</li><li>栈空条件：栈空条件：S.top\==-1</li><li>栈满条件：S.top==MaxSize-1；栈长：S.top+1</li></ul></li><li><p>代码表示</p><ul><li><p>顺序栈的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈顶指针，指示当前栈顶元素的位置 </span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></li><li><p>顺序栈的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span><span class="comment">//初始化 </span></span><br><span class="line">&#123; </span><br><span class="line">S.top=<span class="number">-1</span>; <span class="comment">//初始化栈顶指针 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>顺序栈的判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Sqstack S)</span><span class="comment">//判空 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>顺序栈的进栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span><span class="comment">//进栈 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">S.data[++S.top]=x; <span class="comment">//此处表示当栈不满时，先加栈顶指针，再执行进栈操作 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>顺序栈的出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span><span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x=S.data[S.top--];<span class="comment">//此时表示当栈不为空时，先将指针处元素赋予x,再将栈顶指针减一，执行出栈操作 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>读取栈顶的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTOP</span><span class="params">(SqStack S,<span class="type">int</span> &amp;x)</span><span class="comment">//读栈顶元素 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x=S.data[S.top];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，</li><li>则入栈操作变为S.data[S.top++]=x；</li><li>出栈操作变为x=S.data[—S,top]；</li></ul></li></ul></li><li><p>关于共享栈（非重点）</p><ul><li>共享栈的定义：利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，<br>将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/29/pCw87Cj.png" alt="pCw87Cj.png"></li></ul></li><li>共享栈的栈顶指针<ul><li>两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；</li><li>仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满</li></ul></li><li>共享栈的出入栈操作：当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反。</li><li>共享栈的特点：共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，<br>只有在整个存储空间被占满时才发生上溢，对存取效率没有影响</li></ul></li></ul><h4 id="链式栈（✠）"><a href="#链式栈（✠）" class="headerlink" title="链式栈（✠）"></a>链式栈（✠）</h4><ul><li><p>链栈的定义：链栈一般由单链表来实现，不带头节点，并规定所有的操作都在表头来进行（相当于栈顶），头指针指向栈顶元素。</p></li><li><p>链栈的优点：链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/04/24/p9nMLBF.jpg" alt="p9nMLBF.jpg"></li></ul></li><li><p>代码实现</p><ul><li><p>链栈的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span><span class="comment">//指针域 </span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure></li><li><p>链栈的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;S)</span><span class="comment">//初始化链栈 </span></span><br><span class="line">&#123;</span><br><span class="line"> S=<span class="literal">NULL</span>;<span class="comment">//头指针为空</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>链栈的入栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LiStack &amp;S,<span class="type">int</span> x)</span><span class="comment">//入栈操作 </span></span><br><span class="line">&#123;</span><br><span class="line">  Linknode *p=(Linknode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linknode));<span class="comment">//分配了一个结点的空间 </span></span><br><span class="line">  p-&gt;data=x;</span><br><span class="line">  p-&gt;next=S; </span><br><span class="line">  S=p; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>链栈的出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LiStack &amp;S,<span class="type">int</span> &amp;x)</span><span class="comment">//出栈操作</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> x=S-&gt;data;</span><br><span class="line"> S=S-&gt;next;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>链栈的判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EmptyStack</span><span class="params">(LiStack S)</span><span class="comment">//判空</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>取栈顶元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTOP</span><span class="params">(LiStack S,<span class="type">int</span> &amp;x)</span><span class="comment">//取栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  x=S-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-队列（✪）"><a href="#2-队列（✪）" class="headerlink" title="2.队列（✪）"></a>2.队列（✪）</h3><h4 id="队列的基本概念（操作受限的线性表）"><a href="#队列的基本概念（操作受限的线性表）" class="headerlink" title="队列的基本概念（操作受限的线性表）"></a>队列的基本概念（操作受限的线性表）</h4><ul><li>队列的定义：只允许在表的一端进行插入，而在表的另一端进行删除。</li><li>向队列中插入元素称为入队或进队（此端为队尾rear）；删除元素称为出队或离队（此端为队头front）</li><li>特点：先进先出</li></ul><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><ul><li><p>顺序队列的指针设置：<strong>顺序队列设置两个指针，队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置</strong></p></li><li><p>顺序队列的出入队操作</p><ul><li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加一</li><li>出队操作：队不空时，先取队头元素值，再将队头指针加一</li></ul></li><li><p>初始时：Q.front==Q.rear\==0，此即为判空的条件</p></li><li><p><strong>存在的问题：不能用 Q.rear==MaxSize作为判断队满的条件，并且还有可能造成假溢出</strong></p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/29/pCwYUvn.png" alt="pCwYUvn.png"></li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear; <span class="comment">//队头指针指向队头元素、队尾指针指向队尾元素的下一个位置 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环队列（✪）"><a href="#循环队列（✪）" class="headerlink" title="循环队列（✪）"></a>循环队列（✪）</h4><ul><li><p>循环队列的概念：采用循环队列时，将顺序队列想像成一个环形的空间（逻辑上视为一个环），<br>当队首指针Q.front==MaxSize-1后，再前进一个位置就自动到0，可采取除法取余运算（%）来实现。</p></li><li><p>循环队列的指针设置：<strong>入队出队时相应的指针按顺时针方向进1</strong></p><ul><li>初始时：Q.front=Q.rear=0</li><li>出队时，队首指针进1：Q.front=(Q.front+1)%MaxSize.</li><li>入队时，队尾指针进1：Q.rear=(Q.rear+1)%MaxSize.</li><li>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize.</li></ul></li><li><p>循环队列的判空条件：Q.front==Q.rear。</p></li><li><p>此时的局限性：<strong>若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队尾指针，此时将无法判断队满还是队空</strong></p></li><li><p>三种处理方式区分队空和队满的判断条件（✪）</p><ul><li><p>牺牲一个数组单元来区分队空和队满（♚）</p><ul><li><p>具体实现：<strong>入队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置“作为队满的标志</strong></p></li><li><p>此时判断队满和队空的条件</p><ul><li><strong>队满条件：(Q.rear+1)%Maxsize\==Q.front</strong></li><li><strong>队空条件：Q.front==Q.rear.</strong></li><li><strong>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize。</strong></li></ul></li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/29/pCwt8qx.png" alt="pCwt8qx.png"></li></ul></li><li>例题：本题选A<ul><li><img src="https://s1.ax1x.com/2023/07/04/pCscjpQ.png" alt="pCscjpQ.png"></li></ul></li></ul></li><li><p>结构体类型中增设表示元素个数的数据成员（size）</p><ul><li>入队时：Q.size++；出队时：Q.size—，此时队空和队满都满足：Q.front\==Q.rear</li><li>队空的条件为：Q.s1ze\==0</li><li>队满的条件为：Q.size\==MaxSize</li></ul></li><li><p>结构体类型中增设tag数据成员，以区分是队满还是队空。</p><ul><li>初始化时tag=0；入队成功时令tag=1；出队成功时令tag=0</li><li>tag等于0时，若因删除导致Q.front\==Q.rear,则为队空</li><li>tag等于1时，若因插入导致Q.front\==Q.rear,则为队满</li></ul></li></ul></li><li><p>循环队列的代码实现</p><ul><li><p>循环队列的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">Q.rear=Q.front=<span class="number">0</span>;<span class="comment">//初始化队首与队尾指针 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>循环队列的判断队空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(SqQueue Q)</span><span class="comment">//判空 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>循环队列的入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//入队 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)<span class="comment">//判断队列是否已满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Q.data[Q.rear]=x;</span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>循环队列的出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> &amp;x)</span><span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front)<span class="comment">//判空 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">x=Q.data[Q.front];</span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>取循环队列的队首元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue Q,<span class="type">int</span> &amp;x)</span><span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front)<span class="comment">//判空 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">x=Q.data[Q.front];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="链式队列（✠）"><a href="#链式队列（✠）" class="headerlink" title="链式队列（✠）"></a>链式队列（✠）</h4><ul><li><p>链式队列的定义</p><ul><li><strong>一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点(即单链表的最后一个结点)</strong><br><strong>注意与顺序存储的不同</strong></li><li><strong>一般将链式队列设计成一个带头结点的单链表，统一插入和删除操作</strong></li><li><strong>最适合作为链队的链表是带队头指针和队尾指针的非循环单链表（带头结点）</strong>，<br>此时可快速在第一个位置实现删除操作，在最后一个位置实现插入操作（循环单链表画蛇添足了）</li><li><strong>用链式方式存储的队列，在进行插入运算时，头尾指针可能都要修改</strong><ul><li>当队列不为空时，只会修改rear尾指针。</li><li>当队列为空时，再当有头结点时，也只要修改rear</li><li>当队列为空且没有头结点时，头尾指向相同，在插入时就需要同时修改头和尾</li></ul></li></ul></li><li><p>不带头结点的链式队列</p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/29/pCwwUv4.png" alt="pCwwUv4.png"></li></ul></li><li>链式队列的判空：当Q.front\==NULL&amp;&amp;Q.rear==NULL时，链式队列为空</li><li>链式队列的出入队操作：<ul><li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点<br>若原队列为空队，则令Q.front也指向该结点</li><li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点<br>若该结点为最后一个结点，则置Q.front和Q.rear都为NULL</li></ul></li></ul></li><li><p>带头结点的链式队列</p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/29/pCwwdKJ.png" alt="pCwwdKJ.png"></li></ul></li><li>链式队列的判空：Q.front==Q.rear</li><li>链式队列的出入队操作<ul><li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点</li><li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点<br>若该结点为最后一个结点，则置Q.rear=Q.front</li></ul></li></ul></li><li><p>链式队列的优点</p><ul><li>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</li><li>假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。</li></ul></li><li><p>带头结点的链式队列的代码实现</p><ul><li><p>链式队列的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>//链式队列结点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//链式队列 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkNode *front,*rear;<span class="comment">//链式队列头指针与尾指针 </span></span><br><span class="line">&#125;LinkQueue;  </span><br></pre></td></tr></table></figure></li><li><p>链式队列的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span><span class="comment">//链式队列的初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//头指针和尾指针指向新建立的头结点 </span></span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始为空 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>链式队列的判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkQueue Q)</span><span class="comment">//链式队列的判空 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>链式队列的入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//链式队列的入队 </span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//创建新节点 </span></span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next=s;</span><br><span class="line">Q.rear=s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>链式队列的出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用链式存储方式的队列进行删除操作时需要：头尾指针可能都需要修改,因为如果此时队列中只有一个元素的话，删除之后，队列为空，需要将Q.rear=Q.front;</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span><span class="comment">//链式队列的出队 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)<span class="comment">//判空 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LinkNode *p=Q.front-&gt;next;<span class="comment">//创建一个指针此时指向出队的结点 </span></span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;<span class="comment">//进行出队的操作</span></span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)<span class="comment">//若原队列中只有一个结点，则删除之后变空。 </span></span><br><span class="line">Q.rear=Q.front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="双端队列（主要考察选择题✪）"><a href="#双端队列（主要考察选择题✪）" class="headerlink" title="双端队列（主要考察选择题✪）"></a>双端队列（主要考察选择题✪）</h4><ul><li>双端队列的概念：双端队列是指允许两端都可以进行入队和出队操作的队列，此时可以加上一定的限制<br>形成输出受限的双端队列和输入受限的双端队列</li><li>题目考查<ul><li><strong>作为选择题：常常以输入序列来判断相关的输出序列是否正确，此时的方法是画图进行分析。</strong></li><li><strong>特别地，对于输出序列受限的这一类的题目，可以将其的输出序列直接依次填入所画的双端队列图，由题目的输入序列来反推是否可以得到此输出序列</strong></li><li>例题：分别选C、C<ul><li><img src="https://s1.ax1x.com/2023/04/21/p9E0NGQ.png" alt="p9E0NGQ.png"></li></ul></li></ul></li></ul><h3 id="3-栈和队列的应用-侧重手算模拟-代码不需要掌握✪"><a href="#3-栈和队列的应用-侧重手算模拟-代码不需要掌握✪" class="headerlink" title="3.栈和队列的应用 (侧重手算模拟,代码不需要掌握✪)"></a>3.栈和队列的应用 (侧重手算模拟,代码不需要掌握✪)</h3><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><ul><li>过程：依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</li><li>匹配失败情况：①左括号单身②右括号单身③左右括号不匹配</li><li>流程图<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9eIMRJ.jpg" alt="p9eIMRJ.jpg"></li></ul></li><li>算法实现<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9eIuiF.jpg" alt="p9eIuiF.jpg"></li></ul></li></ul><h4 id="栈在表达式求值中的应用（✪）"><a href="#栈在表达式求值中的应用（✪）" class="headerlink" title="栈在表达式求值中的应用（✪）"></a>栈在表达式求值中的应用（✪）</h4><ul><li>中缀表达式<ul><li>中缀表达式包括:操作数、运算符、界限符</li><li>其运算符在两个操作数的中间（a+b-c*d）</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/04/24/p9mqljg.jpg" alt="p9mqljg.jpg"></li></ul></li></ul></li><li>后缀表达式（♚）<ul><li>定义：也称逆波兰表达式，运算符在两个操作数的后面（$ab+cd*-$）</li><li>中缀表达式转为后缀表达式<ul><li>手算（在确定中缀表达式的运算顺序时，只要左边的能算，就优先算左边的）<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9eohtO.jpg" alt="p9eohtO.jpg"></li></ul></li><li>机算<ul><li><img src="https://s1.ax1x.com/2023/04/24/p9mbg1S.jpg" alt="p9mbg1S.jpg"></li></ul></li></ul></li><li>后缀表达式求值<ul><li>手算<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9eTg2Q.png" alt></li></ul></li><li>机算<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9e7AsA.png" alt="p9e7AsA.png"></li></ul></li></ul></li></ul></li><li>前缀表达式<ul><li>定义：也称波兰表达式，运算符在两个操作数的前面（$-+ab*cd$）</li><li>中缀表达式转前缀表达式<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9eH1fO.jpg" alt="p9eH1fO.jpg"></li></ul></li><li>前缀表达式求值<ul><li><img src="https://s1.ax1x.com/2023/04/23/p9eH6Xj.png" alt="p9eH6Xj.png"></li></ul></li></ul></li></ul><h4 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h4><ul><li><p>关于函数的调用</p><ul><li><strong>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</strong></li><li>函数调用时，需要用一个函数调用栈存储相关信息：调用返回地址、实参、局部变量</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/04/24/p9mjPIA.png" alt="p9mjPIA.png"></li></ul></li></ul></li><li><p>关于递归</p><ul><li><p><strong>定义：若在一个函数、过程或数据结构的定义中又应用了它自身，则称为递归</strong></p><ul><li><p>递归调用时，函数调用栈可称为”递归工作栈”</p></li><li><p>每进入一层递归，就将递归调用所需信息压入栈顶</p></li><li>每退出一层递归，就从栈顶弹出相应信息</li></ul></li><li>递归模型不能是循环定义的，必须满足的两个条件：递归表达式（递归体）；边界条件（递归出口）。</li><li>适合用“递归”算法解决的问题：可以把原始问题转换为属性相同，但规模较小的问题，此时可以大大减少程序的代码量</li><li>可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换</li><li><p>递归程序的缺点</p><ul><li>太多层递归可能会导致栈溢出</li><li><strong>通常效率较低，可能包含很多重复计算</strong></li><li>空间复杂度较高</li></ul></li><li>消除递归不一定必须用栈来实现</li></ul></li><li><p>求阶乘问题</p><ul><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="comment">//边界条件 </span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);<span class="comment">//递归表达式 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n=factorial(<span class="number">10</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/04/24/p9mvmSx.jpg" alt="p9mvmSx.jpg"></li></ul></li></ul></li><li><p>斐波那契数列问题</p><ul><li><img src="https://s1.ax1x.com/2023/04/24/p9mz2eU.png" alt="p9mz2eU.png"></li></ul></li></ul><h4 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h4><ul><li>可作为树的层次遍历、图的广度遍历、页面替换算法、可作为<strong>数据缓冲区（打印机应用）</strong></li></ul><h3 id="4-数组和特殊矩阵（选择题考点✪）"><a href="#4-数组和特殊矩阵（选择题考点✪）" class="headerlink" title="4.数组和特殊矩阵（选择题考点✪）"></a>4.数组和特殊矩阵（选择题考点✪）</h3><ul><li>数组的存储结构<ul><li>数组是由n(n≥1)个相同类型的数据元素构成的有限序列，是线性表的推广（顺序存储结构）</li><li><strong>广义表采取的是链式存储结构，一个广义表的表尾总是一个广义表</strong></li><li>多维数组的两种映射方法<ul><li>行优先<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6AC0e.png" alt="pC6AC0e.png"></li></ul></li><li>列优先<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6AM7Q.png" alt="pC6AM7Q.png"></li></ul></li></ul></li></ul></li><li>特殊矩阵的压缩存储<ul><li>压缩存储的定义：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间</li><li>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。<br>常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。</li><li>特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，<br>把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。</li><li>注意: 二维数组 ${A[n][n]}$ 和 ${A[0 \ldots n-1][0 \ldots n-1]}$ 的写法是等价的。<ul><li>如果数组写为 ${A[1 \ldots n][1 \ldots n]}$, 则说明指定了从下标 1 开始存储元素。</li><li>二维数组元素写为 ${a[i][j]}$, 注意数组元素下标 ${i}$ 和 ${j}$ 通常是从 0 开始的。</li><li>矩阵元素通常写为 ${a_{i, j}}$ 或 ${a_{(i)(j)}}$, 注意行号 ${i}$ 和列号 ${j}$ 是 从 1 开始的。</li></ul></li></ul></li><li>特殊矩阵（♚）<ul><li>处理特殊矩阵的方式，一般先找出前i-1行的规律，再将其与第i行相加即可<strong>（通过画出具体的方阵图来分析）</strong></li><li>对称矩阵<ul><li>此时n阶方阵中均有：$a_{i,j} = a_{j,i}$，则只需要存放主对角线和下三角形部分。</li><li>如果为将下三角部分的元素存入数组的对称矩阵，此时按行优先方式有以下结论<br>（前i-1行可由求和公式得出，为上三角形时，i与j互换）<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6EzZD.png" alt="pC6EzZD.png"></li></ul></li></ul></li><li>三角矩阵<ul><li>下三角形矩阵<ul><li>上三角区的所有元素均为同一常量。存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6ZG9A.png" alt="pC6ZG9A.png"></li></ul></li><li>行优先原则的下标<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6ZaB8.png" alt="pC6ZaB8.png"></li></ul></li></ul></li><li>上三角形矩阵<ul><li>行优先原则的下标<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6Z0Ag.png" alt="pC6Z0Ag.png"></li></ul></li></ul></li></ul></li><li>三对角矩阵（带状矩阵）<ul><li>三对角矩阵中，所有非零元素都集中在以主对角线为中心的三条对角线的区域，其它区域的元素都为0<br>当|i-j|&gt;1时，此时为0<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6ZvUe.png" alt="pC6ZvUe.png"></li></ul></li><li>行优先原则的下标<ul><li>前i-1行共 3(i-1)-1 个元素 （第一行需要减1）</li><li>$a_{i,j}$是i行第j-i+2个元素，$a_{i,j}$是第2i+j-2个元素</li><li>此时数组下标k为k=2i+j-3</li></ul></li><li>如何根据下标求出元素在数组中的具体位置<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6necn.png" alt="pC6necn.png"></li></ul></li></ul></li></ul></li><li>稀疏矩阵（<strong>压缩存储后必定会失去随机存储的功能</strong>）<ul><li>矩阵中非零元素的个数远远小于为0的元素</li><li>使用顺序存储方式压缩存储（三元组表）<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6Qze1.png" alt="pC6Qze1.png"></li></ul></li><li>使用链式存储方式压缩存储（十字链表）<ul><li><img src="https://s1.ax1x.com/2023/07/06/pC6liWD.png" alt="pC6liWD.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第三章-栈，队列和数组&quot;&gt;&lt;a href=&quot;#数据结构第三章-栈，队列和数组&quot; class=&quot;headerlink&quot; title=&quot;数据结构第三章-栈，队列和数组&quot;&gt;&lt;/a&gt;数据结构第三章-栈，队列和数组&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：第三章栈，队列和数组的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第二章-线性表</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2024-08-11T09:01:02.000Z</published>
    <updated>2024-08-11T10:02:23.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第二章-线性表"><a href="#数据结构第二章-线性表" class="headerlink" title="数据结构第二章 线性表"></a>数据结构第二章 线性表</h2><blockquote><p>计算机学科基础：数据结构第二章线性表的学习笔记</p></blockquote><span id="more"></span><h3 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1.线性表的定义"></a>1.线性表的定义</h3><ul><li><p>①定义：具有<u>相同数据类型</u>的n个<u>数据元素</u>的<u>有限序列</u>，<strong>线性表是一种逻辑结构，表示元素之间一对一的相邻关系</strong></p></li><li><p>②特点：<strong>表中的元素在逻辑上相邻，具有逻辑上的顺序性，有其先后次序，每个元素只有唯一的前驱元素</strong></p></li></ul><h3 id="2-顺序表（线性表的顺序存储结构✪）"><a href="#2-顺序表（线性表的顺序存储结构✪）" class="headerlink" title="2.顺序表（线性表的顺序存储结构✪）"></a>2.顺序表（线性表的顺序存储结构✪）</h3><ul><li><p>①定义：<strong>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素</strong><br><strong>从而使得逻辑上相邻的两个元素在物理位置上也相邻</strong></p></li><li><p>②特点</p><ul><li>顺序表中元素的逻辑顺序与其物理顺序相同</li><li>顺序表中的任意一个数据元素都可以<strong>随机存取</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li><li>顺序表的存储密度高，每个结点只存储数据元素。</li><li><strong>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</strong></li><li><strong>n个元素的顺序表可插入的位置有n+1个，移动次数总数为：n(n+1)/2</strong><br><strong>平均移动次数为：n/2</strong></li><li><strong>n个元素的顺序表删除元素时，平均移动次数为：(n-1)/2</strong></li><li><strong>n个元素的顺序表顺序查找的平均比较/查找次数为：(n+1)/2</strong></li></ul></li><li><p>③代码实现（用<strong>数组</strong>来描述线性表的顺序存储结构♚）</p><ul><li><p>顺序表的定义</p><ul><li><p>静态分配一维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50 <span class="comment">//定义顺序表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//对顺序表进行初始化 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>动态分配一维数组（存储数组的空间使用malloc函数进行动态分配）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> *data; <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize,length; <span class="comment">//数组的最大容量和当前顺序表的长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqLsit L;</span><br><span class="line">InitList(L); <span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="comment">//...向表中插入几个元素</span></span><br><span class="line">    IncreaseSize(L,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span><span class="comment">//使用动态分配方法的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span><span class="comment">//为数组分配新的空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L.data;<span class="comment">//申请一个新指针</span></span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize=L.Maxsize+len;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>顺序表的插入操作（平均时间复杂度：O(n)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span><span class="comment">//顺序表的插入，指定位置，插入元素 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L.length&gt;=MaxSize)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>顺序表的删除操作（平均时间复杂度：O(n)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//顺序表的删除，删除指定位置的元素，并传出此元素 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)</span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>顺序表的按值查找位置 （平均时间复杂度：O(n)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SqList L,<span class="type">int</span> e)</span><span class="comment">//按值查号，返回该第一个等于值的位置 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//查到了则返回其位序</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>顺序表的按位查找元素 （平均时间复杂度：O(1)，此时为随机访问）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Get</span><span class="params">(SqList L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//按位查找，返回在位置i上的元素e </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-链表（线性表的链式存储结构✪）"><a href="#3-链表（线性表的链式存储结构✪）" class="headerlink" title="3.链表（线性表的链式存储结构✪）"></a>3.链表（线性表的链式存储结构✪）</h3><ul><li><p>①定义：<strong>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。</strong><br><strong>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</strong></p></li><li><p>②特点</p><ul><li>链式存储线性表时，不需要使用地址连续的存储单元，不要求逻辑上相邻的元素在物理上也相邻</li><li>插入和删除元素不需要移动元素，只需要修改指针。</li><li>单链表附加指针域，也存在浪费存储空间的缺点。</li><li>由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，<br>即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。</li><li><strong>设一个有序的单链表中有n个结点，现要求插入一个新节点后使得单链表仍然保持有序，则该操作的时间复杂度为O(n)</strong></li></ul></li><li><p>③代码实现（♚）</p><ul><li><p>单链表的定义</p><ul><li><p>单链表的结点由数据域（data，存放数据元素）和指针域（next，存放其后继结点的地址）组成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList; <span class="comment">//别名，第一个强调它是一个结点，第二个强调它是一个链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：要表示一个单链表，只需声明一个头指针L，指向单链表的第一个结点。</span></span><br><span class="line"><span class="comment">// LNode *L;或 LinkList L;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>初始化单链表</p><ul><li><p>带头结点的单链表（头指针指向头结点）</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaMWPx.png" alt="pCaMWPx.png"></li></ul></li><li><p>为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点<br>头结点的数据域不带任何信息，指针域指向线性表的第一个<strong>数据结点</strong>（区分第一个结点和第一个数据结点）</p></li><li><p>头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点<br>而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p></li><li><p>引入头结点的优点</p><ul><li><strong>对于插入或删除第一个数据结点的操作，由于第一个数据结点的位置被存放在头结点的指针域中，</strong><br><strong>因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</strong></li><li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空）<br>因此空表和非空表的处理也就得到了统一。</li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//初始化单链表 </span></span><br><span class="line">&#123;</span><br><span class="line">L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//分配一个头结点 </span></span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>不带头结点的单链表 （头指针指向第一个数据结点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">L=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>建立单链表</p><ul><li><p>使用头插法建立单链表（<strong>时间复杂度O(n)</strong>）</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCa8TUJ.png" alt="pCa8TUJ.png"></li></ul></li><li><p>从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头</p></li><li><p>读入数据的顺序与生成的链表中的元素的顺序是相反的</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//头插法建立单链表,可以用于实现逆置 </span></span><br><span class="line">&#123;</span><br><span class="line">LNode *s;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建头结点</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//初始为空链表</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建新结点</span></span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=s;  <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用尾插法建立单链表（<strong>时间复杂度O(n)</strong>）</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCa8jKK.png" alt="pCa8jKK.png"></li></ul></li><li><p>该方法将新结点插入到当前链表的表尾，需要增加一个尾指针r，使其始终指向当前链表的尾结点</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TaliInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//尾插法建立单链表 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">LNode *s,*r=L;<span class="comment">//尾插法需要建立一个尾指针r,刚开始都指向头结点 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">r-&gt;next=s;</span><br><span class="line">r=s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">&#125; </span><br><span class="line">r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点指针置空</span></span><br><span class="line"><span class="keyword">return</span> L; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单链表按序号查找结点 （<strong>时间复杂度O(n)</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span><span class="comment">//循环单链表找到第i个位置的指针 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//若i无效，返回NULL</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//相当于把头结点看作是0号位置</span></span><br><span class="line">LNode *p=L;<span class="comment">//刚开始P指向头结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单链表按值查找节点（<strong>时间复杂度O(n)</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,<span class="type">int</span> e)</span><span class="comment">//按值查找结点 </span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p=L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line"> p=p-&gt;next;</span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">//找到后返回该结点的指针，如果链表中没有该值将返回空值 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>单链表的插入结点操作</p><ul><li><p>指定的结点后插操作</p><ul><li><p>查找待插入位置的前驱结点的时间复杂度为O(n)，在给定的结点后面插入新结点的时间复杂度为O(1)</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaJDYj.png" alt="pCaJDYj.png"></li></ul></li><li><p>插入结点操作将值为×的新结点插入到单链表的第i个位置上。先检查插入位置的合法性<br>然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点</p></li><li><p>算法首先调用按序号查找算法GetElem（L，i-1），查找第i-1个结点。<br>假设返回的第i-1个结点为p，然后令新结点s的指针域指向p的后继结点，再令结点p的指针域指向新插入的结点s</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找插入位置的前驱结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertNext</span><span class="params">(LNode *p,<span class="type">int</span> e)</span><span class="comment">//指定结点的后插操作,需要找到其前驱结点,此时的p是指向待插入位置的前驱结点的指针  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=p-&gt;next; </span><br><span class="line">p-&gt;next=s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定结点的前插操作</p><ul><li><p><strong>查找待插入位置的结点的时间复杂度为O(n)，在给定的结点前面插入新结点的时间复杂度为O(1)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPrior</span><span class="params">(LNode *p,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;next=p-&gt;next; </span><br><span class="line">p-&gt;next=s;</span><br><span class="line">s-&gt;data=p-&gt;data;  <span class="comment">//交换了数据域 </span></span><br><span class="line">p-&gt;data=e; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单链表的删除结点操作</p><ul><li><p>寻找待删除结点的前驱结点，再执行相关删除操作</p><ul><li><p>查找待删除位置的前驱结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaYsED.png" alt="pCaYsED.png"></li></ul></li><li><p>先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//删除第i个位置的元素，并用e返回删除元素的值,需要找到前驱结点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *p=GetElem(L,i<span class="number">-1</span>);<span class="comment">//循环单链表找到第i-1个位置的指针</span></span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *q=p-&gt;next;<span class="comment">//新创建一个指针，并使该指针指向当前欲删除的结点 </span></span><br><span class="line">e=q-&gt;data;</span><br><span class="line">p-&gt;next=q-&gt;next;<span class="comment">//修改前驱结点的指针域使其指向待删除结点的下一个结点,将*q结点从链中断开 </span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放结点的存储空间 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>寻找待删除结点，再执行相关删除操作</p><ul><li><p>查找待删除位置的结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p></li><li><p>删除结点P的操作可用删除P的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteNext</span><span class="params">(LNode *p,<span class="type">int</span> &amp;e)</span><span class="comment">//删除需删除结点的后继结点，但是此时由于该原本该删除的结点的数据域和指针域已经被实际删除的结点的值覆盖，因此相当于删除了需删除的结点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *q=p-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">p-&gt;data=q-&gt;data;</span><br><span class="line">p-&gt;next=q-&gt;next</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单链表的求表长操作<strong>（时间复杂度为O(n)）</strong></p><ul><li><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，<br>为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span><span class="comment">//求表长 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">LNode *p=L-&gt;next; <span class="comment">//创建一个指针指向第一个数据结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="4-双链表（主要考察选择题✪）"><a href="#4-双链表（主要考察选择题✪）" class="headerlink" title="4.双链表（主要考察选择题✪）"></a>4.双链表（主要考察选择题✪）</h3><ul><li><p>①定义</p><ul><li>双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，<br>在指针已经指向相应结点的情况下，插入和删除的时间复杂度为O(1)</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCatOFe.png" alt="pCatOFe.png"></li></ul></li></ul></li><li><p>②代码实现</p><ul><li><p>双链表的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;; DNode,*DLinkList;</span><br></pre></td></tr></table></figure></li><li><p>双链表的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitDLink</span><span class="params">(DLinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L-&gt;prior=<span class="literal">NULL</span>;<span class="comment">//头结点的前驱指针永远指向NULL </span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>双链表的插入操作</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaUsET.png" alt="pCaUsET.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(DNode *p,DNode *s)</span><span class="comment">//在i位置上的p节点之后插入结点s，数值为e </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">s-&gt;next=p-&gt;next; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">p-&gt;next-&gt;prior=s;</span><br><span class="line">s-&gt;prior=p;  <span class="comment">//2</span></span><br><span class="line">p-&gt;next=s;  <span class="comment">//3</span></span><br><span class="line">p-&gt;data=e; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; <span class="comment">//1和2步必须在第4步之前，否则p的后继结点的指针就会丢掉，导致插入失败</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>双链表的删除操作</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCadQTf.png" alt="pCadQTf.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(DNode *p)</span><span class="comment">//删除p结点的后继结点q </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">DNode *q=p-&gt;next; <span class="comment">//找到p的后继结点q </span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span>)<span class="comment">//p结点没有后继 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p-&gt;next=q-&gt;next; </span><br><span class="line"><span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="5-循环链表（主要考察选择题✪）"><a href="#5-循环链表（主要考察选择题✪）" class="headerlink" title="5.循环链表（主要考察选择题✪）"></a>5.循环链表（主要考察选择题✪）</h3><ul><li><p>①循环单链表</p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCawDbt.png" alt="pCawDbt.png"></li></ul></li><li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li><li>在循环单链表中，表尾结点r的next域指向L，故表中没有指针域为NULL的结点，<br>因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</li><li>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表</li><li>有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。<ul><li>其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，</li><li>而若设的是尾指针r，r-&gt;next即为头指针，对在表头或表尾插入元素都只需要O($1$)的时间复杂度。</li></ul></li></ul></li><li><p>②循环双链表</p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCawbPU.png" alt="pCawbPU.png"></li></ul></li><li>循环双链表中，头结点的前指针指向表尾节点，判空的条件是头结点的前后指针域都等于头结点</li><li>循环双链表是有助于删除第一个结点、删除最后一个结点，在第一个结点前插入一个结点，在最后一个结点后添加一个结点<ul><li>选A、C，如果是循环单链表，没办法处理删除最后一个结点（无法快速找到最后一个结点的前驱结点）</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsd3sU.png" alt="pCsd3sU.png"></li></ul></li></ul></li></ul><h3 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h3><ul><li><p><strong>静态链表借助数组来描述线性表的<u>链式存储结构</u>，也有指针域和数据域</strong></p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCa0zlQ.png" alt="pCa0zlQ.png"></li></ul></li></ul></li><li><p>指针表示下一个元素的数组下标（游标），静态链表也需要事先分配一块连续的内存空间。</p></li><li><p>其插入和删除不需要移动元素，只需要修改指针。</p></li><li><p>以next==-1作为结束的标志。</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-顺序表和链表的比较（✪）"><a href="#7-顺序表和链表的比较（✪）" class="headerlink" title="7.顺序表和链表的比较（✪）"></a>7.顺序表和链表的比较（✪）</h3><ul><li>1.存取（读写）方式<ul><li>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。</li><li>例如在第i个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。</li></ul></li><li>2.逻辑结构与物理结构<ul><li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。</li><li>而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li></ul></li><li>3.查找、插入和删除操作<ul><li>对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)<br>顺序表有序时，可采用折半查找，此时的时间复杂度为O($log_2n$).</li><li>对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)<br>而链表的平均时间复杂度为O(n)</li><li>顺序表的插入、删除操作，平均需要移动半个表长的元素。<br>链表的插入、删除操作，只需修改相关结点的指针域即可。</li><li>由于链表的每个结点都带有指针域，故而存储密度不够大。</li></ul></li><li>4.空间分配<ul><li>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，<br>因此需要预先分配足够大的存储空间。<ul><li>预先分配过大，可能会导致顺序表后部大量闲置；</li><li>预先分配过小，又会造成溢出。</li></ul></li><li>动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，<br>而且若内存中没有更大块的连续存储空间，则会导致分配失败。</li><li>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</li></ul></li><li>如何选取存储结构<ul><li>1.基于存储的考虑<ul><li>难以估计线性表的长度或存储规模时，不宜采用顺序表</li><li>链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</li></ul></li><li>2.基于运算的考虑<ul><li>在顺序表中按序访问的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n),<br>因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</li><li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的</li><li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</li></ul></li><li>3.基于环境的考虑<ul><li>顺序表容易实现，任何高级语言中都有数组类型，链表的操作是基于指针的，<br>相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</li><li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第二章-线性表&quot;&gt;&lt;a href=&quot;#数据结构第二章-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构第二章 线性表&quot;&gt;&lt;/a&gt;数据结构第二章 线性表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第二章线性表的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第一章-绪论</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</id>
    <published>2024-08-11T08:08:11.000Z</published>
    <updated>2024-08-11T13:58:04.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第一章-绪论"><a href="#数据结构第一章-绪论" class="headerlink" title="数据结构第一章 绪论"></a>数据结构第一章 绪论</h2><blockquote><p>计算机学科基础：数据结构第一章绪论的学习笔记</p></blockquote><span id="more"></span><h3 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1.数据结构的基本概念"></a>1.数据结构的基本概念</h3><ul><li>数据</li><li>数据元素：<u>数据的基本单位</u>，由若干个数据项组成<br><strong>数据项是不可分割的最小独立数据单位</strong></li><li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集</li><li>数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称<ul><li>原子类型：其值不可再分的数据类型。（如bool、int）</li><li>结构类型：其值可以再分解为若干成分（分量）的数据类型。(如结构体)</li><li><strong>抽象数据类型ADT</strong>：抽象数据组织及与之相关的操作<br>描述了数据的逻辑结构和抽象运算，定义了一个完整的数据结构，如线性表、栈、队列、树、图等）。</li></ul></li><li>数据结构<ul><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)</li><li>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</li><li>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，<br>而算法的实现依赖于所采用的存储结构。</li></ul></li></ul><h3 id="2-数据结构的三要素"><a href="#2-数据结构的三要素" class="headerlink" title="2.数据结构的三要素"></a>2.数据结构的三要素</h3><ul><li>数据的逻辑结构：数据元素之间的逻辑关系，<strong>数据的逻辑结构独立于其存储结构</strong><ul><li>线性结构（数据元素之间只存在一对一的关系）<ul><li>一般线性表</li><li>受限线性表：栈和队列、串</li><li>线性表推广：数组</li></ul></li><li>非线性结构<ul><li>集合 （结构中的数据元素之间除“同属一个集合外”，别无其他关系）</li><li>树形结构：一般树、二叉树（数据元素之间存在一对多的关系）</li><li>图状结构：有向图、无向图（数据元素之间存在多对多的关系）</li></ul></li><li>概念型的例题<ul><li>此题选C，逻辑结构均是线性结构</li><li><img src="https://s1.ax1x.com/2023/07/04/pCs0g2t.png" alt="pCs0g2t.png"></li></ul></li></ul></li><li>数据的存储结构：存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。<br>包括数据元素的表示和关系的表示（<strong>存储数据时，不仅要存储各数据元素的值，也要存储数据元素之间的关系</strong>）<ul><li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中（如顺序表）<br>元素之间的关系由存储单元的邻接关系来体现。<ul><li>其优点是可以实现随机存取，每个元素占用最少的存储空间</li><li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li></ul></li><li>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，<br>借助指示元素存储地址的指针来表示元素之间的逻辑关系<ul><li>链式存储时，链式存储时各个不同结点的存储空间可以不连续，但结点内的存储单元地址一定连续</li><li>链式存储结构比顺序存储结构更能方便地表示各种逻辑结构</li><li>其优点是不会出现碎片现象，能充分利用所有存储单元</li><li>缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li></ul></li><li>索引存储：在存储元素信息的同时，还建立附加的索引表。<br>索引表中的每项称为索引项，索引项的一般形式是(关键字，地址)。<ul><li>其优点是检索速度快：缺点是附加的索引表额外占用存储空间。</li><li>增加和删除数据时也要修改索引表，因而会花费较多的时间。</li></ul></li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hsh)存储。<ul><li>其优点是检索、增加和删除结点的操作都很快</li><li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li></ul></li></ul></li><li>数据的运算：施加在数据上的运算包括运算的定义和实现。<ul><li>运算的定义是针对逻辑结构的，指出运算的功能</li><li>运算的实现是针对存储结构的，指出运算的具体操作步骤。</li><li><strong>不是每种数据结构都具备三种基本运算：插入、删除和查找</strong><br><strong>如栈和队列无法查找，二维数组无法删除</strong></li></ul></li></ul><h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul><li>算法的概念：<strong>对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li><li>五个重要特性<ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算<u>执行有限次</u>来实现。</li><li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li></ul></li><li>四个目标<ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，<br>这两者都与问题的规模有关。</li></ul></li></ul><h3 id="4-算法效率的度量（✪）"><a href="#4-算法效率的度量（✪）" class="headerlink" title="4.算法效率的度量（✪）"></a>4.算法效率的度量（✪）</h3><ul><li><p>时间复杂度</p><ul><li>一个语句的频度是指该语句在算法中<u>被重复执行的次数</u>。算法中所有语句的频度之和记为T(n)，<br><u>它是该算法问题规模n的函数</u>，时间复杂度主要分析T(n)的<u>数量级</u>，<strong>执行时间与时间复杂度的值成正比</strong>。</li><li>算法中基本运算（<strong>最深层循环内的语句</strong>）的频度与T(n)同数量级，<br><strong>因此通常采用算法中基本运算的频度f(n)来分析时间复杂度</strong>，$T ( n ) = O ( f ( n ) )$<ul><li>如此题中，问题规模始终都是n，执行时间与时间复杂度的值成正比，选C<ul><li><img src="https://s1.ax1x.com/2023/07/04/pCse6aQ.png" alt="pCse6aQ.png"></li></ul></li><li>此题可以反映时间复杂度是看问题规模的数量级（即看最高阶，抓大头选B）<ul><li><img src="https://s1.ax1x.com/2023/07/04/pCsKhY4.png" alt="pCsKhY4.png"></li></ul></li><li>但是有两个变量的话就不一样了，如此题选C<ul><li><img src="https://s1.ax1x.com/2023/08/14/pPMMWOs.png" alt="pPMMWOs.png"></li></ul></li></ul></li><li><strong>算法的时间复杂度不仅依赖于问题的规模，也取决于待输入数据的性质（如输入数据元素的初始状态)</strong></li></ul></li><li><p>空间复杂度：算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。</p></li><li><p>关于时间复杂度的例题（♚）</p><ul><li>步骤：首先确定循环中变化的值，之后跟据其变化情况列出其经过每轮循环之后的值<br>（先用实数，最后写出规律式（含频数k）），之后并与问题规模n组成不等式，最后求出k关于n的表达式</li><li>例1<ul><li>此时写出i的变化规律：$1,2,4…2^{k},2^{k}=n,k=log_{2}n$</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsnQ0O.png" alt="pCsnQ0O.png"></li></ul></li><li>例2<ul><li>此时写出x的变化规律：$4,8,16…2^{k+1},2^{k+1}&lt;n/2,k=log_{2}n/2-1=log_{2}n-2$，此时即选A</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsu8bT.png" alt="pCsu8bT.png"></li></ul></li><li>例3<ul><li>此时有内外两层的循环，且外层循环的值决定了内层循环的次数，应该以外层为基准来看</li><li>外层执行第一轮(i=1)：最内层语句执行2次，外层执行第二轮(i=2)，最内层语句执行4次，<br>外层执行第三轮(i=3)，最内层语句执行6次，</li><li>此时有规律得（外层执行第n轮时，最内层语句执行2n次）总次数即为相加（求和公式(2+2n)*n/2)=n(n+1)）</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsKneK.png" alt="pCsKneK.png"></li></ul></li><li><p>例4</p><ul><li><p>先看外层的循环取值</p></li><li><p>此时有$i=1,2,4……2^{k}&lt;n ，此时对应的内层总次数相加为1+2+……2^{k}=2^{k+1}-1&lt;2n$，时间复杂度为n</p></li><li><p><img src="https://s1.ax1x.com/2023/07/04/pCs3Arn.png" alt="pCs3Arn.png"></p></li></ul></li><li><p>例5</p><ul><li><p>此时有两层循环但是内层循环的次数不由外层循环的值确定，此时可以看做两个单独的循环，总次数即为此两次循环的积，选C</p></li><li><p><img src="https://s1.ax1x.com/2023/07/04/pCsKsln.png" alt="pCsKsln.png"></p></li></ul></li><li><p>例6</p><ul><li><p>将表达式简化后写出规律，i=0时，sum=1；i=1，sum=1+2，i=2，sum=1+2+3，则i=k时，sum=(1+k)k/2=n，此时选B</p></li><li><p><img src="https://s1.ax1x.com/2023/07/04/pCslT6s.png" alt="pCslT6s.png"></p></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第一章-绪论&quot;&gt;&lt;a href=&quot;#数据结构第一章-绪论&quot; class=&quot;headerlink&quot; title=&quot;数据结构第一章 绪论&quot;&gt;&lt;/a&gt;数据结构第一章 绪论&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第一章绪论的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hello_world</title>
    <link href="http://example.com/2024/08/10/hello-world/"/>
    <id>http://example.com/2024/08/10/hello-world/</id>
    <published>2024-08-09T20:09:40.000Z</published>
    <updated>2024-08-11T08:09:00.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新阶段的第一篇博客"><a href="#新阶段的第一篇博客" class="headerlink" title="新阶段的第一篇博客"></a>新阶段的第一篇博客</h1><span id="more"></span><p>新的时期开始了！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;新阶段的第一篇博客&quot;&gt;&lt;a href=&quot;#新阶段的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;新阶段的第一篇博客&quot;&gt;&lt;/a&gt;新阶段的第一篇博客&lt;/h1&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="说明" scheme="http://example.com/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
</feed>
