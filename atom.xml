<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懷仁堂</title>
  
  <subtitle>Studying and Recording</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-11T10:02:23.210Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Shamoke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构第二章-线性表</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2024-08-11T09:01:02.000Z</published>
    <updated>2024-08-11T10:02:23.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构第二章-线性表"><a href="#数据结构第二章-线性表" class="headerlink" title="数据结构第二章 线性表"></a>数据结构第二章 线性表</h2><blockquote><p>计算机学科基础：数据结构第二章线性表的学习笔记</p></blockquote><span id="more"></span><h3 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1.线性表的定义"></a>1.线性表的定义</h3><ul><li><p>①定义：具有<u>相同数据类型</u>的n个<u>数据元素</u>的<u>有限序列</u>，<strong>线性表是一种逻辑结构，表示元素之间一对一的相邻关系</strong></p></li><li><p>②特点：<strong>表中的元素在逻辑上相邻，具有逻辑上的顺序性，有其先后次序，每个元素只有唯一的前驱元素</strong></p></li></ul><h3 id="2-顺序表（线性表的顺序存储结构✪）"><a href="#2-顺序表（线性表的顺序存储结构✪）" class="headerlink" title="2.顺序表（线性表的顺序存储结构✪）"></a>2.顺序表（线性表的顺序存储结构✪）</h3><ul><li><p>①定义：<strong>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素</strong><br><strong>从而使得逻辑上相邻的两个元素在物理位置上也相邻</strong></p></li><li><p>②特点</p><ul><li>顺序表中元素的逻辑顺序与其物理顺序相同</li><li>顺序表中的任意一个数据元素都可以<strong>随机存取</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li><li>顺序表的存储密度高，每个结点只存储数据元素。</li><li><strong>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</strong></li><li><strong>n个元素的顺序表可插入的位置有n+1个，移动次数总数为：n(n+1)/2</strong><br><strong>平均移动次数为：n/2</strong></li><li><strong>n个元素的顺序表删除元素时，平均移动次数为：(n-1)/2</strong></li><li><strong>n个元素的顺序表顺序查找的平均比较/查找次数为：(n+1)/2</strong></li></ul></li><li><p>③代码实现（用<strong>数组</strong>来描述线性表的顺序存储结构♚）</p><ul><li><p>顺序表的定义</p><ul><li><p>静态分配一维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50 <span class="comment">//定义顺序表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//对顺序表进行初始化 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>动态分配一维数组（存储数组的空间使用malloc函数进行动态分配）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> *data; <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line"><span class="type">int</span> MaxSize,length; <span class="comment">//数组的最大容量和当前顺序表的长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqLsit L;</span><br><span class="line">InitList(L); <span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="comment">//...向表中插入几个元素</span></span><br><span class="line">    IncreaseSize(L,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span><span class="comment">//使用动态分配方法的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span><span class="comment">//为数组分配新的空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L.data;<span class="comment">//申请一个新指针</span></span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize=L.Maxsize+len;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>顺序表的插入操作（平均时间复杂度：O(n)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span><span class="comment">//顺序表的插入，指定位置，插入元素 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L.length&gt;=MaxSize)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>顺序表的删除操作（平均时间复杂度：O(n)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//顺序表的删除，删除指定位置的元素，并传出此元素 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)</span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>顺序表的按值查找位置 （平均时间复杂度：O(n)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SqList L,<span class="type">int</span> e)</span><span class="comment">//按值查号，返回该第一个等于值的位置 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//查到了则返回其位序</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>顺序表的按位查找元素 （平均时间复杂度：O(1)，此时为随机访问）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Get</span><span class="params">(SqList L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//按位查找，返回在位置i上的元素e </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-链表（线性表的链式存储结构✪）"><a href="#3-链表（线性表的链式存储结构✪）" class="headerlink" title="3.链表（线性表的链式存储结构✪）"></a>3.链表（线性表的链式存储结构✪）</h3><ul><li><p>①定义：<strong>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。</strong><br><strong>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</strong></p></li><li><p>②特点</p><ul><li>链式存储线性表时，不需要使用地址连续的存储单元，不要求逻辑上相邻的元素在物理上也相邻</li><li>插入和删除元素不需要移动元素，只需要修改指针。</li><li>单链表附加指针域，也存在浪费存储空间的缺点。</li><li>由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，<br>即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。</li><li><strong>设一个有序的单链表中有n个结点，现要求插入一个新节点后使得单链表仍然保持有序，则该操作的时间复杂度为O(n)</strong></li></ul></li><li><p>③代码实现（♚）</p><ul><li><p>单链表的定义</p><ul><li><p>单链表的结点由数据域（data，存放数据元素）和指针域（next，存放其后继结点的地址）组成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList; <span class="comment">//别名，第一个强调它是一个结点，第二个强调它是一个链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：要表示一个单链表，只需声明一个头指针L，指向单链表的第一个结点。</span></span><br><span class="line"><span class="comment">// LNode *L;或 LinkList L;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>初始化单链表</p><ul><li><p>带头结点的单链表（头指针指向头结点）</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaMWPx.png" alt="pCaMWPx.png"></li></ul></li><li><p>为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点<br>头结点的数据域不带任何信息，指针域指向线性表的第一个<strong>数据结点</strong>（区分第一个结点和第一个数据结点）</p></li><li><p>头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点<br>而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p></li><li><p>引入头结点的优点</p><ul><li><strong>对于插入或删除第一个数据结点的操作，由于第一个数据结点的位置被存放在头结点的指针域中，</strong><br><strong>因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</strong></li><li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空）<br>因此空表和非空表的处理也就得到了统一。</li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//初始化单链表 </span></span><br><span class="line">&#123;</span><br><span class="line">L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//分配一个头结点 </span></span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>不带头结点的单链表 （头指针指向第一个数据结点）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">L=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>建立单链表</p><ul><li><p>使用头插法建立单链表（<strong>时间复杂度O(n)</strong>）</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCa8TUJ.png" alt="pCa8TUJ.png"></li></ul></li><li><p>从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头</p></li><li><p>读入数据的顺序与生成的链表中的元素的顺序是相反的</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//头插法建立单链表,可以用于实现逆置 </span></span><br><span class="line">&#123;</span><br><span class="line">LNode *s;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建头结点</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//初始为空链表</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建新结点</span></span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=s;  <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用尾插法建立单链表（<strong>时间复杂度O(n)</strong>）</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCa8jKK.png" alt="pCa8jKK.png"></li></ul></li><li><p>该方法将新结点插入到当前链表的表尾，需要增加一个尾指针r，使其始终指向当前链表的尾结点</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TaliInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//尾插法建立单链表 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">LNode *s,*r=L;<span class="comment">//尾插法需要建立一个尾指针r,刚开始都指向头结点 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">r-&gt;next=s;</span><br><span class="line">r=s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">&#125; </span><br><span class="line">r-&gt;next=<span class="literal">NULL</span>;<span class="comment">//尾结点指针置空</span></span><br><span class="line"><span class="keyword">return</span> L; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单链表按序号查找结点 （<strong>时间复杂度O(n)</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span><span class="comment">//循环单链表找到第i个位置的指针 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//若i无效，返回NULL</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//相当于把头结点看作是0号位置</span></span><br><span class="line">LNode *p=L;<span class="comment">//刚开始P指向头结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单链表按值查找节点（<strong>时间复杂度O(n)</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,<span class="type">int</span> e)</span><span class="comment">//按值查找结点 </span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p=L-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)<span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line"> p=p-&gt;next;</span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">//找到后返回该结点的指针，如果链表中没有该值将返回空值 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>单链表的插入结点操作</p><ul><li><p>指定的结点后插操作</p><ul><li><p>查找待插入位置的前驱结点的时间复杂度为O(n)，在给定的结点后面插入新结点的时间复杂度为O(1)</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaJDYj.png" alt="pCaJDYj.png"></li></ul></li><li><p>插入结点操作将值为×的新结点插入到单链表的第i个位置上。先检查插入位置的合法性<br>然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点</p></li><li><p>算法首先调用按序号查找算法GetElem（L，i-1），查找第i-1个结点。<br>假设返回的第i-1个结点为p，然后令新结点s的指针域指向p的后继结点，再令结点p的指针域指向新插入的结点s</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找插入位置的前驱结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertNext</span><span class="params">(LNode *p,<span class="type">int</span> e)</span><span class="comment">//指定结点的后插操作,需要找到其前驱结点,此时的p是指向待插入位置的前驱结点的指针  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=p-&gt;next; </span><br><span class="line">p-&gt;next=s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>指定结点的前插操作</p><ul><li><p><strong>查找待插入位置的结点的时间复杂度为O(n)，在给定的结点前面插入新结点的时间复杂度为O(1)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPrior</span><span class="params">(LNode *p,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">s-&gt;next=p-&gt;next; </span><br><span class="line">p-&gt;next=s;</span><br><span class="line">s-&gt;data=p-&gt;data;  <span class="comment">//交换了数据域 </span></span><br><span class="line">p-&gt;data=e; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单链表的删除结点操作</p><ul><li><p>寻找待删除结点的前驱结点，再执行相关删除操作</p><ul><li><p>查找待删除位置的前驱结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p></li><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaYsED.png" alt="pCaYsED.png"></li></ul></li><li><p>先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//删除第i个位置的元素，并用e返回删除元素的值,需要找到前驱结点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *p=GetElem(L,i<span class="number">-1</span>);<span class="comment">//循环单链表找到第i-1个位置的指针</span></span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *q=p-&gt;next;<span class="comment">//新创建一个指针，并使该指针指向当前欲删除的结点 </span></span><br><span class="line">e=q-&gt;data;</span><br><span class="line">p-&gt;next=q-&gt;next;<span class="comment">//修改前驱结点的指针域使其指向待删除结点的下一个结点,将*q结点从链中断开 </span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放结点的存储空间 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>寻找待删除结点，再执行相关删除操作</p><ul><li><p>查找待删除位置的结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p></li><li><p>删除结点P的操作可用删除P的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteNext</span><span class="params">(LNode *p,<span class="type">int</span> &amp;e)</span><span class="comment">//删除需删除结点的后继结点，但是此时由于该原本该删除的结点的数据域和指针域已经被实际删除的结点的值覆盖，因此相当于删除了需删除的结点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">LNode *q=p-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">p-&gt;data=q-&gt;data;</span><br><span class="line">p-&gt;next=q-&gt;next</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>单链表的求表长操作<strong>（时间复杂度为O(n)）</strong></p><ul><li><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，<br>为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span><span class="comment">//求表长 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">LNode *p=L-&gt;next; <span class="comment">//创建一个指针指向第一个数据结点</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="4-双链表（主要考察选择题✪）"><a href="#4-双链表（主要考察选择题✪）" class="headerlink" title="4.双链表（主要考察选择题✪）"></a>4.双链表（主要考察选择题✪）</h3><ul><li><p>①定义</p><ul><li>双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，<br>在指针已经指向相应结点的情况下，插入和删除的时间复杂度为O(1)</li><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCatOFe.png" alt="pCatOFe.png"></li></ul></li></ul></li><li><p>②代码实现</p><ul><li><p>双链表的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;; DNode,*DLinkList;</span><br></pre></td></tr></table></figure></li><li><p>双链表的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitDLink</span><span class="params">(DLinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">L-&gt;prior=<span class="literal">NULL</span>;<span class="comment">//头结点的前驱指针永远指向NULL </span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>双链表的插入操作</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCaUsET.png" alt="pCaUsET.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(DNode *p,DNode *s)</span><span class="comment">//在i位置上的p节点之后插入结点s，数值为e </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">s-&gt;next=p-&gt;next; <span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">p-&gt;next-&gt;prior=s;</span><br><span class="line">s-&gt;prior=p;  <span class="comment">//2</span></span><br><span class="line">p-&gt;next=s;  <span class="comment">//3</span></span><br><span class="line">p-&gt;data=e; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; <span class="comment">//1和2步必须在第4步之前，否则p的后继结点的指针就会丢掉，导致插入失败</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>双链表的删除操作</p><ul><li><p>图片</p><ul><li><img src="https://s1.ax1x.com/2023/06/27/pCadQTf.png" alt="pCadQTf.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(DNode *p)</span><span class="comment">//删除p结点的后继结点q </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">DNode *q=p-&gt;next; <span class="comment">//找到p的后继结点q </span></span><br><span class="line"><span class="keyword">if</span>(q==<span class="literal">NULL</span>)<span class="comment">//p结点没有后继 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p-&gt;next=q-&gt;next; </span><br><span class="line"><span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">q-&gt;next-&gt;prior=p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="5-循环链表（主要考察选择题✪）"><a href="#5-循环链表（主要考察选择题✪）" class="headerlink" title="5.循环链表（主要考察选择题✪）"></a>5.循环链表（主要考察选择题✪）</h3><ul><li><p>①循环单链表</p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCawDbt.png" alt="pCawDbt.png"></li></ul></li><li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li><li>在循环单链表中，表尾结点r的next域指向L，故表中没有指针域为NULL的结点，<br>因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</li><li>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表</li><li>有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。<ul><li>其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，</li><li>而若设的是尾指针r，r-&gt;next即为头指针，对在表头或表尾插入元素都只需要O($1$)的时间复杂度。</li></ul></li></ul></li><li><p>②循环双链表</p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCawbPU.png" alt="pCawbPU.png"></li></ul></li><li>循环双链表中，头结点的前指针指向表尾节点，判空的条件是头结点的前后指针域都等于头结点</li><li>循环双链表是有助于删除第一个结点、删除最后一个结点，在第一个结点前插入一个结点，在最后一个结点后添加一个结点<ul><li>选A、C，如果是循环单链表，没办法处理删除最后一个结点（无法快速找到最后一个结点的前驱结点）</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsd3sU.png" alt="pCsd3sU.png"></li></ul></li></ul></li></ul><h3 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h3><ul><li><p><strong>静态链表借助数组来描述线性表的<u>链式存储结构</u>，也有指针域和数据域</strong></p><ul><li>图片<ul><li><img src="https://s1.ax1x.com/2023/06/27/pCa0zlQ.png" alt="pCa0zlQ.png"></li></ul></li></ul></li><li><p>指针表示下一个元素的数组下标（游标），静态链表也需要事先分配一块连续的内存空间。</p></li><li><p>其插入和删除不需要移动元素，只需要修改指针。</p></li><li><p>以next==-1作为结束的标志。</p></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-顺序表和链表的比较（✪）"><a href="#7-顺序表和链表的比较（✪）" class="headerlink" title="7.顺序表和链表的比较（✪）"></a>7.顺序表和链表的比较（✪）</h3><ul><li>1.存取（读写）方式<ul><li>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。</li><li>例如在第i个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。</li></ul></li><li>2.逻辑结构与物理结构<ul><li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。</li><li>而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li></ul></li><li>3.查找、插入和删除操作<ul><li>对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)<br>顺序表有序时，可采用折半查找，此时的时间复杂度为O($log_2n$).</li><li>对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)<br>而链表的平均时间复杂度为O(n)</li><li>顺序表的插入、删除操作，平均需要移动半个表长的元素。<br>链表的插入、删除操作，只需修改相关结点的指针域即可。</li><li>由于链表的每个结点都带有指针域，故而存储密度不够大。</li></ul></li><li>4.空间分配<ul><li>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，<br>因此需要预先分配足够大的存储空间。<ul><li>预先分配过大，可能会导致顺序表后部大量闲置；</li><li>预先分配过小，又会造成溢出。</li></ul></li><li>动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，<br>而且若内存中没有更大块的连续存储空间，则会导致分配失败。</li><li>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</li></ul></li><li>如何选取存储结构<ul><li>1.基于存储的考虑<ul><li>难以估计线性表的长度或存储规模时，不宜采用顺序表</li><li>链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</li></ul></li><li>2.基于运算的考虑<ul><li>在顺序表中按序访问的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n),<br>因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</li><li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的</li><li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</li></ul></li><li>3.基于环境的考虑<ul><li>顺序表容易实现，任何高级语言中都有数组类型，链表的操作是基于指针的，<br>相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</li><li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数据结构第二章-线性表&quot;&gt;&lt;a href=&quot;#数据结构第二章-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构第二章 线性表&quot;&gt;&lt;/a&gt;数据结构第二章 线性表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第二章线性表的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第一章-绪论</title>
    <link href="http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
    <id>http://example.com/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</id>
    <published>2024-08-11T08:08:11.000Z</published>
    <updated>2024-08-11T09:40:23.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构第一章-绪论"><a href="#数据结构第一章-绪论" class="headerlink" title="数据结构第一章 绪论"></a>数据结构第一章 绪论</h1><blockquote><p>计算机学科基础：数据结构第一章绪论的学习笔记</p></blockquote><span id="more"></span><h2 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1.数据结构的基本概念"></a>1.数据结构的基本概念</h2><ul><li>数据</li><li>数据元素：<u>数据的基本单位</u>，由若干个数据项组成<br><strong>数据项是不可分割的最小独立数据单位</strong></li><li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集</li><li>数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称<ul><li>原子类型：其值不可再分的数据类型。（如bool、int）</li><li>结构类型：其值可以再分解为若干成分（分量）的数据类型。(如结构体)</li><li><strong>抽象数据类型ADT</strong>：抽象数据组织及与之相关的操作<br>描述了数据的逻辑结构和抽象运算，定义了一个完整的数据结构，如线性表、栈、队列、树、图等）。</li></ul></li><li>数据结构<ul><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)</li><li>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</li><li>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，<br>而算法的实现依赖于所采用的存储结构。</li></ul></li></ul><h2 id="2-数据结构的三要素"><a href="#2-数据结构的三要素" class="headerlink" title="2.数据结构的三要素"></a>2.数据结构的三要素</h2><ul><li>数据的逻辑结构：数据元素之间的逻辑关系，<strong>数据的逻辑结构独立于其存储结构</strong><ul><li>线性结构（数据元素之间只存在一对一的关系）<ul><li>一般线性表</li><li>受限线性表：栈和队列、串</li><li>线性表推广：数组</li></ul></li><li>非线性结构<ul><li>集合 （结构中的数据元素之间除“同属一个集合外”，别无其他关系）</li><li>树形结构：一般树、二叉树（数据元素之间存在一对多的关系）</li><li>图状结构：有向图、无向图（数据元素之间存在多对多的关系）</li></ul></li><li>概念型的例题<ul><li>此题选C，逻辑结构均是线性结构</li><li><img src="https://s1.ax1x.com/2023/07/04/pCs0g2t.png" alt="pCs0g2t.png"></li></ul></li></ul></li><li>数据的存储结构：存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。<br>包括数据元素的表示和关系的表示（<strong>存储数据时，不仅要存储各数据元素的值，也要存储数据元素之间的关系</strong>）<ul><li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中（如顺序表）<br>元素之间的关系由存储单元的邻接关系来体现。<ul><li>其优点是可以实现随机存取，每个元素占用最少的存储空间</li><li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li></ul></li><li>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，<br>借助指示元素存储地址的指针来表示元素之间的逻辑关系<ul><li>链式存储时，链式存储时各个不同结点的存储空间可以不连续，但结点内的存储单元地址一定连续</li><li>链式存储结构比顺序存储结构更能方便地表示各种逻辑结构</li><li>其优点是不会出现碎片现象，能充分利用所有存储单元</li><li>缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li></ul></li><li>索引存储：在存储元素信息的同时，还建立附加的索引表。<br>索引表中的每项称为索引项，索引项的一般形式是(关键字，地址)。<ul><li>其优点是检索速度快：缺点是附加的索引表额外占用存储空间。</li><li>增加和删除数据时也要修改索引表，因而会花费较多的时间。</li></ul></li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hsh)存储。<ul><li>其优点是检索、增加和删除结点的操作都很快</li><li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li></ul></li></ul></li><li>数据的运算：施加在数据上的运算包括运算的定义和实现。<ul><li>运算的定义是针对逻辑结构的，指出运算的功能</li><li>运算的实现是针对存储结构的，指出运算的具体操作步骤。</li><li><strong>不是每种数据结构都具备三种基本运算：插入、删除和查找</strong><br><strong>如栈和队列无法查找，二维数组无法删除</strong></li></ul></li></ul><h2 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h2><ul><li>算法的概念：<strong>对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li><li>五个重要特性<ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算<u>执行有限次</u>来实现。</li><li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li></ul></li><li>四个目标<ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，<br>这两者都与问题的规模有关。</li></ul></li></ul><h2 id="4-算法效率的度量（✪）"><a href="#4-算法效率的度量（✪）" class="headerlink" title="4.算法效率的度量（✪）"></a>4.算法效率的度量（✪）</h2><ul><li><p>时间复杂度</p><ul><li>一个语句的频度是指该语句在算法中<u>被重复执行的次数</u>。算法中所有语句的频度之和记为T(n)，<br><u>它是该算法问题规模n的函数</u>，时间复杂度主要分析T(n)的<u>数量级</u>，<strong>执行时间与时间复杂度的值成正比</strong>。</li><li>算法中基本运算（<strong>最深层循环内的语句</strong>）的频度与T(n)同数量级，<br><strong>因此通常采用算法中基本运算的频度f(n)来分析时间复杂度</strong>，$T ( n ) = O ( f ( n ) )$<ul><li>如此题中，问题规模始终都是n，执行时间与时间复杂度的值成正比，选C<ul><li><img src="https://s1.ax1x.com/2023/07/04/pCse6aQ.png" alt="pCse6aQ.png"></li></ul></li><li>此题可以反映时间复杂度是看问题规模的数量级（即看最高阶，抓大头选B）<ul><li><img src="https://s1.ax1x.com/2023/07/04/pCsKhY4.png" alt="pCsKhY4.png"></li></ul></li><li>但是有两个变量的话就不一样了，如此题选C<ul><li><img src="https://s1.ax1x.com/2023/08/14/pPMMWOs.png" alt="pPMMWOs.png"></li></ul></li></ul></li><li><strong>算法的时间复杂度不仅依赖于问题的规模，也取决于待输入数据的性质（如输入数据元素的初始状态)</strong></li></ul></li><li><p>空间复杂度：算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。</p></li><li><p>关于时间复杂度的例题（♚）</p><ul><li>步骤：首先确定循环中变化的值，之后跟据其变化情况列出其经过每轮循环之后的值<br>（先用实数，最后写出规律式（含频数k）），之后并与问题规模n组成不等式，最后求出k关于n的表达式</li><li>例1<ul><li>此时写出i的变化规律：$1,2,4…2^{k},2^{k}=n,k=log_{2}n$</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsnQ0O.png" alt="pCsnQ0O.png"></li></ul></li><li>例2<ul><li>此时写出x的变化规律：$4,8,16…2^{k+1},2^{k+1}&lt;n/2,k=log_{2}n/2-1=log_{2}n-2$，此时即选A</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsu8bT.png" alt="pCsu8bT.png"></li></ul></li><li>例3<ul><li>此时有内外两层的循环，且外层循环的值决定了内层循环的次数，应该以外层为基准来看</li><li>外层执行第一轮(i=1)：最内层语句执行2次，外层执行第二轮(i=2)，最内层语句执行4次，<br>外层执行第三轮(i=3)，最内层语句执行6次，</li><li>此时有规律得（外层执行第n轮时，最内层语句执行2n次）总次数即为相加（求和公式(2+2n)*n/2)=n(n+1)）</li><li><img src="https://s1.ax1x.com/2023/07/04/pCsKneK.png" alt="pCsKneK.png"></li></ul></li><li><p>例4</p><ul><li><p>先看外层的循环取值</p></li><li><p>此时有$i=1,2,4……2^{k}&lt;n ，此时对应的内层总次数相加为1+2+……2^{k}=2^{k+1}-1&lt;2n$，时间复杂度为n</p></li><li><p><img src="https://s1.ax1x.com/2023/07/04/pCs3Arn.png" alt="pCs3Arn.png"></p></li></ul></li><li><p>例5</p><ul><li><p>此时有两层循环但是内层循环的次数不由外层循环的值确定，此时可以看做两个单独的循环，总次数即为此两次循环的积，选C</p></li><li><p><img src="https://s1.ax1x.com/2023/07/04/pCsKsln.png" alt="pCsKsln.png"></p></li></ul></li><li><p>例6</p><ul><li><p>将表达式简化后写出规律，i=0时，sum=1；i=1，sum=1+2，i=2，sum=1+2+3，则i=k时，sum=(1+k)k/2=n，此时选B</p></li><li><p><img src="https://s1.ax1x.com/2023/07/04/pCslT6s.png" alt="pCslT6s.png"></p></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构第一章-绪论&quot;&gt;&lt;a href=&quot;#数据结构第一章-绪论&quot; class=&quot;headerlink&quot; title=&quot;数据结构第一章 绪论&quot;&gt;&lt;/a&gt;数据结构第一章 绪论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;计算机学科基础：数据结构第一章绪论的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机基础学习笔记" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hello_world</title>
    <link href="http://example.com/2024/08/10/hello-world/"/>
    <id>http://example.com/2024/08/10/hello-world/</id>
    <published>2024-08-09T20:09:40.000Z</published>
    <updated>2024-08-11T08:09:00.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新阶段的第一篇博客"><a href="#新阶段的第一篇博客" class="headerlink" title="新阶段的第一篇博客"></a>新阶段的第一篇博客</h1><span id="more"></span><p>新的时期开始了！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;新阶段的第一篇博客&quot;&gt;&lt;a href=&quot;#新阶段的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;新阶段的第一篇博客&quot;&gt;&lt;/a&gt;新阶段的第一篇博客&lt;/h1&gt;</summary>
    
    
    
    <category term="日志" scheme="http://example.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="说明" scheme="http://example.com/tags/%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
</feed>
