<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello_world</title>
    <url>/2024/08/10/hello-world/</url>
    <content><![CDATA[<h1 id="新阶段的第一篇博客"><a href="#新阶段的第一篇博客" class="headerlink" title="新阶段的第一篇博客"></a>新阶段的第一篇博客</h1><span id="more"></span>
<p>新的时期开始了！</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>说明</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第八章-排序</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="数据结构第八章-排序"><a href="#数据结构第八章-排序" class="headerlink" title="数据结构第八章-排序"></a>数据结构第八章-排序</h2><blockquote>
<p>计算机学科基础：数据结构第八章排序的学习笔记</p>
</blockquote>
<h3 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1.排序的基本概念"></a>1.排序的基本概念</h3><ul>
<li>评价指标<ul>
<li>稳定性：关键字相同的元素经过排序后<strong>相对顺序</strong>是否会改变</li>
<li>时间复杂度、空间复杂度</li>
</ul>
</li>
<li>分类<ul>
<li>内部排序：数据都存放在内存中<ul>
<li>一般内部排序算法在执行过程中都需要进行比较和移动两种操作（但是基数排序不基于比较）</li>
</ul>
</li>
<li>外部排序：数据无法全部同时存放在内存中</li>
</ul>
</li>
</ul>
<h3 id="2-插入排序（✪）"><a href="#2-插入排序（✪）" class="headerlink" title="2.插入排序（✪）"></a>2.插入排序（✪）</h3><ul>
<li><p>直接插入排序</p>
<ul>
<li><p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>
</li>
<li><p>流程</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjN6gJ.png" alt="pCjN6gJ.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;  <span class="comment">//每次都比较该位置的前驱，看是否小于前驱</span></span><br><span class="line">            temp=A[i];  <span class="comment">// temp暂存</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;A[j]&gt;temp;--j)<span class="comment">//检查前面排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j]; <span class="comment">//所有大于temp的元素都向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接插入排序的性能分析</p>
<ul>
<li>空间效率：空间复杂度为O(1)</li>
<li>时间复杂度：主要来自对比关键字、移动元素，若有n个元素，则需要n-1趟处理<ul>
<li>最好时间复杂度为O(n)（全部顺序）<ul>
<li>最好的情况下做 n-1次关键字的比较，也就是执行n-1趟，每趟只比较一次，此时不需要移动元素</li>
</ul>
</li>
<li>最坏/平均时间复杂度为O($n^{2}$) (全部逆序)<ul>
<li>直接插入排序在最坏的情况下做 n(n-1)/2次关键字的比较，此时移动次数也达到最大</li>
</ul>
</li>
</ul>
</li>
<li>稳定性：为稳定的排序算法</li>
<li>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>折半插入排序</p>
<ul>
<li><p>算法思想：先用折半查找找到应该插入的位置，再移动元素</p>
<ul>
<li><p>当low&gt;high时折半查找停止，应将[Iow,i-1]内的元素全部右移，并将A[0]复制到Iow所指位置</p>
</li>
<li><p>当A[mid]==A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置</p>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>如此时向前插入8位置的55，需要在1-7个位置之间进行折半查找<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCOdDEV.png" alt="pCOdDEV.png"></li>
</ul>
</li>
<li>此时通过折半查找，找到其应该插入的位置为5，则将6-7的元素统一后移一位，并在5位置插入55<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCOdc34.png" alt="pCOdc34.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Void <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>,i&lt;=n;i++)&#123; 	<span class="comment">//依次将A[2]到A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i]; 	<span class="comment">//A[0]作为暂存位</span></span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>; 	<span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;	<span class="comment">//折半查找</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>; <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>; <span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span> <span class="comment">//查找右半子表</span></span><br><span class="line">            	<span class="comment">//注意：一直到Iow&gt;high时才停止折半查找。当mid所指元素等于当前元素时，</span></span><br><span class="line">				<span class="comment">//应继续令Iow=mid+1,以保证“稳定性”。最终应将当前元素插入到Iow所指位置(即high+1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;i&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];	<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];    	<span class="comment">//插入操作</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>折半插入排序的性能分析</p>
<ul>
<li>折半插入排序的比较次数与原始状态无关，仅取决于n</li>
<li><p>折半插入排序仅减少了比较元素的次数，约为O($nlog_{2}{n}$)</p>
</li>
<li><p>折半插入排序没有改变元素的移动次数，时间复杂度仍然是O($n^{2}$)，依赖于原始状态</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>希尔排序（缩小增量排序）</p>
<ul>
<li><p>算法思想：先追求表中元素部分有序，再逐渐逼近全局有序</p>
<ul>
<li>设置增量为d的子表，把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序。<br>之后进行增量的缩小再进行一次这样的排序，当整个表中的呈现基本有序时，再对全体记录进行一次直接插入排序</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO0aT0.png" alt="pCO0aT0.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>第一趟排序之后<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO0rpF.png" alt="pCO0rpF.png"></li>
</ul>
</li>
<li>第二趟排序之后<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO07Xd.png" alt="pCO07Xd.png"></li>
</ul>
</li>
<li>第三趟排序之后<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO0jtf.png" alt="pCO0jtf.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>) <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123; <span class="comment">//若前序较大，需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];	<span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j]; <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>]		<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序的性能分析</p>
<ul>
<li>空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)</li>
<li>时间效率：当n在某个特定范围时，希尔排序的时间复杂度约为O($n^{1.3}$)，在最坏情况下希尔排序的时间复杂度为O($n^{2}$)</li>
<li>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，希尔排序是一种不稳定的排序方法。</li>
<li>适用性：希尔排序算法<strong>仅适用于线性表为顺序存储的情况</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-交换排序（✪）"><a href="#3-交换排序（✪）" class="headerlink" title="3.交换排序（✪）"></a>3.交换排序（✪）</h3><ul>
<li><p>冒泡排序</p>
<ul>
<li>算法思想：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置<ul>
<li>从后往前（或从前往后）两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换它们，直到序列比较完。<br>称这样过程为“一趟”冒泡排序。</li>
<li>下一趟冒泡时，前一趟确定的最小元素不再参与比较，<br>每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置</li>
<li>最多做n-1趟冒泡就能把所有元素排好序。</li>
</ul>
</li>
<li>流程<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjBBU1.png" alt="pCjBBU1.png"></li>
</ul>
</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO6peH.png" alt="pCO6peH.png"></li>
</ul>
</li>
<li>冒泡排序的性能分析<ul>
<li>空间复杂度：仅使用了常数个辅助单元，因而空间复杂度为O(1).</li>
<li>时间复杂度<ul>
<li>当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换）从而直接跳出循环，<br>比较次数为n-1，移动次数为0，从而最好情况下的时间复杂度为O($n$)</li>
<li>当初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较，<br>而且每次比较后都必须移动元素3次来交换元素位置，此时<ul>
<li>比较次数：$\frac{n(n-1)}{2}$，移动次数：$\frac{3n(n-1)}{2}$</li>
<li>最坏情况下的时间复杂度O($n^{2}$)</li>
</ul>
</li>
<li>平均时间复杂度为O($n^{2}$)</li>
</ul>
</li>
<li>稳定性：冒泡排序是一种稳定的排序方法</li>
<li>适用于顺序表和链表</li>
<li>快速排序一趟会确定一个元素最终的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li><p>算法思想：分治法</p>
<ul>
<li>在待排序表L[1..n]中任取一个元素pivot作为枢轴(或基准，<strong>通常取首元素</strong>)</li>
<li>通过一趟排序将待排序表划分为独立的两部分L[1……k-1]和L[k+1……n]，使得L[1……k-1]中的所有元素小于pivot，<br>L[k+1……n]中的所有元素大于等于pivot，则<strong>pivot放在了其最终位置L(k)上，这个过程称为一次“划分”</strong>。</li>
<li>然后分别<strong>递归地对两个子表重复上述过程</strong>，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</li>
</ul>
</li>
<li><p>代码实现（掌握）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序（表长为n，初始的low为表头0，high为表尾n-1）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">()</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;	<span class="comment">//当low=high时，此时递归跳出</span></span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low,high); <span class="comment">//进行一次分治划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);	<span class="comment">//划分左子表(上一次划分后返回的之前枢纽存放的最终位置的左边一位在划分左子表时作为&quot;high&quot;，low为当前递归工作栈的存放位置)</span></span><br><span class="line">        QuickSort(A,Pivotpos+<span class="number">1</span>,high);   <span class="comment">//划分右子表(上一层划分后返回的之前枢纽存放的最终位置的右边一位在划分右子表时作为&quot;low&quot;,high为当前递归工作栈的存放位置)</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];   <span class="comment">//将当前表中的low作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;	<span class="comment">//当low=high时，说明此轮的枢纽已经搜索到了最终的位置，跳出此轮枢纽的循环</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)  <span class="comment">//从后往前找到比枢纽更小的元素，将其移动到左边</span></span><br><span class="line">            --high;</span><br><span class="line">        A[low]=A[high];   <span class="comment">//在high位置上比枢纽小的元素移动到当前low的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)   <span class="comment">//从前往后找到比当前枢纽更大的元素，将其移动到右边</span></span><br><span class="line">            ++low;</span><br><span class="line">        A[high]=A[low];	  <span class="comment">//在low位置上比枢纽更大的元素移动到当前的high位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;     <span class="comment">//进行一次分治算法后，枢纽存放的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;       <span class="comment">//返回枢纽存放的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流程</p>
<ul>
<li>第一轮分治法时，递归工作栈中的low为0，high为7，此时将49作为枢纽，将high指针左移，找到比枢纽小的元素移动到low指针处，<br>之后又将low指针右移，找到比枢纽大的元素移动到high指针处。</li>
<li>互相进行以上操作，直到low=high时，此时就找到了枢纽元素的最终位置。并返回当前的枢纽指针位置，进行左子表的新一轮递归操作。<ul>
<li>初始情况<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCO5Bh4.png" alt="pCO5Bh4.png"></li>
</ul>
</li>
<li>第一趟递归操作<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjsLrD.png" alt="pCjsLrD.png"></li>
</ul>
</li>
</ul>
</li>
<li>第二轮分治法时，递归工作栈中的low为0，high为之前的枢纽位置3减1为2，此时选择27为枢纽进行操作<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCO5XE8.png" alt="pCO5XE8.png"></li>
</ul>
</li>
<li>到了处理右子表时，递归的工作栈中low为之前的枢纽3加1为4，high为7，此时选择76为枢纽进行操作<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOIm8J.png" alt="pCOIm8J.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>快速排序的性能分析</p>
<ul>
<li>算法表现主要取决于递归深度若每次“划分”越均匀，则递归深度越低。“划分”越不均匀，递归深度越深</li>
<li>空间复杂度：最好空间复杂度：O($log_{2}n$)，最坏空间复杂度：O($n$)</li>
<li><p>时间复杂度：</p>
<ul>
<li>最好时间复杂度：O($nlog_{2}n$)，每次选的枢轴元素都能将序列划分成均匀的两部分</li>
<li>最坏时间复杂度：O($n^{2}$​)，若序列原本就有序或逆序，则时空复杂度最高，可优化，尽量选择<br>可以把数据中分的枢轴元素。</li>
</ul>
</li>
<li><p>快速排序是所有内部排序算法中平均性能最优的算法</p>
</li>
<li>快速排序是一种不稳定的排序</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li>判断快速排序时速度最快和最慢的情况<ul>
<li>此时需要判断以枢纽为中心的两边所划分的元素个数是否平均，<br>小于枢纽的元素的个数和大于枢纽的元素的个数的比例越不平均，所耗时越多</li>
<li>速度最慢显然是D选项，均为有序排序时，速度最快时看大于和小于枢纽的数的比例，<br>A，C选项的比例1:1；B选项为5:1，<br>再从AC选项里面选择进行一趟快速排序（A：9,5,7,21,25,23,30；B:5,9,17,21,25,23,30）<br>此时A的左右子表都满足与新枢纽的比例为1:1，但是B的左右子表关于新枢纽的比例均为2:0，选A<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOHtTP.png" alt="pCOHtTP.png"></li>
</ul>
</li>
</ul>
</li>
<li>判断不可能是快速排序第2趟排序的结果的序列，利用快速排序一趟会确定一个元素最终的位置，<br>此时写出有序序列与选项作比较，此时只需要选项中有两个在相应位置上契合的元素即可<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOOeje.png" alt="pCOOeje.png"></li>
</ul>
</li>
<li>除了需要满足上面的条件，还需要满足此时有一个符合的元素位于边界<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOOo8K.png" alt="pCOOo8K.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-选择排序（✪）"><a href="#4-选择排序（✪）" class="headerlink" title="4.选择排序（✪）"></a>4.选择排序（✪）</h3><ul>
<li><p>简单选择排序</p>
<ul>
<li><p>算法思想：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列<br>每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;		<span class="comment">//一共进行n-1趟	</span></span><br><span class="line">        <span class="type">int</span> min=i;     <span class="comment">//记录最小元素的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;  <span class="comment">//在A[i……n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])		<span class="comment">//如果存在更小的元素，则更新最小元素的位置</span></span><br><span class="line">                min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">            swap(A[i],A[min]);   <span class="comment">//交换位置，此时该趟中最小的元素到了i位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单选择排序性能分析</p>
<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：O($n^{2}$)</li>
<li>无论有序、逆序、还是乱序，一定需要n-1趟处理</li>
<li>元素间比较的次数与序列的初始状态无关，始终是$n(n-1)/2$次，因此时间复杂度始终是O($n^{2}$)</li>
<li>简单选择排序是一种不稳定的排序算法</li>
<li>适用于顺序表和链表</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序</p>
<ul>
<li><p>堆（堆是用来排序的，他的查找效率很低）</p>
<ul>
<li><strong>从二叉树的任意结点出发到根的路径上所经过的所有结点序列按其关键字有序，则此二叉树是根</strong></li>
<li><p>大根堆与小根堆</p>
<ul>
<li><p>若${n}$个关键字序列${L[1 \ldots n]}$满足下面某一条性质, 则称为堆（Heap）</p>
<ul>
<li>若满足:${\mathrm{L}(\mathrm{i}) \geqslant \mathrm{L}(2 \mathrm{i})}$且${\mathrm{L}(\mathrm{i}) \geqslant \mathrm{L}(2 \mathrm{i}+1) (1 \leq i \leq n / 2)—}$大根堆（大顶堆）    </li>
<li>若满足:${\mathrm{L}(\mathrm{i}) \leqslant \mathrm{L}(2 \mathrm{i})}$且${\mathrm{L}(\mathrm{i}) \leqslant \mathrm{L}(2 \mathrm{i}+1) (1 \leq i \leq n / 2) —}$小根堆（小顶堆）</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCXeqsJ.png" alt="pCXeqsJ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>建立大根堆<ul>
<li>可以将堆看做是一个完全二叉树，大根堆就是根结点的关键字大于左右孩子结点，<br>此时可以对于一个给定的初始的序列建立大根堆，之后方便进行选择排序</li>
<li>把所有非终端结点都检查一遍，是否满足大根堆的要求，<br>如果不满足，则进行调整，在顺序存储的完全二叉树中, 非终端结点编号  $\mathbf{i} \leq\lfloor n / 2\rfloor$</li>
<li>从编号为$\lfloor n / 2\rfloor$的分支结点开始从后往前检查，检查当前结点是否满足根≥左、右，<br>若不满足，将当前结点与更大的一个孩子互换</li>
<li>之后依次这样处理前面序号的非终端结点，<br>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整(小元素不断“下坠”)</li>
<li>图片（注：初始序列为：（53,17,78,9,45,65,87,32），初始对$\lfloor n / 2\rfloor$位置开始检查，从后往前检查）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjcjZF.png" alt="pCjcjZF.png"></li>
</ul>
</li>
</ul>
</li>
<li>进行堆排序<ul>
<li>在建立大根堆完成之后，每一趟将堆顶关键字与待排序序列中的最后一个元素交换（将堆顶元素加入有序子序列）</li>
<li>并将待排序元素序列再次调整为大根堆(小元素不断“下坠”)</li>
<li>在经过n-1趟之后得到基于“大根堆”的堆排序的“递增序列”</li>
<li>图片<ul>
<li>此时已建立好堆排序，此时将堆顶元素87与最后一个元素9进行互换，87输出到最后位<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX1S74.png" alt="pCX1S74.png"></li>
</ul>
</li>
<li>互换之后，此时9在完全二叉树中破坏了大堆根，此时应该进行调整，使最小的元素坠入底端，9与78互换<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX1ZnO.png" alt="pCX1ZnO.png"></li>
</ul>
</li>
<li>互换之后，还需要使其与下一层更大的65进行互换<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX113t.png" alt="pCX113t.png"></li>
<li>此时互换后，重新形成了一个大根堆，如果继续进行下一趟排序的话，<br>此时已经变成有序序列的第8号元素所在的关键字87不参与排序，此时的len减一为7。78将输出，与7位置上的53互换<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX18jf.png" alt="pCX18jf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现（了解）</p>
<ul>
<li><p>建立大根堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;	<span class="comment">//从后向前调整所有的非终端结点</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以K为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k];   <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿关键字较大的根结点的子节点向下筛选，若超出原数组长度，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])	<span class="comment">//此时取关键字更大的其中子节点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])</span><br><span class="line">            <span class="keyword">break</span>;		<span class="comment">//此时根结点的值较大，则停止筛选</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[K]=A[i];  <span class="comment">//将被筛选中的结点调整到双亲结点上</span></span><br><span class="line">            k=i;	<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];    <span class="comment">//筛选完成后，被筛选的节点放入最终的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现根排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>	<span class="comment">//建立大根堆</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span><span class="comment">//将以k为根的子树调整大根堆</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;		<span class="comment">//堆排序的完整逻辑</span></span><br><span class="line">    BuildMaxHeap(A,len);	<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;		<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);	<span class="comment">//堆顶元素和堆底元素进行互换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);	<span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>堆的插入</p>
<ul>
<li>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。<br>新元素就这样一路“上升”，直到无法继续上升为止</li>
<li>删除时，被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止</li>
<li>向具有n个结点的堆中插入一个新元素的时间复杂度为O($log_{2}n$)，删除一个元素的时间复杂度为O($log_{2}n$)</li>
<li>例题<ul>
<li>按照插入的方法，逐个插入即可，此时选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCXhNlR.png" alt="pCXhNlR.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/25/pCXhU61.png" alt="pCXhU61.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序的性能分析</p>
<ul>
<li>空间效率: 仅使用了常数个辅助单元, 所以空间复杂度为${O(1)}$</li>
<li>时间效率: 建堆时间为${O(n)}$, 之后有${n-1}$次向下调整操作, 每次调整的时间复杂度为${O(h)}$,<br>故在最好、最坏和平均情况下, 堆排序的时间复杂度为${O\left(n \log _{2} n\right)}$</li>
<li>堆排序是一种不稳定的排序方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-归并排序和基数排序（✪）"><a href="#5-归并排序和基数排序（✪）" class="headerlink" title="5.归并排序和基数排序（✪）"></a>5.归并排序和基数排序（✪）</h3><ul>
<li><p>归并排序（可以作为外部排序）</p>
<ul>
<li><p>算法思想</p>
<ul>
<li>把两个或多个<strong>已经有序</strong>的序列合并成一个新的有序表</li>
<li>m路归并，每选出一个元素需要对比关键字m-1次</li>
<li>将两个各有N个元素的有序表合并成一个有序表，最少的比较次数是N次（一个表中的最小元素大于另一个表的最大元素时），<br>最多的比较次数是2N-1次（两个表中的元素依次间隔地比较时）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjPZh4.png" alt="pCjPZh4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>流程（在内部排序中一般选择二路归并）</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjPucR.png" alt="pCjPucR.png"></li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li>第一趟为2个一组，第二趟为4个一组，每组内部排序即可，选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjeUmj.png" alt="pCjeUmj.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现（了解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//定义辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并算法</span></span><br><span class="line">Void <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k]; 	<span class="comment">//将A中所有元素复制到辅助元素B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) <span class="comment">//此时有等于号的原因是使两个元素相等时，优先使用靠前的那一个（稳定性）</span></span><br><span class="line">            A[k]=B[i++];   <span class="comment">//将较小的复制到A的位置，之后前半部分的指针位加一</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[K]=B[j++];	<span class="comment">//将较大的复制到A的位置，之后后半部分的指针位加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) </span><br><span class="line">        A[k++]=B[i++]; <span class="comment">//若第一个辅助表没有检测完，则直接复制到原表的尾部</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=hige)</span><br><span class="line">         A[k++]=B[j++]; <span class="comment">//若第二个辅助表没有检测完，则直接复制到原表的尾部</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归的归并算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>; <span class="comment">//从序列的中间划分出子序列</span></span><br><span class="line">        MergeSort(A,low,mid);	<span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,high);	<span class="comment">//整体归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序的性能分析</p>
<ul>
<li>空间复杂度${=O(n)}$, 来自于辅助数组${\mathbf{B}}$</li>
<li>${\mathrm{n}}$个元素进行2路归并排序, 归并趟数${=\left\lceil\log _{2} n\right\rceil}$，每路归并时间复杂度为${O(n)}$, 则算法的时间复杂度为${O\left(n \log _{2} n\right)}$</li>
<li>归并排序是一种稳定的排序算法</li>
</ul>
</li>
</ul>
</li>
<li><p>基数排序</p>
<ul>
<li>算法思想<ul>
<li>基数排序不是基于比较的排序算法，是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法，<br>通常基于链式存储实现</li>
<li>最高位优先法（MSD）：按关键字位权重递减（先看最高位）；最低位优先法（LSD）：按关键字位权重递增（先看个位）</li>
<li>采用最低位优先法进行基数排序的流程<ul>
<li>将整个关键字拆分为d位(或“组”)</li>
<li>按照各个关键字位权重递增的次序(如：个、十、百)，做d趟“分配”和“收集”，<br>若当前处理的关键字位可能取得r个值，则需要建立r个队列</li>
<li>分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配耗时O(n)</li>
<li>收集：把各个队列中的结点依次出队并链接。一趟收集耗时O(r)</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>最低位优先法，分为三元组（个、十、百）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjAgoV.png" alt="pCjAgoV.png"></li>
</ul>
</li>
<li>进行第一趟的分配，将个位满足相应关键字位的元素入队（先进先出）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjAOJO.png" alt="pCjAOJO.png"></li>
</ul>
</li>
<li>进行第一趟收集，使这些元素依次出队<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjE9eI.png" alt="pCjE9eI.png"></li>
</ul>
</li>
<li>进行第二趟分配与第三趟分配，最终得到相应的结果</li>
</ul>
</li>
<li>基数排序的性能分析<ul>
<li>基数排序擅长解决的问题<ul>
<li>数据元素的关键字可以方便地拆分为d组，且d较小</li>
<li>每组关键字的取值范围不大，即”较小</li>
<li>数据元素个数n较大</li>
</ul>
</li>
<li>基数排序只能对int型进行排序，无法对float型以及double型进行排序</li>
<li>空间复杂度：取决于分组队列的情况，r个队列，空间复杂度为O(r)</li>
<li>时间复杂度：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，时间复杂度为O($d(n+r)$），<br>它与序列的初始状态无关。</li>
<li>基数排序是一种稳定的排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-各种内部排序算法的比较及应用（✪）"><a href="#6-各种内部排序算法的比较及应用（✪）" class="headerlink" title="6.各种内部排序算法的比较及应用（✪）"></a>6.各种内部排序算法的比较及应用（✪）</h3><ul>
<li>各种内部算法的比较<ul>
<li>时间复杂度分析<ul>
<li>平均时间复杂度为O($n^{2}$)：直接插入排序、折半插入排序、简单选择排序、冒泡排序<ul>
<li>直接插入排序、冒泡排序最好情况下的时间复杂度为：O($n$)（在基本有序的情况下）</li>
<li>简单选择排序与序列的初始状态无关</li>
</ul>
</li>
<li>平均时间复杂度为O($nlog_2n$)：快速排序、堆排序、归并排序<ul>
<li>快速排序的最坏时间复杂度为：O($n^{2}$)（在基本有序的情况下）</li>
<li>堆排序和归并排序的在最好、最坏和平均情况下, 堆排序的时间复杂度为：${O\left(n \log _{2} n\right)}$</li>
</ul>
</li>
<li>希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间</li>
<li>基数排序的时间复杂度取决于划分的组数d、组内的队列数r、元素数量n，时间复杂度为：O($d(n+r)$)</li>
</ul>
</li>
<li>空间复杂度分析<ul>
<li>空间复杂度为O($1$)：插入排序（直接插入、折半插入、希尔排序）、冒泡排序、选择排序（简单选择排序、堆排序）<br>仅需要借助常数个辅助空间</li>
<li>空间复杂度为O($log_2{n}$)：快速排序需要借助一个递归工作栈<ul>
<li>快速排序在最坏情况下的空间复杂度可能达到O($n$)</li>
</ul>
</li>
<li>空间复杂度为O($n$)：归并排序</li>
</ul>
</li>
<li>稳定性分析<ul>
<li>稳定的排序算法：直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序<ul>
<li>平均时间复杂度为O($nlog_2n$)的排序只有归并排序</li>
</ul>
</li>
<li>不稳定的排序算法：希尔排序、快速排序、选择排序（简单选择排序、堆排序）</li>
</ul>
</li>
<li>过程特征分析<ul>
<li>排序趟数与序列的原始状态的关系<ul>
<li><strong>趟数与原始序列状态无关：插入类、选择类的排序、基数排序</strong><ul>
<li>直接插入排序(每次固定插入一个元素)、简单选择排序(每次都选出一个最大/最小的元素) 均为n-1趟排序</li>
<li>基数排序：每趟都要进行分配和收集，排序趟数固定为d</li>
</ul>
</li>
<li><strong>趟数与原始序列状态有关：交换类的排序(冒泡排序、快速排序)</strong><ul>
<li>冒泡排序如果为顺序，只需要进行一趟排序（本趟无元素交换）；若为逆序需要进行n-1趟排序</li>
<li>快速排序若每趟的枢纽元素都能平均的划分两个子序列则需要的趟数最少，若原始序列有序，则需要的趟数最多</li>
</ul>
</li>
</ul>
</li>
<li>比较次数与序列的原始状态的关系<ul>
<li><strong>比较次数与序列的原始状态无关：折半插入排序、选择类的排序(简单选择排序、堆排序)</strong><ul>
<li>折半插入排序的比较次数仅取决于表中的元素个数n</li>
<li>简单选择排序的关键字比较次数恒为：n(n−1)/2次</li>
</ul>
</li>
<li><strong>比较次数与序列的原始状态有关：直接插入排序、希尔排序、冒泡排序、快速排序</strong><ul>
<li>直接插入排序最好只做n-1次关键字比较（顺序时），最坏做n(n−1)/2次关键字比较（逆序时）</li>
<li>冒泡排序顺序时比较次数为n-1次，逆序时比较次数为n(n−1)/2次</li>
</ul>
</li>
</ul>
</li>
<li>移动次数与序列的原始状态的关系<ul>
<li><strong>元素的移动次数与序列的原始状态无关：基数排序</strong></li>
<li>元素的移动次数与序列的原始状态有关：直接插入排序、折半排序、冒泡排序、快速排序、简单选择排序<ul>
<li>直接插入排序在顺序的情况下，不需要移动元素；若逆序需要移动大量元素</li>
<li>冒泡排序有序时不需要移动元素；若逆序时需要移动3n(n-1)/2次</li>
<li>快速排序若每趟的枢纽元素都能平均的划分两个子序列则需要的移动的次数少，<br>若原始序列有序，则需要移动的次数最多</li>
<li>简单选择排序在有序的情况下不需要移动元素</li>
</ul>
</li>
</ul>
</li>
<li>每趟排序结束后都至少能确定一个元素的最终位置的排序算法：冒泡排序、快速排序、简单选择排序、堆排序</li>
</ul>
</li>
</ul>
</li>
<li>内部排序算法的应用<ul>
<li>基于关键字个数n选择排序算法<ul>
<li>若n较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，<br>因而当记录本身信息量较大时，用简单选择排序较好。</li>
<li>若n较大，则应采用时间复杂度为O($nlog_2{n}$)的排序方法：快速排序、堆排序或归并排序。<br>快速排序被认为是目前基于比较的内部排序方法中最好的方法</li>
<li>当待排序的关键字随机分布时，快速排序的平均时间最短。<br>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。</li>
<li>若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li>
</ul>
</li>
<li>若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。</li>
<li>若要求排序稳定且时间复杂度为O($log_2{n}$)，则可选用归并排序。<ul>
<li>但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。<br>先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。</li>
</ul>
</li>
<li>在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，<br>因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要O($nlog_2{n}$)的时间。</li>
<li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。<ul>
<li>但是希尔排序和堆排序利用顺序存储的随机访问特性，如果将其换为链式存储结构其时间复杂度将增加</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-外部排序（✪）"><a href="#7-外部排序（✪）" class="headerlink" title="7.外部排序（✪）"></a>7.外部排序（✪）</h3><ul>
<li><p>外部排序的基本概念与方法</p>
<ul>
<li>外部排序的基本概念<ul>
<li>外部排序：数据元素太多，无法一次全部读入内存进行排序。</li>
<li>因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，<br>在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序。</li>
</ul>
</li>
<li>外部排序的方法<ul>
<li>外部排序通常采用归并排序法。它包括两个阶段：<ul>
<li>根据内存缓冲区大小，将外存上的文件分成若干长度为L的子文件，依次读入内存并利用内部排序方法对它们进行排序<br>并将排序后得到的有序子文件重新写回外存，<strong>称这些有序子文件为<u>归并段</u>或顺串</strong></li>
<li>对这些归并段在内存中进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。</li>
</ul>
</li>
<li>使用“归并排序”的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序</li>
<li>在内存中，归并后的对象顺序存放在输出缓冲区中，若缓冲区的对象存满，则将其顺序写到输出归并段中并清空缓冲区</li>
<li>若某个输入缓冲区中的对象在移动到输出缓冲区之后为空，则从其对应的输入归并段中再读取下一块，继续参加归并</li>
</ul>
</li>
<li>外部排序进行归并的流程<ul>
<li>内存读取外存的子文件进行内部排序，将排序好的有序子文件依次返回外层，这些有序子文件又称为归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjLMSf.png" alt="pCjLMSf.png"></li>
</ul>
</li>
<li>经过16次读和16次写之后，由于经过了内存中的内部排序，此时在外存中形成了初始归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjO8gK.png" alt="pCjO8gK.png"></li>
<li>此时对这8个初始归并段在内存中进行第一趟归并，需要读16次，写16次<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjXKsS.png" alt="pCjXKsS.png"></li>
</ul>
</li>
<li>在进行了第一趟归并之后，形成了4个新的归并段，之后需要对这4个归并段在内存中进行进一步的归并（第二趟归并）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjXCrD.png" alt="pCjXCrD.png"></li>
</ul>
</li>
<li>此时对这4个归并段在内存中进行归并操作，依旧需要读16次，写16次，最后会形成一个新的2个归并段，<br>此时再进行一次归并即可得到最终的有序序列<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjX6Rx.png" alt="pCjX6Rx.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部排序的优化</p>
<ul>
<li>在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果同时存放在内存中，<br>因此需要不停地将数据读出、写入磁盘，这会消耗大量的时间<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjLzng.png" alt="pCjLzng.png"></li>
</ul>
</li>
<li>多路平衡归并<ul>
<li>${\mathrm{k}}$路平衡归并的概念<ul>
<li>最多只能有${\mathrm{k}}$个段归并为一个</li>
<li>每一趟归并中, 若有${\mathrm{m}}$个归并段参与归并, 则经过这一趟处理得到${\lceil\mathrm{m} / \mathrm{k}\rceil}$个新的归并段</li>
<li>图片<ul>
<li>4路平衡归并<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvSMUe.png" alt="pCvSMUe.png"></li>
</ul>
</li>
<li>4路归并<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvSGvt.png" alt="pCvSGvt.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可以用多路归并的方法进行优化，采用4路归并时，只需要两趟归并，总读写次数为=32*2+32=96<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjjmk9.png" alt="pCjjmk9.png"></li>
</ul>
</li>
<li>在做m路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置2m个输入缓冲区和2个输出缓冲区<br>以便在执行内部归并时，能同时进行输入输出操作。若仅设置m个输入缓冲区，则仅能进行串行操作，无法并行处理。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于优化归并趟数(读写次数)的分析</p>
<ul>
<li>对r个初始归并段，做k路归并，则归并树可用K叉树来表示</li>
<li>若树高为h，则归并趟数$=\mathbf{h}-\mathbf{1}=\left\lceil\log _{k} r\right\rceil $<ul>
<li>推导：${\mathrm{k}}$叉树第${\mathrm{h}}$层最多有${k^{h-1}}$个结点，则${r \leq k^{h-1},(\mathrm{h}-1)}$最小${=\left\lceil\log _{k} r\right\rceil}$</li>
<li>由此，k越大，r越小，则归并趟数越少，读写次数越少</li>
</ul>
</li>
<li>可以增加输入缓冲区的数量来提高$K$（归并路数），即实现多路归并，但是会产生一些负面影响<ul>
<li>k路归并时，需要开辟k个输入缓冲区，内存开销增加。</li>
<li>每挑选一个关键字需要对比关键字(k-1)次，内部归并所需时间增加（可以设置败者树来解决此问题）</li>
</ul>
</li>
<li>可以减少初始归并段数量$r$来减少归并趟数，<br>生成初始归并段的“内存工作区”越大，初始归并段越长，此时初始归并段的数量越少<ul>
<li>若共${\mathbf{N}}$个记录, 内存工作区可以容纳${\mathrm{L}}$个记录, 则初始归并段数量  $\mathrm{r}=\lceil N / L\rceil$</li>
<li>可用“置换-选择排序”进一步减少初始归并段数量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>败者树</p>
<ul>
<li>败者树可以在多路归并时减少每挑选一个关键字时的比较次数，提高内部归并的时间</li>
<li>对于k路归并，第一次构建败者树时，需要对比关键字k-1次<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvp6Wd.png" alt="pCvp6Wd.png"></li>
</ul>
</li>
<li>有了败者树, 选出最小元素, 对于每一次比较只需对比关键字${\left\lceil\log _{2} k\right\rceil}$次 <ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv9pY4.png" alt="pCv9pY4.png"></li>
</ul>
</li>
<li>例题<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvX4EQ.png" alt="pCvX4EQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>置换-选择排序（生成初始归并段的优化方法）</p>
<ul>
<li>使用置换-选择排序，可以让每个初始归并段的长度超越内存工作区大小的限制</li>
<li>在内存工作区中传入待排序文件的关键字，内存工作区满了之后，选择其中最小的输出，<br>此时设置MINIMAX记录输出关键字的信息，下一个输出的关键字必须大于MINIMAX，否则无法输出<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv90cn.png" alt="pCv90cn.png"></li>
</ul>
</li>
<li>三个关键字都小于MINIMAX时，均无法输出，此时第一个归并段构建完成，可以构建下一个新的归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv94j1.png" alt="pCv94j1.png"></li>
</ul>
</li>
<li>最后将构建出数量r较少的初始归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv9X3d.png" alt="pCv9X3d.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>最佳归并树</p>
<ul>
<li><p>归并过程中的磁盘I/O次数=归并树的WPL*2</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvP5TK.png" alt="pCvP5TK.png"></li>
</ul>
</li>
<li><p>最佳归并树指此时的I/O时间最小的树，可以由构造哈夫曼树的方法来构造</p>
<ul>
<li>此时将归并段看做树的带权结点选取最小的组合来构造</li>
<li>2路归并的最佳归并树<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCviEmq.png" alt="pCviEmq.png"></li>
</ul>
</li>
<li>多路归并的最佳归并树<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvXWDS.png" alt="pCvXWDS.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>k叉归并的最佳归并树一定是严格k叉树，即树中只有度为k、度为0的结点</p>
</li>
<li><p>对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的“虚段”，再进行k叉哈夫曼树的构造</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvXBAH.png" alt="pCvXBAH.png"></li>
</ul>
</li>
<li><p>如何判断初始归并段的数量无法构成严格k叉归并树以及需要添加虚段的数量</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvX3N9.png" alt="pCvX3N9.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第七章-查找</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="数据结构第七章-查找"><a href="#数据结构第七章-查找" class="headerlink" title="数据结构第七章 查找"></a>数据结构第七章 查找</h2><blockquote>
<p>计算机学科基础：数据结构第七章查找的学习笔记</p>
</blockquote>
<h3 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1.查找的基本概念"></a>1.查找的基本概念</h3><ul>
<li>查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，<br>可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种<ul>
<li>①查询某个特定的数据元素是否在查找表中</li>
<li>②检索满足条件的某个特定的数据</li>
<li>③在查找表中插入一个数据元素</li>
<li>④从查找表中删除某个数据元素</li>
</ul>
</li>
<li>静态查找表和动态查找表<ul>
<li>若一个查找表的操作只涉及上述操作①和②，则无须动态地修改查找表，此类查找表称为静态查找表。</li>
<li>与此对应，需要动态地插入或删除的查找表称为动态查找表。<br>适合静态查找表的查找方法有顺序查找、折半查找、散列查找等，<br>适合动态查找表的查找方法有二叉排序树的查找、散列查找等。</li>
</ul>
</li>
<li>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</li>
<li>平均查找长度（<strong>ASL</strong>）：在查找过程中，一次查找的长度是指需要比较的关键字次数，<br>而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。</li>
</ul>
<h3 id="2-顺序查找和折半查找（✪）"><a href="#2-顺序查找和折半查找（✪）" class="headerlink" title="2.顺序查找和折半查找（✪）"></a>2.顺序查找和折半查找（✪）</h3><ul>
<li><p>顺序查找（线性查找，适用于顺序表和链表）</p>
<ul>
<li><p>一般线性表的顺序查找</p>
<ul>
<li><p>加入哨兵的线性查找，算法从尾部开始查找，此时在0号位设置一个哨兵，查找失败则返回0，<br>无需判断是否越界，提高程序效率</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//顺序表</span></span><br><span class="line">    <span class="type">int</span> *elem;		<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;   <span class="comment">//表长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST,ElemType Key)</span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key; <span class="comment">//0号位置存哨兵</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;i--) <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>平均查找长度：查找成功时：ASL=$\frac{n+1}{2}$，查找失败时为：ASL=$n+1$</p>
</li>
</ul>
</li>
<li><p>有序表的顺序查找</p>
<ul>
<li>可以设置查找判定树<ul>
<li>成功结点的关键字对比次数=结点所在层数</li>
<li>失败结点的关键字对比次数=其父节点所在层数</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pC7kJsS.png" alt="pC7kJsS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平均查找长度：查找成功时：ASL=$\frac{n+1}{2}$，查找失败时为：ASL=$\frac{n}{n+1}+\frac{n}{2}$</p>
</li>
<li><p>顺序查找的时间复杂度：O(n)</p>
</li>
</ul>
</li>
<li><p>折半查找（二分查找，仅适用于<strong>有序的顺序表</strong>✪）</p>
<ul>
<li><p>此时设定中间指针(mid=(low+high)/2)，向下取整。如果较小则high=mid-1，在左边的区间再进行折半查找；<br>如果较大则low=mid+1,在右边的区间再进行折半查找。</p>
</li>
<li><p>代码实现（中间指针向下取整）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>; <span class="comment">//取有序表的中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;   <span class="comment">//查找成功则返回当前位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low=mid+<span class="number">1</span>; <span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>折半查找的判定树</p>
<ul>
<li>性质（当$\operatorname{mid}{=\lfloor(} low +   high ) / 2\rfloor$时）<ul>
<li>如果当前Iow和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</li>
<li>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</li>
<li>每个结点值均大于其左子结点值，小于其右子结点值</li>
<li>此二叉树时一颗平衡二叉树，并且有性质：右子树结点数—左子树结点数=0或1</li>
<li>折半查找的判定树中，只有最下面一层是不满的，元素个数为${\boldsymbol{n}}$时树高${h=\left\lceil\log _{2}(n+1)\right\rceil}$<ul>
<li>折半查找不成功时的最多比较次数为树的高度，最少比较次数为树的高度减一<ul>
<li>此时由${h=\left\lceil\log _{2}(16+1&gt;2^{4})\right\rceil}$最多需要比较5次，最少需要比较4次<img src="https://s1.ax1x.com/2023/07/20/pCHyCUf.png" alt="pCHyCUf.png"></li>
</ul>
</li>
</ul>
</li>
<li>若有序序列有个n元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点<br>（失败结点的数量=成功结点所构成的树的空链域数量=n+1）</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pC7Exr8.png" alt="pC7Exr8.png"></li>
</ul>
</li>
<li>关于折半查找二叉树的例题<ul>
<li>例1，已知关键字的个数，求查找成功的平均复杂长度和查找失败的平均复杂长度<ul>
<li>此时构造判定树，采用（$\operatorname{mid}{=\lfloor(} low +   high ) / 2\rfloor$写出中间的点，<br>再根据左小右大确定两边的范围，再某段范围里通过公式求出两边的点的中间的点）<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHyxWF.png" alt="pCHyxWF.png"></li>
</ul>
</li>
</ul>
</li>
<li>例2，判断是否能成为折半查找中关键字的比较序列<ul>
<li>此时直接写出相关的判定树，之后对各元素存在的合理性进行判断，<br>A选项中200后的450说明之后的数都应该比200大，但是之后出现了180，此时不满足判定树的原理<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCH6XnA.png" alt="pCH6XnA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>折半查找的时间复杂度：$O ( \log _ { 2 } n )$</p>
</li>
</ul>
</li>
<li><p>分块查找（索引顺序查找,了解）</p>
<ul>
<li><p>概述</p>
<ul>
<li>将查找表分为若干块，块内的元素可以无序，但是块间的元素必须是有序的，<br>前一个块中的最大关键字小于后一个块中所有记录的关键字</li>
<li>之后建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，<br>索引表按关键字有序排序。</li>
<li>对索引表进行折半查找时，若索引表中不包含目标关键字，则折半查找最终停在low&gt;high,要在Iow所指分块中查找</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCH0oY4.png" alt="pCH0oY4.png"></li>
</ul>
</li>
<li><p>分块查找的平均时间复杂度分析（一般只分析分块查找的顺序查找索引表下的ASL）</p>
<ul>
<li><strong>当每个分块内部元素的数量（s）等于元素总数开根时<script type="math/tex">\sqrt{n}</script>时，（此时s=b=$\sqrt{n}$）此时其查找时间最小</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHBwcR.png" alt="pCHBwcR.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>分块矩阵的相应例题</p>
<ul>
<li><p>例1，利用分块矩阵顺序查找索引查找表的公式来计算查找成功的平均查找长度，$A S L = \frac { b + 1 } { 2 } + \frac { s + 1 } { 2 }$，<br>b和s分别是块内的单元数和分块的数量，选B</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHcK9U.png" alt="pCHcK9U.png"></li>
</ul>
</li>
<li><p>例2，分析在什么条件下的分块查找的平均查找长度最小并计算，此时需要满足：块数=块长=$\sqrt{元素总数}=255$，<br>这个时候可以在索引项和索引表中都采取<strong>折半查找</strong>的方式，来计算最小的平均查找长度：${A S L=\left\lceil\log _{2}(255+1)\right\rceil + \left\lceil\log _{2}(255+1)\right\rceil}=16$</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHcRC8.png" alt="pCHcRC8.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-树形查找（✪）"><a href="#3-树形查找（✪）" class="headerlink" title="3.树形查找（✪）"></a>3.树形查找（✪）</h3><ul>
<li><p>二叉排序树（BST✪）</p>
<ul>
<li><p>二叉排序树的定义</p>
<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字</li>
<li>右子树上所有结点的关键字均大于根结点的关键字</li>
<li>左子树和右子树又各是一棵二叉排序树。</li>
<li>注：空树也是二叉排序树</li>
<li>进行中序遍历，可以得到一个递增的有序序列</li>
</ul>
</li>
<li><p>二叉排序树的查找</p>
<ul>
<li><p>从根结点开始，沿某个分支逐层向下比较的过程</p>
</li>
<li><p>若树非空，目标值与根结点的值比较</p>
<ul>
<li>若相等，则查找成功</li>
<li>若小于根结点，则在左子树上查找，否则在右子树上查找。</li>
</ul>
</li>
<li><p>查找成功，返回结点指针；查找失败返回NULL</p>
</li>
<li><p>代码实现（了解）</p>
<ul>
<li><p>二叉排序树的非递归算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> Key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;Key!=T-&gt;key)&#123;  <span class="comment">//若树空或等于根结点的值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)  <span class="comment">//小于根结点的值，在左子树上查找</span></span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;  <span class="comment">//大于根结点的值，则在右子树上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的递归算法（空间复杂度较高，执行效率较低）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key); <span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key); <span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的插入</p>
<ul>
<li><p><strong>将二叉排序树T1的<u>先序遍历序列</u>依次插入初始为空的树中，所得到的二叉排序树T2和T1的形态完全相同。</strong></p>
</li>
<li><p><strong>在二叉排序树中插入一个结点的时间复杂度为O(n)</strong></p>
</li>
<li><p>插入结点的过程如下：若原二叉排序树为空，则直接插入，否则，若关键字k小于根结点值，则插入到左子树，<br>若关键字k大于根结点值，则插入到右子树。</p>
</li>
<li><p>代码实现（了解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BiTree &amp;T,keyType k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;	<span class="comment">//此时原树为空，新插入的结点为根节点</span></span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode)); </span><br><span class="line">        T-&gt;data=k;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回1，插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(K==T-&gt;data)	<span class="comment">//树中存在相同关键字的结点，此时插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;data) <span class="comment">//新结点会插入到此时结点的左子树中</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//新结点会插入到此时结点的右子树中</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的构造</p>
<ul>
<li><p>从一颗空树出发，依次输入元素，并将其插入到二叉树中的合适位置</p>
</li>
<li><p>代码实现（了解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BiTree &amp;T,keyType str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>; <span class="comment">//初始时为空树</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        BST_INsert(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</li>
<li>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li>
<li>若结点z有左、右两棵子树，则令z的直接后继（直接前驱）替代z，然后从二叉排序树中删去这个直接后继（直接前驱）<br><strong>这里的直接后驱指的是右子树中进行中序遍历的第一个数，直接前驱指的是左子树中进行中序遍历的最后一个数</strong>）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHfwm4.png" alt="pCHfwm4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的查找效率分析</p>
<ul>
<li>二叉排序树的查找效率，主要取决于树的高度。若树高h，找到最下层的一个结点需要对比h次</li>
<li>若二叉排序树的左、右子树的高度之差的绝对值不超过1(为平衡二叉树时)，它的平均查找长度为O($log_{2}n$)。</li>
<li>若二叉排序树是一个只有右（左）孩子的单支树（类似有序的单链表），则其平均查找长度为O(n)。<ul>
<li>用逐点插入法构建二叉排序树，若先后插入的关键字有序，此时二叉排序树的深度最大</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHfLjS.png" alt="pCHfLjS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平衡二叉树（AVL树✪）</p>
<ul>
<li><p>平衡二叉树的定义</p>
<ul>
<li>平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：<br>它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。</li>
<li>结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</li>
</ul>
</li>
<li><p>平衡二叉树的插入</p>
<ul>
<li><p>概述</p>
<ul>
<li>每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。</li>
<li><strong>若导致了不平衡，则先找到插入路径上<u>离插入结点最近的</u>平衡因子的绝对值大于1的结点A，</strong><br><strong>再对以A为根的子树（最小不平衡子树），在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</strong><ul>
<li>此时找到距离插入点最近的平衡因子的绝对值大于1的点为序号70，LL插入，此时则应该变动70的左子树68进行右上旋</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHvN3F.png" alt="pCHvN3F.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡</strong></li>
</ul>
</li>
<li><p>四种调整的情况</p>
<ul>
<li><p>LL：在A的左孩子的左子树中插入导致不平衡</p>
<ul>
<li><p>进行右单旋转，将A的左孩子右上旋</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHbUcn.png" alt="pCHbUcn.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f是双亲结点，gf是f的双亲结点</span></span><br><span class="line">f-&gt;lchild=p-&gt;rchild;</span><br><span class="line">p-&gt;rchild=f;</span><br><span class="line">gf-&gt;lchild/rchild=p</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>RR：在A的右孩子的右子树中插入导致不平衡</p>
<ul>
<li><p>进行左单旋转，将A的右孩子左上旋</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHbH9H.png" alt="pCHbH9H.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f-&gt;rchild=p-&gt;lchild;</span><br><span class="line">p-&gt;lchild=f;</span><br><span class="line">gf-&gt;lchild/rchild=p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LR：在A的左孩子的右子树中插入导致不平衡</p>
<ul>
<li>在A的左孩子的右子树插入导致A不平衡，<strong>将A的左孩子的右孩子先左上旋再右上旋</strong>（此时这里的A为66，绝对值大于1）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHXGbq.png" alt="pCHXGbq.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>RL：在A的右孩子的左子树中插入导致不平衡</p>
<ul>
<li>在A的右孩子的左子树插入导致A不平衡，<strong>将A的右孩子的左孩子先右上旋再左上旋</strong>（此时这里的A为50(绝对值大于1)）</li>
<li>图片1<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHXdGF.png" alt="pCHXdGF.png"></li>
</ul>
</li>
<li>图片2<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHjZQJ.png" alt="pCHjZQJ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平衡二叉树的删除</p>
<ul>
<li>步骤<ul>
<li>①删除结点(方法同“二叉排序树”)</li>
<li>②向上看是否导致存在不平衡，若没有则结束</li>
<li>③找最小不平衡子树下，“个头”最高的儿子、孙子</li>
<li>④根据孙子相对于最小不平衡子树的根结点的位置，使用相关方法调整平衡(LL/RR/LR/RL)<ul>
<li>孙子在LL:儿子右单旋</li>
<li>孙子在RR:儿子左单旋</li>
<li>孙子在LR:孙子先左旋，再右旋</li>
<li>孙子在RL:孙子先右旋，再左旋</li>
</ul>
</li>
<li>⑤如果不平衡向上传导，继续②<ul>
<li>对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</li>
</ul>
</li>
</ul>
</li>
<li>例子：此时删除32后向上找到44不平衡，向下找到44最高的儿子和孙子78、50。孙子的情况是RL，<br>则此时对其先右上旋再左上旋，调整为平衡二叉树<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCbSqgO.png" alt="pCbSqgO.png"></li>
</ul>
</li>
<li>对于一个平衡二叉树如果删除一个结点后再插入（不管是叶结点还是分支结点）此时树可能会发生改变；<br>对于一个二叉排序树，删除叶子结点后再插入此时树不变，删除分支结点后再插入树会发生改变。</li>
</ul>
</li>
<li><p>平衡二叉树的查找</p>
<ul>
<li>在查找过程中，查找次数不会超过平衡二叉树的深度</li>
<li>在平衡二叉树上，树上任一结点的左子树和右子树的高度之差不超过 1 。</li>
<li>假设以${n_{h}}$表示深度为${h}$的平衡树中含有的最少结点数。则有${n_{0}=0, n_{1}=1, n_{2}=2}$, 并且有${n_{h}=n_{h-1}+n_{h-2}+1}$<ul>
<li>本题用此方法递推计算（1,2,4,7,12,20）构建5层平衡二叉树至少需要12个顶点，<br>构建6层平衡二叉树至少需要20个顶点，因此含有15个顶点的平衡二叉树的最大深度为5</li>
<li>平衡二叉树总结点数最小时，所有非叶节点的平衡因子都为1</li>
</ul>
</li>
<li>含有$\mathrm{n}   个结点的平衡二叉树深度最小值为 \left\lfloor\log _{2} \mathrm{n}\right\rfloor+1$</li>
<li>平衡二叉树的平均查找长度为${O\left(\log _{2} n\right)}$</li>
</ul>
</li>
</ul>
</li>
<li><p>红黑树（RBT✪）</p>
<ul>
<li>红黑树的定义：一种特殊的二重排序树<ul>
<li>红黑树RBT，插入/删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。<br>即便需要调整，一般都可以在常数级时间内完成</li>
<li>平衡二叉树：适用于以查为主、很少插入/删除的场景</li>
<li>红黑树：适用于频繁插入、删除的场景，实用性更强</li>
<li>结点的黑高：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数</li>
</ul>
</li>
<li>红黑树的五个特点（左根右，根叶黑，不红红，黑路同）<ul>
<li>每个结点或是红色，或是黑色的</li>
<li>根节点是黑色的</li>
<li>叶结点(这里指NULL和结点失败结点)均是黑色的</li>
<li>不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</li>
<li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li>
</ul>
</li>
<li>红黑树的结论<ul>
<li>从根节点到叶结点的最长路径不大于最短路径的2倍<ul>
<li>当从根到任意一个叶结点的简单路径最短时，这条路径必然全部由黑结点构成</li>
<li>当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时两者的数量相同</li>
<li>红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过2</li>
</ul>
</li>
<li>有n个内部节点的红黑树高度 h≤$2log_{2}(n+1)$</li>
<li>根节点黑高为h的红黑树，内部结点数（关键字）至少有$2^{h}-1$个</li>
<li>红黑树查找操作时间复杂度=O($log_{2}n$)，查找效率与AVL树同等数量级</li>
</ul>
</li>
<li>红黑树的插入<ul>
<li>插入结点的方法，注：一般插入时违背的是“不红红”<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCbViRA.png" alt="pCbViRA.png"></li>
</ul>
</li>
<li>例子<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCbVnIg.png" alt="pCbVnIg.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-B树与B-树（✪）"><a href="#4-B树与B-树（✪）" class="headerlink" title="4.B树与B+树（✪）"></a>4.B树与B+树（✪）</h3><ul>
<li><p>B树（✪）</p>
<ul>
<li><p>B树的性质</p>
<ul>
<li>m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。</li>
<li>一棵m阶B树或为空树，或为满足如下特性的m叉树<ul>
<li><strong>树中每个结点至多有$m$棵子树，即至多含有$m-1$个关键字。</strong></li>
<li>若根结点不是叶结点，则至少有两棵子树。</li>
<li><strong>除根结点外的所有非叶结点至少有$ \lceil m / 2\rceil $棵子树，即至少含有$ \lceil m / 2\rceil-1 $个关键字。</strong></li>
<li>满足左&lt;中&lt;右的性质</li>
<li>所有叶节点都出现在同一层次上，并且不带信息（即为查找失败结点）</li>
<li>${\mathrm{n}}$个关键字的B树必有${\mathrm{n}+1}$个叶子结点</li>
<li>注：判断B树的类型，需要看其中关键字最多的结点判断是几阶</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqrBkV.png" alt="pCqrBkV.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B树的最小高度和最大高度（此时一般不包括最后一层叶子结点的层数）</p>
<ul>
<li>对于n个关键字，m阶B树的最小高度<ul>
<li>在每一层中含有最多的结点数并且在每一个结点中含有最多的关键字数</li>
<li>此时关键字的数量满足：$n \leqslant(m-1)\left(1+m+m^{2}+\cdots+m^{h-1}\right)=m^{h}-1$</li>
<li>此时可算出最小的高度： $h \geqslant \log _{m}(n+1)$</li>
</ul>
</li>
<li>对于n个关键字，m阶B树的最大高度<ul>
<li>在每一层中含有最小的结点数并且在每一个结点中含有最少的关键字数</li>
<li>此时让各层的分叉尽可能的少, 即根节点只有 2 个分叉, 其他结点只有${\lceil m / 2\rceil}$个分叉</li>
<li>各层结点至少有：第一层 1、第二层 2、第三层${2\lceil\mathrm{m} / 2\rceil \ldots}$第h层${2(\lceil\mathrm{m} / 2\rceil)^{h-2}}$，<br>则第h+1层共有叶子结点（失败结点）${2(\lceil m / 2\rceil)^{h-1}}$个</li>
<li>${\mathrm{n}}$个关键字的B树必有${\mathrm{n}+1}$个叶子结点, 则${n+1 \geq 2(\lceil m / 2\rceil)^{h-1}}$, 即${h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1}$</li>
<li>此时可算出最大的高度：$h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1$</li>
</ul>
</li>
<li>含$\mathrm{n}$个关键字的$\mathrm{m叉B} 树, 满足 \log _{m}(n+1) \leq h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1$</li>
</ul>
</li>
<li><p>B树的插入</p>
<ul>
<li>首先定位元素插入的位置，新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</li>
<li>如果再插入关键字后，结点中的关键字数量没有超过上限，此时直接插入即可<br>（如阶为5的B树的关键字范围为2—4，在一个结点中最多有4个，最少有2个关键字）</li>
<li>在插入key后, 若导致原结点关键字数超过上限, 则从中间位置${(\lceil\mathrm{m} / 2\rceil)}$将其中的关键字分为两部分,<br>左部分包含的关键字放在原结点中, 右部分包含的关键字放到新结点中, 中间位置${(\lceil{m} / 2\rceil)}$的结点插入原结点的父结点</li>
<li>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，<br>进而导致B树高度增1。</li>
<li>图片<ul>
<li>图1<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqy956.png" alt="pCqy956.png"></li>
</ul>
</li>
<li>图2<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqyi8O.png" alt="pCqyi8O.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B树的删除</p>
<ul>
<li><p>若被删除关键字在非终端节点，则用直接前驱或直接后继来替代被删除的关键字</p>
<ul>
<li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li>
<li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqy8MQ.png" alt="pCqy8MQ.png"></li>
</ul>
</li>
<li><p>若被删除关键字在终端节点，此时分为下列三种情况</p>
<ul>
<li>删除后的结点中的关键字的数量不低于低于下限${\lceil m / 2\rceil-1}$时，则直接删除该关键字</li>
<li>（兄弟够借）<ul>
<li>删除后结点的关键字数量将低于下限${\lceil m / 2\rceil-1}$，且与结点相邻的右（或左）兄弟结点的关键字个数还很宽裕，</li>
<li>此时删除该结点后，将其对应的一个父节点的关键字转移到此处，并将右兄弟或左兄弟的一个关键字转移到此父节点</li>
<li>去借右兄弟：<ul>
<li>此时删除38，此时其右兄弟够用，将父结点关键字49下移来替换38，<br>并且将右兄弟关键字70上移到原来的父节点关键字处</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6Ces.png" alt="pCq6Ces.png"></li>
</ul>
</li>
</ul>
</li>
<li>去借左兄弟<ul>
<li>此时删除90，其左兄弟够用，使父结点关键字88下移，再将左兄弟结点关键字87上移</li>
<li>图片1<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq68fK.png" alt="pCq68fK.png"></li>
</ul>
</li>
<li>图片2<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6d0A.png" alt="pCq6d0A.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>(兄弟不够借)<ul>
<li>若被删除关键字所在结点删除关键字后少于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均${\lceil m / 2\rceil-1}$, </li>
<li>则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</li>
<li>在合并过程中, 双亲结点中的关键字个数会减 1，此时可能需要对双亲结点进行相关操作<ul>
<li>若双亲结点不是根结点, 且关键字个数减少到${\lceil m / 2\rceil-2}$, 则又要与它自己的兄弟结点进行调整或合并操作,<br>并重复上述步骤, 直至符合${B}$树的要求为止。</li>
<li>若其双亲结点是根结点且关键字个数减少至 0 (根结点关键字个数为 1 时, 有 2 棵子树) , 则直接将根结点删除,<br>合并后的新结点成为根</li>
</ul>
</li>
<li>流程<ul>
<li>此时删除49，但是其右兄弟的关键字数量已经不够借，<br>此时删除49之后将父结点关键字70下移以及和其右兄弟结点的两个关键字合并到一起<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6TpT.png" alt="pCq6TpT.png"></li>
</ul>
</li>
<li>此时合并之后，上方的父结点中的关键字数量已经少于下限，此时也需要合并，<br>可将父结点82与其右兄弟结点中的87,93关键字合并到一起，此时根节点为空，删除根结点即可<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6vA1.png" alt="pCq6vA1.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqcu38.png" alt="pCqcu38.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树（适用于数据库）</p>
<ul>
<li><p>B+树的性质</p>
<ul>
<li>每个分支结点最多有m棵子树（孩子结点）</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有${\lceil\mathrm{m} / 2\rceil}$棵子树。</li>
<li>结点的子树个数与关键字个数相等。</li>
<li>所有<strong>叶结点</strong>包含<strong>全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，<br>并且相邻叶结点按大小顺序相互链接起来。（支持顺序查找）</li>
<li>所有分支结点中仅包含它的各个子结点中关键字的<strong>最大值</strong>及指向其<strong>子结点的指针</strong>。</li>
<li><p>B+树含有两个头指针，一个指向根结点，一个指向关键字最小的叶结点，<br>可以进行从最小关键字开始的顺序查找以及从根结点开始的多路查找</p>
<ul>
<li>在B+树中进行的多路查找，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，<br>直到叶结点上的该关键字为止。在B+树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqcdvF.png" alt="pCqcdvF.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>B+树与B树的区别</p>
<ul>
<li>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；<br>而在B树中，具有n个关键字的结点含有n+1棵子树。</li>
<li>在B+树中，每个结点（非根内部结点）的关键字个数n的范围是 ${\lceil\mathrm{m} / 2\rceil} ≤n≤m$ (而根结点：$1≤n≤m$)；<br>而在B树中，每个结点（非根内部结点）的关键字个数n的范围是${\lceil\mathrm{m} / 2\rceil}-1≤n≤m-1$ (根结点：$1≤n≤m-1$)</li>
<li>在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；<br>而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。</li>
<li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，<br>非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>B树的结点中都包含了关键字对应的记录的存储地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-散列表（✪）"><a href="#5-散列表（✪）" class="headerlink" title="5.散列表（✪）"></a>5.散列表（✪）</h3><ul>
<li>散列表的基本概念<ul>
<li>散列表 (哈希表，Hash Table)：是一种数据结构。根据关键字而直接进行访问的数据结构。<br>散列表建立了关键字和存储地址之间的一种直接映射关系。</li>
<li>散列函数（哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，<br>记为Hash(key)=Addr (这里的地址可以是数组下标、索引或内存地址等)</li>
<li>冲突和同义词：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，<br>这些发生碰撞的不同关键字称为同义词</li>
</ul>
</li>
<li>散列表的构造<ul>
<li>进行构造的要点<ul>
<li>定义域必须涵盖所有可能出现的关键字，值域不能超出散列表的地址范围</li>
<li>尽可能减少冲突。散列函数计算出来的地址应尽可能均匀分布在整个地址空间。</li>
<li>散列函数应尽量简单，能够快速计算出任意一个关键字对应的散列地址</li>
</ul>
</li>
<li>四种构造的方法<ul>
<li>除留余数法：H(key)=key%p<ul>
<li>散列表表长为m，取一个不大于m但最接近或等于m的质数p</li>
<li>如表长为13，16，p可以均选13</li>
<li>只要关键字为整数就适用</li>
</ul>
</li>
<li>直接定址法：H(key)=key或H(key)=a*key+b<ul>
<li>其中，和b是常数。这种方法计算最简单，且不会产生冲突。<br>若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li>
<li>适用场景：关键字分布基本连续</li>
</ul>
</li>
<li>数字分析法：选取数码分布较为均匀的若干位作为散列地址<ul>
<li>每个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；<br>而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。</li>
<li>适用场景：关键字集合已知，且关键字的某几个数码位分布均匀</li>
</ul>
</li>
<li>平方取中法：取关键字的平方值的中间几位作为散列地址<ul>
<li>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀。</li>
<li>适用场景：关键字的每位取值都不够均匀。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>处理冲突的方法<ul>
<li>开放定址法：如果发生冲突，就给新元素找另一个空闲的位置<ul>
<li>数学递推公式为：$H _ { i } = ( H ( k e y ) + d _ { i } ) \% m$（m为散列表表长）</li>
<li>其中$d_{i}$为增量序列（偏移量），通过四种方法可以进行选择</li>
<li>采用“开放定址法”时，删除元素不能简单地将被删元素的空间置为空，<br>否则将截断在它之后的探测路径，可以做一个“已删除”标记，<strong>进行逻辑删除</strong>。</li>
<li>理想情况下，若散列表表长=m,则最多发生m-1次冲突即可“探测”完整个散列表。</li>
<li>线性探测法<ul>
<li>$d_{i}=0,1,2,3……m-1$</li>
<li>可以探测到散列表的每一个地址，但是容易造成大量元素在相邻的散列地址上聚集，大大降低查找效率</li>
<li>堆积问题是由于同义词之间或非同义词之间发生冲突导致的</li>
<li><strong>当从散列表中删除一个记录时，不应将这个记录的所在位置置为空，因为这将会影响后面的查找，逻辑删除即可</strong></li>
</ul>
</li>
<li>平方探测法（又称为二次探测法）<ul>
<li>${d_{i}=0^{2}, 1^{2},-1^{2}, 2^{2},-2^{2}, \ldots, k^{2},-k^{2}}$。 其中${k \leq m / 2}$</li>
<li>采用平方探测法，至少可以探测到散列表中一半的位置，即便散列表中有空闲位置，也未必能插入成功</li>
<li>若散列表长度m是一个可以表示成4k+3的素数(如7、11、19)，平方探测法就能探测到所有位置</li>
<li>可以有效避免堆积的问题</li>
</ul>
</li>
<li>双散列法<ul>
<li>${d_{i}=\mathbf{i} \times \operatorname{hash}_{2}(k e y)}$</li>
<li>双散列法未必能探测到散列表的所有位置。双散列法的探测覆盖率取决于第二个散列函数hash2(key)设计的是否合理。</li>
<li>若hash2(key)计算得到的值与散列表表长m互质，就能保证双散列发可以探测所有单元</li>
<li>令表长m本身就是质数，hash2(key)=m-(key%m)，此时无论key值是多少，hash2(key)和m一定互质</li>
</ul>
</li>
<li>伪随机序列法：d是一个伪随机序列，由程序员人为设计</li>
</ul>
</li>
<li>拉链法（链地址法）<ul>
<li>适用于经常进行插入和删除的情况</li>
<li>查找长度是指的查找时与相应关键字的对比次数</li>
<li>如此时要找40，此时需要在1处的链表查找4次，未能找到<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqqPvd.png" alt="pCqqPvd.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>散列查找及性能分析<ul>
<li>先求得散列地址，在散列地址上已有关键字且与查找的关键字不同时，使用相关方法进行冲突处理。<br>若散列地址上没有关键字此时查找失败。若散列地址上的关键字与被查找关键字相等，此时查找成功，返回相应的地址</li>
<li>散列表的查找效率主要取决于：散列函数，处理冲突的方法和装填因子</li>
<li>装填因子a，定义为一个表的装满程度：$a=\frac{表中记录数n}{散列表长度m}$</li>
<li>散列表的平均查找长度依赖于散列表的装填因子$a$，而不直接依赖于n或m。<br>直观地看，$a$越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。</li>
<li>例题：求查找失败的平均查找长度就是查到表中的空地址时，即查找失败，此时虽然表中有序号为7的元素，<br>但是由于散列为7的余数，此时只会在0-6的范围内有相对应的地址，但是查询的时候会查到序号为8的地方。<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCLSwHH.png" alt="pCLSwHH.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/23/pCLSDUA.png" alt="pCLSDUA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第六章-图</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="数据结构第六章-图"><a href="#数据结构第六章-图" class="headerlink" title="数据结构第六章 图"></a>数据结构第六章 图</h2><blockquote>
<p>计算机学科基础：数据结构第六章图的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-图的定义（✪）"><a href="#1-图的定义（✪）" class="headerlink" title="1.图的定义（✪）"></a>1.图的定义（✪）</h3><ul>
<li><p>定义</p>
<ul>
<li>图G由顶点集V和边集E组成，记为G=(V,E)</li>
<li>其中V(G)表示图G中顶点的有限非空集（称为图的阶）；E(G)表示图G中顶点之间的关系（边）集合。</li>
<li>图不能是空图，顶点集不能为空，但是边集可以为空</li>
<li><strong>对于一个具有n个顶点和e条边的图，若采用边集数组表示，则边集数组中的单元数至少为2e个</strong></li>
</ul>
</li>
<li><p>一些关于图的概念</p>
<ul>
<li>无向图：若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为(v,w)或(w,v)。</li>
<li>有向图：若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是项点的有序对，记为<v,w>，<br>其中v,w是顶点，v称为弧尾，w称为弧头，<y,w>称为从v到w的弧，也称v邻接到w。</y,w></v,w></li>
<li>简单图、多重图：不存在重复边且不存在顶点到自身的边，则图G即为简单图，否则为多重图</li>
<li>度<ul>
<li>对于无向图，顶点v的度是指依附于顶点v的边的条数，<br><strong>无向图的全部顶点的度的和等于边数的两倍（无向图所有顶点的度之和为偶数）</strong></li>
<li>对于有向图，顶点v的度分为入度和出度，<strong>有向图的全部顶点的入度之和与出度之和相等，并且等于边数。</strong></li>
<li>例题<ul>
<li>此时直接利用相关的关系，所有顶点的度数之和等于边数量的两倍（4*5+3*4+2<em>(n-9)=23\</em>2）选D<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIG4Ln.png" alt="pCIG4Ln.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>路径与回路<ul>
<li>路径：由顶点和相邻顶点序偶构成的边所形成的序列<ul>
<li>注意：由不同顶点所形成的序列不是路径的定义</li>
</ul>
</li>
<li>回路（环）：第一个顶点和最后一个顶点相同的路径称为回路或环<ul>
<li><strong>有n个顶点和n条边的无向图一定是有环的</strong></li>
<li><strong>如果有向图中存在拓扑排序，则其一定是无环的</strong></li>
</ul>
</li>
<li>简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。<ul>
<li>最短路径一定是简单路径</li>
</ul>
</li>
<li>简单回路：除第一个项点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li>
<li>路径长度：路径上边的数目</li>
<li>点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。<br>若从u到v根本不存在路径，则记该距离为无穷(∞)。</li>
</ul>
</li>
<li>连通与强连通<ul>
<li>无向图中，若从项点v到项点w有路径存在，则称顶点v和顶点w之间是连通的</li>
<li>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的<strong>（可以去和回）</strong></li>
</ul>
</li>
<li>连通图与强连通图<ul>
<li>连通图：任意两个顶点之间都是连通的无向图，则称为连通图否则为非连通图。<ul>
<li><strong>对于n个顶点的无向图G，若G是连通图，则最少有n-1条边</strong><ul>
<li>注意理解：是G为连通图可以推导出该无向图至少有n-1条边</li>
<li>此题选D<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIJKFf.png" alt="pCIJKFf.png"></li>
</ul>
</li>
<li>此题选D，这时肯定构成了回路，但是不一定是连通图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI1Bq0.png" alt="pCI1Bq0.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>若其为非连通图无向图，则最多可能有$\frac {n ( n - 1 ) } {2} $条边</strong><ul>
<li>如果出现由n-1个完全无向图与另外一个单独顶点的极端情况，此时只需加1，<br>则可以确保这n个顶点可以构成无向连通图<ul>
<li>本题即为（5*4）/2+1=11，选D<img src="https://s1.ax1x.com/2023/07/16/pCIGGa6.png" alt="pCIGGa6.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>强连通图：任意一对顶点之间都是强连通的有向图。<ul>
<li><strong>对于n个顶点的有向图G，若其为强连通图，则最少有n条边（形成回路）</strong></li>
</ul>
</li>
</ul>
</li>
<li>连通分量与强联通分量<ul>
<li>连通分量：无向图的极大连通子图（<strong>必须连通且尽可能包含更多的顶点和边</strong>）<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIKLDK.png" alt="pCIKLDK.png"></li>
</ul>
</li>
<li>强连通分量：有向图的极大强连通子图（<strong>必须强连通且尽可能包含更多的边</strong>）<ul>
<li>注：若一个图存在环，则其一定<strong>含有</strong>顶点数大于1的强连通分量</li>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIKOHO.png" alt="pCIKOHO.png"></li>
</ul>
</li>
</ul>
</li>
<li>子图与生成子图<ul>
<li>设有两个图G=(V,E)和G1=(V1,E1),若V1是V的子集，且E1是E的子集，则称G1是G的子图。<ul>
<li>此时需要V1和E1先相互对应，即构成了图。如下面的描述错误<img src="https://s1.ax1x.com/2023/07/16/pCI3ffg.png" alt="pCI3ffg.png"></li>
</ul>
</li>
<li>若有满足V(G)=V(G1)的子图G,则称其为G的生成子图。<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIKRBT.png" alt="pCIKRBT.png"></li>
</ul>
</li>
</ul>
</li>
<li>生成树与生成森林<ul>
<li>连通图的生成树是包含图中全部顶点的一个极小连通子图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIMCvt.png" alt="pCIMCvt.png"></li>
</ul>
</li>
<li>生成森林<ul>
<li>非连通图中，连通分量的生成树构成了非连通图的生成森林<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIMFDf.png" alt="pCIMFDf.png"></li>
</ul>
</li>
</ul>
</li>
<li>边的权、带权图（网）<ul>
<li>边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</li>
<li>带权图/网：边上带有权值的图称为带权图，也称网。</li>
<li>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li>
</ul>
</li>
</ul>
</li>
<li>几种特殊的图<ul>
<li>完全图<ul>
<li>无向完全图：无向图中任意两个顶点之间都存在边，共有条$\frac {n ( n - 1 ) } {2} $边</li>
<li>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，共有$n(n-1)$条边</li>
<li><strong>讨论拥有n个顶点的无向图需要多少条边才能确保形成一个连通图，</strong><br><strong>此时常常考虑为由n-1个顶点之间形成的完全无向图与另外一个单独结点的组合时，再添加一条边，使这两部分相连。</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI8Obt.png" alt="pCI8Obt.png"></li>
</ul>
</li>
</ul>
</li>
<li>树：不存在回路，且连通的无向图，n个顶点的树，必有n-1条边。n个顶点的图，若边大于n-1,则一定有回路</li>
<li>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-图的存储（✪）"><a href="#2-图的存储（✪）" class="headerlink" title="2.图的存储（✪）"></a>2.图的存储（✪）</h3><ul>
<li><p>邻接矩阵法（二维数组实现的顺序存储方式✪）</p>
<ul>
<li><p>使用邻接矩阵存储，是指用一个一维数组存储图中项点的信息，<br>用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100 	<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum]; 	<span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; 	<span class="comment">//临接矩阵，存放边的关系</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum; 		<span class="comment">//图的当前顶点数和边数、弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接矩阵存储有向图与无向图</p>
<ul>
<li>值为1时边之间有关系，为0时无关系</li>
<li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。（只需存储上下三角矩阵的元素）</li>
<li>对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是顶点的度数</li>
<li>对于有向图，邻接矩阵的第i行非零元素的个数正好是顶点i的出度，第i列非零元素的个数正好是顶点i的入度</li>
<li>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(n)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI0HFs.png" alt="pCI0HFs.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>邻接矩阵存储带权图</p>
<ul>
<li>∞元素和0元素表示两边之间不邻接，非零数表示相应的权值</li>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIB1pt.png" alt="pCIB1pt.png"></li>
</ul>
</li>
<li><p>邻接矩阵的相关性质</p>
<ul>
<li><strong>邻接矩阵表示法的空间复杂度为O($n^{2}$),其中n为图的顶点数。</strong></li>
<li><strong>稠密图适合使用邻接矩阵的存储表示。</strong></li>
<li><strong>邻接矩阵关于利用矩阵乘法计算路径条数的的重要性质</strong><ul>
<li>矩阵的平方相当于求路径长度为2的路径条数：此时从B到B路径长度为2的路径条数为3<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIBakj.png" alt="pCIBakj.png"></li>
</ul>
</li>
<li>矩阵的立方相当于求路径长度为3的路径条数，此时从B到C路径长度为3的路径条数为4<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIBD10.png" alt="pCIBD10.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>邻接表法（顺序+链式存储✪）</p>
<ul>
<li>对图G中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点$v_{i}$的边(对于有向图则是以顶点为尾的弧)，<br>这个单链表就称为顶点$v_{i}$的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表）</li>
<li>顶点表结点由顶点域(data)和指向第一条邻接边的指针(firstarc)构成，<br>边表（邻接表）结点由邻接点域(adivex)和指向下一条邻接边的指针域(nextarc)构成。</li>
<li>图片<ul>
<li>存储无向图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI2btS.png" alt="pCI2btS.png"></li>
</ul>
</li>
<li>存储有向图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIRrcj.png" alt="pCIRrcj.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li><strong>若G为无向图，则所需的存储空间为O(V+2E)</strong>，<strong>若G为有向图，则所需的存储空间为O(V+E)</strong>。<br>前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。（n个顶点的无向图的邻接表最多含有n(n-1)个边表顶点）</li>
<li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li>
<li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。<ul>
<li>在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)</li>
<li>如果要确定两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li>
</ul>
</li>
<li>在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数，<br>但求其顶点的入度则需要遍历全部的邻接表（<strong>在有向图的邻接表中，顶点v在边表的出现次数等于顶点v的入度</strong>）</li>
<li>图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，<br>它取决于建立邻接表的算法及边的输入次序。</li>
</ul>
</li>
<li>邻接表与邻接矩阵的对比<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIRw4S.png" alt="pCIRw4S.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>十字链表（只能用于存储有向图）</p>
<ul>
<li>空间复杂度为O(V+E)，此时要找顶点的出边顺着绿色路线，要找入边顺序橙色路线。</li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoFIu4.png" alt="pCoFIu4.png"></li>
</ul>
</li>
<li><p>邻接多重表（只能用于存储无向图）</p>
<ul>
<li>空间复杂度为O(V+E)，删除边和顶点很方便</li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoAAoR.png" alt="pCoAAoR.png"></li>
</ul>
</li>
</ul>
<h3 id="3-图的遍历（选择题考点，代码了解即可✪）"><a href="#3-图的遍历（选择题考点，代码了解即可✪）" class="headerlink" title="3.图的遍历（选择题考点，代码了解即可✪）"></a>3.图的遍历（选择题考点，代码了解即可✪）</h3><ul>
<li><p>定义：图的遍历是从图的某一顶点出发，按照某种搜索方法沿着图中的边对图的所有顶点访问一次且仅访问一次。</p>
</li>
<li><p>广度优先搜索（BFS）</p>
<ul>
<li>特点<ul>
<li><strong>与二叉树的层序遍历完全一致，都是利用队列进行遍历操作，出队时将其相邻元素入队</strong><br>（使用数组标记已经入队的顶点不用在入队）</li>
<li>同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一</li>
<li>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</li>
<li>空间复杂度最坏情况下为：O(V)</li>
</ul>
</li>
<li>要点<ul>
<li>找到与一个顶点相邻的所有顶点</li>
<li>标记哪些顶点被访问过（visited数组）</li>
<li><strong>需要一个辅助队列，用队列来暂存刚访问过的结点</strong></li>
</ul>
</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoeoDO.png" alt="pCoeoDO.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoef81.png" alt="pCoef81.png"></li>
</ul>
</li>
<li>时间复杂度分析<ul>
<li>采用邻接表时<ul>
<li>访问 |V| 个顶点需要O(|V|)的时间 </li>
<li>查找各个顶点的邻接点共需要O(|E|)的时间, 时间复杂度${=O(|V|+|E|)}$</li>
</ul>
</li>
<li>采用邻接矩阵时<ul>
<li>访问${|\mathbf{V}|}$个顶点需要${O(|\mathbf{V}|)}$的时间</li>
<li>查找每个顶点的邻接点都需要${O(|V|)}$的时间, 而总共有${|\mathbf{V}|}$个顶点的时间复杂度${=O\left(|V|^{2}\right)}$</li>
</ul>
</li>
</ul>
</li>
<li>广度优先生成树<ul>
<li>同一个图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，<br>但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。</li>
<li><img src="https://s1.ax1x.com/2023/07/17/pConPOK.png" alt="pConPOK.png"></li>
</ul>
</li>
</ul>
</li>
<li>深度优先搜索（DFS）<ul>
<li>特点：<strong>与树的先序遍历类似，采用根左右的顺序，需要借助于栈，最坏的空间复杂度为O(V)</strong></li>
<li>要点：此时不需要队列，但是需要借助于函数调用栈以及标记哪些顶点被访问过的visited数组</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pColTSJ.png" alt="pColTSJ.png"></li>
</ul>
</li>
<li>时间复杂度分析<ul>
<li>采用邻接矩阵：查找每个顶点的邻接点所需的时间为${O(| V|)}$，故总的时间复杂度为${O\left(| V^{2}\right)}$。</li>
<li>采用邻接表：查找所有顶点的邻接点所需的时间为${O(|E|)}$, 访问顶点所需的时间为${O(|V|)}$,<br>此时, 总的时间复杂度为${O(|V|+|E|)}$。</li>
</ul>
</li>
<li>利用邻接表找出深度优先遍历的顺序<ul>
<li>此时的具体方法是，首先找到开始的顶点的那条链，遍历一个之前没有遍历到的元素时，从此元素的链继续开始遍历，<br>如果此链遍历完成，那么退回上一个链继续进行上述有关操作。<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo1MXn.png" alt="pCo1MXn.png"></li>
</ul>
</li>
</ul>
</li>
<li>深度优先生成树<ul>
<li>同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一</li>
<li>同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</li>
</ul>
</li>
</ul>
</li>
<li>图的遍历与图的连通性<ul>
<li>对于无向图遍历调用BFS/DFS函数的次数<ul>
<li>若其为连通的，只需要一次遍历即可</li>
<li><strong>若其为非连通的，此时的遍历次数为其连通分量的数量。</strong></li>
</ul>
</li>
<li>对于有向图遍历调用BFS/DFS函数的次数<ul>
<li>此时情况不确定，若起始顶点到其他各顶点都有路径，则只需调用次1BFS/DFS函数</li>
<li>对于强连通图，从任一结点出发都只需调用1次BFS/DFS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-图的应用（✪）"><a href="#4-图的应用（✪）" class="headerlink" title="4.图的应用（✪）"></a>4.图的应用（✪）</h3><ul>
<li><p>求最小生成树问题（✪）</p>
<ul>
<li>最小生成树的概念<ul>
<li>对于一个<strong>带权连通无向图</strong>G=(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。<br>若T为R中边的权值之和最小的那棵生成树，则T称为G的最小生成树(Minimum-Spanning-Tree,MST)。</li>
<li><strong>最小生成树可能不是唯一的，树形可能不唯一（因为图中可能存在权值相等的边）</strong><ul>
<li>只要无向连通图中没有权值相同的边，则其最小生成树唯一，此说法正确</li>
<li>只要无向连通图中有权值相同的边，则其最小生成树一定不唯一，此说法错误<br>（此时若无向图本身就是一颗树，则最小生成树就是其本身，此时唯一）</li>
</ul>
</li>
<li><strong>最小生成树的边的权值之和总是唯一的（代价唯一且最小）</strong></li>
<li>最小生成树的边数为顶点数量减一</li>
<li>最小生成树的算法基于贪心算法的策略</li>
</ul>
</li>
<li>Prim算法<ul>
<li>概述：从某一个顶点开始构建生成树，之后选择一个与当前树中的集合距离最近的顶点纳入生成树，<br>直到所有顶点都纳入为止。</li>
<li>此时若顶点数量为n，则此时生成的最小生成树的边数为n-1</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo6e4e.png" alt="pCo6e4e.png"></li>
</ul>
</li>
<li>普里姆算法的特点<ul>
<li>时间复杂度：O($V^{2}$)，只与顶点有关，不依赖于边</li>
<li>适合求解边稠密图的最小生成树</li>
</ul>
</li>
</ul>
</li>
<li>kruskal算法<ul>
<li>概述：按边来构建最小生成树，每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）<br>直到所有结点都连通</li>
<li>图片：如此图中，第二次选择的边为权值最小的边，权值为2<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo6dvn.png" alt="pCo6dvn.png"></li>
</ul>
</li>
<li>克鲁斯卡尔算法的特点<ul>
<li>时间复杂度：O($|E|log_{2}E$)，只与边的数量有关，与顶点的数量无关</li>
<li>适合求边稀疏图而顶点多的图的最小生成树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求最短路径问题（✪）</p>
<ul>
<li><p>最短路径的定义</p>
<ul>
<li>从一个顶点到图中其余任意一个顶点的一条路径（可能不止一条）所经过边上的权值之和，<br>定义为该路径的（带权）路径长度，（带权）路径长度最短的称为最短路径</li>
<li>最短路径一定是简单路径</li>
</ul>
</li>
<li><p>求单源最短路径（分为有权图和无权图的求法）</p>
<ul>
<li><p>BFS(广度优先)算法求<strong><u>无权图</u></strong>的单源最短路径问题（无权图相当于每一条边的权值都为1）</p>
<ul>
<li><p>概述：就是对广度优先搜索的小修改，在visit访问一个顶点时，修改其最短路径长度d【】并在path【】记录前驱结点</p>
</li>
<li><p>代码实现</p>
<ul>
<li><strong>由顶点2开始时，2到8的最短路径长度=d[8]=3，通过path数组可知，2到8的最短路径为：8&lt;一7&lt;一6&lt;一2</strong></li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCogyp4.png" alt="pCogyp4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>Dijkstra算法求<strong><u>有权图</u></strong>单源最短路径问题</p>
<ul>
<li>概述<ul>
<li><strong>首先需要设置三个数组（与起始顶点相邻的点的最短路径长度修改为边上的权值，并修改路径前驱为起始点，</strong><br><strong>其余的都设置为最短路径长度为无穷（起始点自身的最短路径长度设置为0），路径前驱为-1）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRPPO.png" alt="pCoRPPO.png"></li>
</ul>
</li>
<li><strong>第一轮：循环遍历所有顶点，优先选择还没有确定最短路径长度并且此时的最短路径长度最小的点进行修改，</strong><br><strong>此时此点为V4，将final值设置为true。并且再进行对其它相邻点的遍历，</strong><br><strong>此时V1需要变动（最短路径长度修改为8，路径前驱修改为4，但是这个时候还不能修改其标志位）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRwJU.png" alt="pCoRwJU.png"></li>
</ul>
</li>
<li><strong>第二轮，在V4遍历完成以后，此时应该开始优先遍历第二个最短路径长度最小的顶点V3，</strong><br><strong>V3修改其标志位，在V3处可以将V2的最短路径的值修改为13，此时前驱变为V3。</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRfJO.png" alt="pCoRfJO.png"></li>
</ul>
</li>
<li><strong>第三轮，在V3遍历完成之后，选择V1进行遍历，此时修改其标志位，</strong><br><strong>并且此时可以修改V2的最短路径长度为9，并将其前驱改变为V3.</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRqTP.png" alt="pCoRqTP.png"></li>
</ul>
</li>
<li><strong>求最短路径的长度时，即为dist数组中的值，求最短路径经过的顶点序列时，根据path数组的值往前推出</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTbyAe.png" alt="pCTbyAe.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li><strong>时间复杂度为O(|$V^{2}$|)</strong></li>
<li>不适用于边上带有负权值的图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Floyd算法求各<u><strong>顶点之间</strong></u>最短路径问题</p>
<ul>
<li>概述：使用的是动态规划的思想，通过设置中转点依次来求解，<br>此时需要两个矩阵（一个表示最短路径，另一个表示中转点）</li>
<li>特点<ul>
<li><strong>时间复杂度为O($V^{3}$)</strong></li>
<li>可以用于计算负权值带权图的计算，但是不适用于带有“负权回路”的图（有负权值的边组成回路），这种图有可能没有最短路径</li>
</ul>
</li>
<li><strong>最短路径的表中首先把存在直接联系的的路径长度写上，之后将中转点矩阵中的值均设为-1</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4AtP.png" alt="pCo4AtP.png"></li>
</ul>
</li>
<li><strong>之后规定可以将V0作为中转点，按照表格依次进行遍历，需要满足两个顶点之间经过此中转点之后的路径长度小于原来的长度。此时v2到v1的路径可以修改为11，并且中转矩阵所对应的相关值修改为中转点0</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo43t0.png" alt="pCo43t0.png"></li>
</ul>
</li>
<li><strong>遍历完成后，之后规定可以将V1,V0作为中转点，此时可以修改v0到v2的相关值</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4w7R.png" alt="pCo4w7R.png"></li>
</ul>
</li>
<li><strong>最后将v0、v1、v2均设置为中转点，此时可以将v1到v0的相关值进行修改</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4Dtx.png" alt="pCo4Dtx.png"></li>
</ul>
</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4T9f.png" alt="pCo4T9f.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>三种求最短路径的算法之间的差异</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo593T.png" alt="pCo593T.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>求有向无环图描述表达式问题（DAG图，了解）</p>
<ul>
<li>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图(Directed Acyclic Graph)</li>
<li><p>有向无环图可以描述含有公共子式的表达式。并可将重复出现的子表达式共享，节省存储空间</p>
</li>
<li><p>解题思路</p>
<ul>
<li>首先根据规则先画好基本的有向无环图<ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTGNzF.png" alt="pCTGNzF.png"></li>
</ul>
</li>
<li>之后逐层的合体相同的运算符（该层的运算符的两个指向边都分别对应到相同的元素就合并）<ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTGWsH.png" alt="pCTGWsH.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求拓扑排序问题（主要是会手算✪）</p>
<ul>
<li>AOV网 （一种有向无环图）<ul>
<li><strong><u>顶点</u>表示活动的网络的有向图</strong>，有向边${<V_{i},V_{j}>}$表示活动${V_{i}}$必须先于活动${V_{j}}$进行</V_{i},V_{j}></li>
</ul>
</li>
<li>拓扑排序：找到做事的先后顺序（<strong>同时可以判断图中是否存在回路</strong>）<ul>
<li>拓扑排序的特点（当且仅当满足以下的条件时）<ul>
<li>每个顶点出现且只出现一次</li>
<li>若顶点A在序列中排在顶点B的前面，则在图中不存在从J顶点B到顶点A的路径。</li>
</ul>
</li>
<li>拓扑排序的流程<ul>
<li>从AOV网中选择一个没有前驱(入度为0)的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为起点的有向边。</li>
<li>重复之前的操作直到当前的AOV网为空或当前网中不存在无前驱的顶点（说明此时存在回路）为止。</li>
</ul>
</li>
<li>拓扑排序算法代码实现（DFS(深度优先遍历)也可以得出相应的拓扑排序序列，了解）<ul>
<li><strong>建立两个数组，分别表示当前顶点的入度情况以及记录生成拓扑的序列，<br>且用一个栈保存度为0的待处理顶点，也可以用队列</strong><br><strong>首先填写入度表中的各顶点的值，并将有向无序图中入度为0的点依次入栈，该图中有两个顶点0、2可依次入栈</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTYbrQ.png" alt="pCTYbrQ.png"></li>
</ul>
</li>
<li><strong>之后首先弹出栈顶的顶点2，将拓补序列的第一号位修改为2并移动计数指针（序列的第一号即为2）</strong><br><strong>，此时将2的后继结点“3、4”的入度减一，由于此时3、4的入度还不为0，因此暂时不能入栈）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTtZPx.png" alt="pCTtZPx.png"></li>
</ul>
</li>
<li><strong>按照上述过程，此时再将栈顶的顶点0弹出，此时顶点1的入度减一，作为入度为0的顶点入栈，</strong><br><strong>之后依次类推，最后的拓扑顺序为：2、0、1、3、4</strong></li>
<li><strong>进行如果最后的计数指针的数量等于顶点数，此时就得到了相应的拓扑排序序列，</strong><br><strong>否则说明有向无序图中存在环路，无法进行排序，不是AOV网</strong></li>
</ul>
</li>
<li><strong>时间复杂度：采用邻接表时为${O(|V|+|E|)}$，若采用邻接矩阵, 则需${O\left(|V|^{2}\right)}$</strong></li>
</ul>
</li>
<li><strong>逆拓扑排序则是以没有出度的顶点开始排序，此时可以使用DFS(深度优先遍历)的算法进行操作得出逆拓扑排序序列，</strong><br><strong>此时在顶点退栈前输出序列</strong></li>
<li>拓扑排序算法的相关注意事项<ul>
<li><strong>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</strong></li>
<li><strong>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一（但是也不是绝对的，如下面的例题中有经典的反例）</strong></li>
<li>若各个顶点已经排在一个<strong>线性有序</strong>的序列中，每个顶点有<strong>唯一的前驱后继</strong>关系，则拓扑排序的结果是唯一的<ul>
<li>判断：若有向无环图的拓扑序列唯一，则可以唯一确定此图（X），可举出下面的反例<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTLOmV.png" alt="pCTLOmV.png"></li>
</ul>
</li>
</ul>
</li>
<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，<br>生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵</li>
<li><strong>但对于一般的图来说，若其邻接矩阵是三角矩阵（不存在环），则存在拓扑序列，反之则不一定成立。</strong><ul>
<li>反之成立的条件是此有向图的拓扑排序序列是有序的</li>
</ul>
</li>
</ul>
</li>
<li>例题<ul>
<li>例题1：本题选D，此时可以举出一个经典的反例如下图<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTL3i4.png" alt="pCTL3i4.png"><ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTLsWd.png" alt="pCTLsWd.png"></li>
</ul>
</li>
</ul>
</li>
<li>例题2：此题选D，此时不能排成一个拓扑序列说明该图中存在环，AC选项用一个三角形环就可以排除；<br>对于B选项，连通图是指需要任意两个端点之间可以互相到达的图，如果此时用一个三角形环外加从外面指向一个单独顶点的线，<br>此时该单独顶点无法到达其它顶点，故不是强连通图。只有D满足相关的情况<ul>
<li>若一个有向图的顶点不能排成一个拓扑序列（即存在环路），则可以判定该有向图<strong>含有</strong>顶点数大于1的强连通分量。<br>这是因为环路中的顶点构成了至少一个强连通分量，并且强连通分量中的顶点数大于1。</li>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTO4nx.png" alt="pCTO4nx.png"></li>
</ul>
</li>
<li>例题3，找到拓扑排序的所有序列，用逐次列举的方法来找，不用去考虑机算方法，可以通过画圈辅助判断<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTvBnI.png" alt="pCTvBnI.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求关键路径问题（✪）</p>
<ul>
<li>AOE网概念（一种有向无环图）<ul>
<li>在带权有向图中, <u>以顶点表示事件</u>, <strong>以有向边表示活动</strong>，以边上的权值表示完成该活动的开销（如完成活动所需的时间），<br>称之为<strong>用边表示活动的网络</strong>,简称AOE网 (Activity On Edge NetWork)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTUdEj.png" alt="pCTUdEj.png"></li>
</ul>
</li>
</ul>
</li>
<li>AOE网的两个性质<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li>
<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。<br>另外，有些活动是可以并行进行的</li>
</ul>
</li>
<li>源点与汇点<ul>
<li>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；</li>
<li>也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li>
</ul>
</li>
<li>关键路径与关键活动（<strong>求关键路径是以拓扑排序为基础的</strong>）<ul>
<li><strong>从源点到汇点的有向路径可能有多条，所有路径中，具有<u>最大路径长度</u>的路径称为关键路径</strong></li>
<li><strong>关键路径上的活动称为关键活动，它是决定整个工程的关键因素</strong></li>
<li><strong>完成整个工程的最短时间就是关键路径的长度（关键路径上各活动花费开销的总和），</strong><br><strong>若关键活动不能按时完成，则整个工程的完成时间就会延长（在关键路径上的活动的时间延长多少，整个工程的时间也就随之延长多少）</strong></li>
<li><strong>可以通过加快关键活动（减少关键活动的时间）来缩短整个工程的工期。</strong><br><strong>但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</strong></li>
<li><strong>网络图的关键路径并不唯一，且对于有几条关键路径的网，</strong><br><strong>缩短关键路径上任意一个或多个只包括在一条关键路径的关键活动的持续时间并不能缩短关键路径的长度，</strong><br><strong>需要缩短那些包括在<u>所有</u>关键路径上的关键活动的持续时间才能缩短关键路径的长度。</strong><ul>
<li>关于缩短关键路径长度的例题<ul>
<li>例题1，本题选择C，对于关键路径长度来说，增加是可以增大关键路径长度的，<br>但是缩短需要在一定的条件下才能缩短关键路径长度<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTomM8.png" alt="pCTomM8.png"></li>
</ul>
</li>
<li>例题2，本题选择C，该题的关键路径经过计算得出为：b,d,c,g；b,d,e,h；b,f,h。<br>此时只有C选项的f与d可以同时作用到三条关键路径上，其它的选项只能作用到其中的一条或两条。<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTonsS.png" alt="pCTonsS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>求关键路径与关键活动以及相关的参数（<strong>求关键路径同时也可以判断图中是否存在回路</strong>）<ul>
<li>注意区别事件(顶点)的最早/最迟开始时间与活动(弧)的最早/最迟开始时间。<ul>
<li>时间余量=下一个顶点的最迟开始时间-活动持续时间—起始顶点的最早开始时间</li>
<li>顶点（事件）的最迟开始时间等于=起始顶点的最早开始时间+时间余量</li>
<li>弧（活动）的最早开始时间等于：弧的起始顶点的最早开始时间</li>
<li>弧（活动）的最迟开始时间等于：下一个顶点的最迟发生时间—该活动的持续时间</li>
</ul>
</li>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTHwdg.jpg" alt="pCTHwdg.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第五章-树与二叉树</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h2><blockquote>
<p>计算机学科基础：数据结构第五章树与二叉树学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-树的基本概念（✠）"><a href="#1-树的基本概念（✠）" class="headerlink" title="1.树的基本概念（✠）"></a>1.树的基本概念（✠）</h3><ul>
<li><p>①树的定义：</p>
<ul>
<li>树是n(n≥0)个结点的有限集，是一种递归定义的数据结构。当n=0时，称为空树。</li>
<li>在任意一棵非空树中应满足<ul>
<li>有且仅有一个特定的称为根的结点。</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2……Tm<br>其中每个集合本身又是一棵树，并且称为根的子树。</li>
</ul>
</li>
</ul>
</li>
<li><p>②树的基本术语</p>
<ul>
<li>结点的关系图谱：祖先、子孙、双亲（父节点）（根结点是唯一没有双亲的结点）<br>孩子、兄弟（有相同双亲的结点）、堂兄弟（同一层非同父节点）</li>
<li>路径和路径长度。<ul>
<li>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数；</li>
<li>树的路径长度是从树根到每个结点的路径长度的<u>总和</u>（路径只能是由上往下的，同一层之间不存在路径）</li>
</ul>
</li>
<li>结点的深度、层次（从上往下数）；结点的高度（从下往上数）；树的高度（或深度）是树中结点的最大层数</li>
<li>度：<strong>一个结点的孩子个数</strong>；<br>树的度：树中结点的最大度数<ul>
<li>如度为4的树：存在某结点至少有4个孩子结点（而不是至少在某一层正好有4个结点）</li>
<li>度大于0：分支节点（每个结点的分支数就是该结点的度）</li>
<li>度等于0：叶子节点</li>
</ul>
</li>
<li>有序树与无序树（从左到右有无次序）</li>
<li>森林：森林是m(m≥0)棵互不相交的树的集合</li>
</ul>
</li>
<li>③树的性质（选择题考点✪）<ul>
<li>树的结点数=总度数+1（总度数也等于分支数）<ul>
<li>例，此题选B，由总度数+1=结点数，叶子结点个数=总度数-其它非叶子结点的结点个数<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWf6u6.png" alt="pCWf6u6.png"></li>
</ul>
</li>
</ul>
</li>
<li>区分度为m的树和m叉树<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWcsPI.png" alt="pCWcsPI.png"></li>
</ul>
</li>
<li>度为m的树第i层最多有$m^{i-1}$个结点(i≥1)；m叉树第i层最多有$m^{i-1}$个结点 (i≥1)</li>
<li>高度为h的m叉树最多有$\frac{m^{h}-1}{m-1}$个结点（由等比数列求和公式得）</li>
<li>高度为h的m叉树最少有h个结点；高度为h，度为m的树最少有h+m-1个结点<ul>
<li>此时也可以反过来说，度为m，结点数为n的树，高度最多为n-m+1</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCW2f4s.png" alt="pCW2f4s.png"></li>
</ul>
</li>
</ul>
</li>
<li>具有n个结点的m叉树（或度为m）的最小高度为    $\left\lceil\log _{m}(n(m-1)+1)\right\rceil$<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWR9KK.png" alt="pCWR9KK.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-二叉树（✪）"><a href="#2-二叉树（✪）" class="headerlink" title="2.二叉树（✪）"></a>2.二叉树（✪）</h3><ul>
<li><p>①二叉树的定义</p>
<ul>
<li>二叉树是n(n≥0)个结点的有限集合，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）</li>
<li>或者为空二叉树，即n=0</li>
<li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。<br>左子树和右子树又分别是一棵二叉树（二叉树是有序树，左右次序不能颠倒）</li>
</ul>
</li>
<li><p>②特殊的二叉树</p>
<ul>
<li>满二叉树<ul>
<li>一棵高度为h，且含有$2^{h}-1$个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点</li>
<li>满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2，不存在度为1的结点</li>
<li>按层序从1开始编号，结点ⅰ的左孩子为2i，右孩子为2i+1，结点i的父节点 ⌊i/2⌋（如果有的话）</li>
</ul>
</li>
<li>完全二叉树<ul>
<li>高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</li>
<li>若i ≤ ⌊n/2⌋，则结点i为分支结点，否则为叶结点。</li>
<li><strong>若一棵完全二叉树中的结点无左孩子，则其必是叶节点</strong></li>
<li>叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排列在该层最左边的位置上。</li>
<li>若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li>
<li>按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点。</li>
<li>若结点数n为奇数，则每个分支结点都有左孩子和右孩子；</li>
<li>若n为偶数，则编号最大的分支结点(编号为n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCfAsD1.png" alt="pCfAsD1.png"></li>
</ul>
</li>
</ul>
</li>
<li>二叉排序树<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字</li>
<li>右子树上的所有结点的关键字均大于根结点的关键字</li>
<li>左子树和右子树又各是一棵二叉排序树。</li>
<li><strong>将二叉排序树的<u>先序序列</u>中的关键字依次插入初始为空的树中，所得到的二叉排序树与原二叉排序树是相同的</strong></li>
</ul>
</li>
<li>平衡二叉树：树上任意一个结点的左子树和右子树的深度之差不超过1。<ul>
<li><strong>对于高度为n的平衡二叉树，最少需h(n)个结点，最多需要2n-1个结点。</strong></li>
<li><strong>h(n)=h(n-1)+h(n-2)+1</strong></li>
<li><strong>h(0)=0，h(1)=1，h(2)=2</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>③二叉树的性质（选择题考点♚）</p>
<ul>
<li><strong>非空二叉树上的叶结点数等于度为2的结点数加1，即$n_{0}=n_{2}+1$</strong><ul>
<li>可由$n=n_{0}+n_{1}+n_{2}$与$n=n_{1}+2n_{2}+1$得来</li>
</ul>
</li>
<li><strong>二叉树第i层上至多有$2^{i-1}$个结点(i≥1)</strong></li>
<li><strong>高度为h的二叉树至多有$2^{h}-1$个结点（满二叉树），最少有$2^{h-1}$个结点</strong></li>
<li><strong>具有n个${(n&gt;0)}$ 结点的完全二叉树的高度h为${\left\lceil\log _{2}(n+1)\right\rceil}$ 或 $\left\lfloor\log _{2} n\right\rfloor+1$</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfVgpD.png" alt="pCfVgpD.png"></li>
</ul>
</li>
<li><strong>第i个结点所在层次为${\left\lceil\log _{2}(n+1)\right\rceil}$ 或 $\left\lfloor\log _{2} n\right\rfloor+1$</strong></li>
<li>对于<strong>完全二叉树</strong>，可以由节点数推出各类结点的数量情况，分为结点总数n为奇数或偶数<ul>
<li>完全二叉树的度为1的结点数量最多为1，$n_{1}=1或0$</li>
<li>当n=2k时，此时$n_{1}=1,n_{0}=k,n_{2}=k+1$ <strong>（完全二叉树有偶数个结点时，叶子结点的个数为总结点数除以2）</strong></li>
<li>当n=2k-1时，此时$n_{1}=0,n_{0}=k,n_{2}=k+1$<strong>（有奇数个结点时，叶子结点的个数为总结点数+1再除以2）</strong></li>
<li>完全二叉树如果所有的非空结点都有两个子节点，说明其有奇数个结点，此时结点总数=2*叶子节点总数-1</li>
</ul>
</li>
<li>有关性质例题的考察<ul>
<li>例题1：这种题通过画出二叉树的情况来找规律即可，选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfxZ9I.png" alt="pCfxZ9I.png"></li>
</ul>
</li>
<li>例题2：给出完全二叉树具体一层的叶结点数量，求最多和最少得结点总数<br>（重要信息：完全二叉树的叶结点只有可能存在于最后一层和倒数第二层）<ul>
<li>结点数量最少时，该层即为最后一层，如此题为前五层满二叉树+8=39，</li>
<li>结点数量最多时，该层为倒数第二层，如此题为总七层-8*2=111</li>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfzZa4.png" alt="pCfzZa4.png"></li>
</ul>
</li>
<li>例题3：最小高度往往是满二叉树时，存放该二叉树至少需要的结点数量（最坏的情况，也为满二叉树时）分别选C、A<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pChSuTg.png" alt="pChSuTg.png"></li>
<li><a href="https://imgse.com/i/pChSmm8"><img src="https://s1.ax1x.com/2023/07/12/pChSmm8.png" alt="pChSmm8.png"></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>④二叉树的存储结构</p>
<ul>
<li><p>二叉树的顺序存储</p>
<ul>
<li><p>对于完全二叉树，顺序存储的结构较为合适，此时可以较好的反映出结点之间的逻辑关系，也能节省存储空间</p>
<ul>
<li><a href="https://imgse.com/i/pCfHGVI"><img src="https://s1.ax1x.com/2023/07/12/pCfHGVI.png" alt="pCfHGVI.png"></a></li>
</ul>
</li>
<li><p>对于一般的二叉树，需要用0来表示并不存在的空结点，以便于反映二叉树的逻辑结构，但是此时会浪费较多的存储空间</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfHYIP.png" alt="pCfHYIP.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的链式存储</p>
<ul>
<li><p>又称为<strong>二叉链表</strong>，由数据域，左指针域，右指针域组成</p>
</li>
<li><p><strong>n个结点的二叉链表共有n+1个空链域，有n-1个非空链域</strong><br>链域是指左指针或右指针</p>
</li>
<li><p>关于三叉链表：再定义一个父指针指向父节点，方便查找（在后序线索树中可找到后序后继结点）</p>
</li>
<li><p>链式存储的代码实现</p>
<ul>
<li><p>定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化以及插入节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BiTree root=<span class="literal">NULL</span>; <span class="comment">//定义一颗空树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data=<span class="number">1</span>;</span><br><span class="line">root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchlid=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data=<span class="number">2</span>;</span><br><span class="line">p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild=p; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-二叉树的遍历（✪）"><a href="#3-二叉树的遍历（✪）" class="headerlink" title="3.二叉树的遍历（✪）"></a>3.二叉树的遍历（✪）</h3><ul>
<li><p>三种基本遍历</p>
<ul>
<li><p>如中序遍历，先递归遍历左子树，再访问根节点，再递归遍历右子树，二叉树为空则什么都不做。</p>
</li>
<li><p>这三种遍历方法的时间复杂度都是O(n)，每个结点都会被访问一次</p>
</li>
<li><p><strong>二叉树的前中后序遍历中，所有叶节点的顺序完全相同</strong></p>
</li>
<li><p><strong>若一个二叉树的先序和后序序列正好相反，则该二叉树的高度等于结点数，只有一个叶节点</strong></p>
</li>
<li><p>先序序列与中序序列的关系相当于，以先序序列为入栈次序，以中序队列为出栈次序</p>
</li>
<li><p>先序序列为a,b,c,d，求不同二叉树的个数（使用卡特兰数的公式$\frac{1}{n+1}C^{n}_{2n}$）</p>
</li>
<li><p>可用递归子树思想的方法来求出遍历次序</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pChpkEF.png" alt="pChpkEF.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>先序遍历（NLR，根左右）<br>在前序遍历的二叉树中，任何结点的子树的所有结点都是直接跟在该结点的之后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     visit(T);</span><br><span class="line">     preOrder(T-&gt;lchild);</span><br><span class="line">     preOrder(T-&gt;rchild);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历（LNR，左根右）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     InOrder(T-&gt;lchild);</span><br><span class="line">     visit(T);</span><br><span class="line">     InOrder(T-&gt;rchild);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历（LRN，左右根，可找到从子孙到祖先的路径）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     PostOrder(T-&gt;lchild);</span><br><span class="line">     PostOrder(T-&gt;rchild);</span><br><span class="line">     visit(T);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求树的深度</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCh9ydO.png" alt="pCh9ydO.png"></li>
</ul>
</li>
<li><p>层次遍历二叉树</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/13/pChf03j.png" alt="pChf03j.png"></li>
</ul>
</li>
<li><p>由遍历构造二叉树</p>
<ul>
<li>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树，需要和中序遍历组合才行</li>
<li>前序加中序确定二叉树结构<ul>
<li>以前序序列的第一个单位为准，在中序遍历中确定其左右子树，之后的子树的根节点都以前序遍历靠前的元素为准</li>
<li><img src="https://s1.ax1x.com/2023/07/13/pCh7prj.png" alt="pCh7prj.png"></li>
</ul>
</li>
<li>后序加中序确定二叉树结构<ul>
<li>以后序遍历的最后一个元素为准，在中序遍历中确定其左右子树，之后的子树的根节点都以后序遍历靠后的元素为准</li>
<li><img src="https://s1.ax1x.com/2023/07/13/pCh7iaq.png" alt="pCh7iaq.png"></li>
</ul>
</li>
<li>层序加中序确定二叉树结构<ul>
<li><img src="https://s1.ax1x.com/2023/07/13/pChHXjg.png" alt="pChHXjg.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-线索二叉树（选择题考点，代码无需掌握✪）"><a href="#4-线索二叉树（选择题考点，代码无需掌握✪）" class="headerlink" title="4.线索二叉树（选择题考点，代码无需掌握✪）"></a>4.线索二叉树（选择题考点，代码无需掌握✪）</h3><ul>
<li><p>作用：方便从一个结点出发，找到其前驱、后继，<br>此时先序线索二叉树和中序线索二叉树进行遍历时不需要栈的支持（进行）递归，但是后序线索二叉树仍需要栈的支持</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4wIUI.png" alt="pC4wIUI.png"></li>
</ul>
</li>
<li><p><strong>线索：指向前驱和后继的指针，n个结点的二叉树含有n+1个空指针</strong><br><strong>n个结点的线索二叉树含有n+1个线索</strong></p>
</li>
<li><p><strong>二叉树的线索化就是将二叉链表中的空指针改为指向前驱或后驱的线索</strong><br><strong>按照遍历的顺序进行，如果指针已经指向相应结点则不变动，如果没有空指针就跳过）</strong></p>
</li>
<li><p>存储结构</p>
<ul>
<li>在普通二叉树结点的基础上，增加标志位：Itag和rtag （等于0此结点有孩子，等于1此结点被线索化）</li>
<li>ltag\==1时，表示Ichild指向前驱；Itag\==0时，表示Ichild指向左孩子</li>
<li>rtag\==1时，表示rchild指向后继；rtag\==0时，表示rchild指向右孩子</li>
</ul>
</li>
<li><p>线索化二叉树（代码了解即可）</p>
<ul>
<li><p>线索二叉树的存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;  <span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>; <span class="comment">//设定当前访问结点的前驱，并初始化</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  <span class="comment">//线索化非空二叉树</span></span><br><span class="line">        InThread(T,pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>; <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>; <span class="comment">//改变其标志符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre); <span class="comment">//递归，线索化左子树（按照中序遍历，先遍历左子树）</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;  <span class="comment">//若当前结点左子树为空时，建立前驱线索,左指针指向前驱</span></span><br><span class="line">            P-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p; <span class="comment">//建立前驱节点的后继线索</span></span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p; <span class="comment">//完成以上操作之后，将前驱结点指向当前所遍历到的结点</span></span><br><span class="line">        InThread(p-&gt;rchild,pre); <span class="comment">//递归线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于先序线索化而言只需要将其线索化左子树的操作写在前面，中间是根结点的操作，最后是线索化右子树的操作</p>
<ul>
<li>注：此时在ltag==0时，才能对左子树先序线索化</li>
</ul>
</li>
<li><p>对于后序线索化而言只需要将其线索化左子树的操作写在前面，中间是线索化右子树的操作，最后是根结点的操作</p>
</li>
</ul>
</li>
<li><p>线索二叉树的遍历（会推出各种遍历序列即可✪）</p>
<ul>
<li><p>中序线索二叉树的遍历</p>
<ul>
<li><p>进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。</p>
</li>
<li><p>首先找到中序线索二叉树的第一个结点 （最左下的结点，不一定为叶节点）</p>
<ul>
<li><p>代码实现（求中序线索二叉树中中序序列下的第一个结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;lchild; (遍历找到最左下的结点，不一定是叶结点)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>之后找中序后继结点</p>
<ul>
<li><p>若此时p-&gt;rtag==1,则next=p-&gt;rchild （此时右链为线索，指向其后继）</p>
</li>
<li><p><strong>p-&gt;ratg==0时，此时右子树不为空，则遍历右子树的第一个访问结点（右子树最左下的结点为其后继）</strong></p>
</li>
<li><p>代码实现（求中序线索二叉树中结点p在中序序列下的后继）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThreadNode *<span class="title function_">Nexttnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild); <span class="comment">//不为空，找到其右子树的最左下角的结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//右标志为1直接返回线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历中序二叉树的代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line">		visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序线索二叉树找到中序前驱</p>
<ul>
<li>若此时p-&gt;ltag==1，此时直接返回左线索</li>
<li>若此时p-&gt;ltag==0，则p结点的左子树中，最右下角的结点就是其前驱结点</li>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4dIpT.png" alt="pC4dIpT.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>先序线索二叉树的遍历</p>
<ul>
<li><p>先序线索二叉树的先序后继</p>
<ul>
<li>若右标志位为0时，首先看先序线索二叉树有无左孩子，如果有的话，就是其先序后继，如果只有右孩子没有左孩子，那么右孩子为其先序后继</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4wFHA.png" alt="pC4wFHA.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>先序线索二叉树不能在左标志位为0的情况下找到先序前驱</p>
</li>
</ul>
</li>
<li><p>后序线索二叉树的遍历</p>
<ul>
<li><p>后序线索二叉树找后序前驱</p>
<ul>
<li>若左标志位为0时，此时如果其有右孩子，那么此右孩子为其后序前驱，如果只有左孩子没有右孩子，那么左孩子为其后序前驱</li>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4wqxS.png" alt="pC4wqxS.png"></li>
</ul>
</li>
<li><p>后序线索二叉树找后序后继</p>
<ul>
<li>如果此时右标志位为0，则不能有效的找到后序后继</li>
<li>此时可以用三叉链表来找到其后序后继<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC40yZj.png" alt="pC40yZj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三种线索二叉树遍历的总结</p>
<ul>
<li>对于中序线索二叉树来说可从任意结点进行遍历和逆向遍历；对于前序线索二叉树来说，只可进行顺向遍历；对于后序线索二叉树来说，只可进行逆向遍历</li>
<li><img src="https://s1.ax1x.com/2023/07/14/pC402iq.png" alt="pC402iq.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-树、森林（✪）"><a href="#5-树、森林（✪）" class="headerlink" title="5.树、森林（✪）"></a>5.树、森林（✪）</h3><ul>
<li><p>树的存储结构（✪）</p>
<ul>
<li><p>双亲表示法（顺序存储✪）</p>
<ul>
<li><p>这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。<br>根结点下标为0，其伪指针域为-1。</p>
</li>
<li><p>特点：该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，<br>但求结点的孩子时则需要遍历整个结构。</p>
</li>
<li><p>适用于找父节点较多找孩子结点较少的树，如并查集</p>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">//树中最多的结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE]; <span class="comment">//双亲表示法</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC45BlQ.png" alt="pC45BlQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>孩子表示法（顺序存储+链式存储）</p>
<ul>
<li><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表<br>叶结点的孩子链表为空表</p>
</li>
<li><p>用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针</p>
</li>
<li><p>特点：这种存储结构寻找子女的操作非常直接，而寻找双亲的操作需要遍历个结点中孩子链表指针域所指向的n个孩子链表，适用于服务流程树。</p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child; <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r; <span class="comment">//结点数与根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC45OfO.png" alt="pC45OfO.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>孩子兄弟表示法（链式存储✪）</p>
<ul>
<li><p>又称为二叉树表示法，即以二叉链表作为树的存储结构，<br>包括结点值，<strong>指向结点第一个孩子的结点指针，以及指向结点下一个兄弟结点的指针</strong></p>
</li>
<li><p>特点：易于查找孩子，但是不易于查找双亲，可以方便实现树转换成二叉树的操作。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4qwEd.png" alt="pC4qwEd.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>树、森林与二叉树的转换（会画✪）</p>
<ul>
<li>树转换为二叉树：<strong>转换后的二叉树一定没有右子树</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4LLSP.png" alt="pC4LLSP.png"></li>
</ul>
</li>
<li>森林转换为二叉树<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4Lxeg.png" alt="pC4Lxeg.png"></li>
</ul>
</li>
<li>二叉树转换为树<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4OJmD.png" alt="pC4OJmD.png"></li>
</ul>
</li>
<li>二叉树转换成森林<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4OB1P.png" alt="pC4OB1P.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>树和森林的遍历（✪）</p>
<ul>
<li>树的遍历<ul>
<li>先根遍历<strong>（等同于对相应二叉树的先序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4j9x0.png" alt="pC4j9x0.png"></li>
</ul>
</li>
<li>后根遍历<strong>（等同于对相应二叉树的中序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jirT.png" alt="pC4jirT.png"></li>
</ul>
</li>
<li>层序遍历<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jFqU.png" alt="pC4jFqU.png"></li>
</ul>
</li>
</ul>
</li>
<li>森林的遍历<ul>
<li>先序遍历<strong>（等同于对所对应的二叉树依次进行先序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jdQP.png" alt="pC4jdQP.png"></li>
</ul>
</li>
<li>中序遍历<strong>（等同于对所对应的二叉树依次进行中序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jwsf.png" alt="pC4jwsf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-树与二叉树的应用（✪）"><a href="#6-树与二叉树的应用（✪）" class="headerlink" title="6.树与二叉树的应用（✪）"></a>6.树与二叉树的应用（✪）</h3><ul>
<li><p>哈夫曼树和哈夫曼编码</p>
<ul>
<li>带权路径长度：从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度。<br>树中所有叶结点的带权路径长度之和称为该树的带权路径长度（WPL）。</li>
<li>哈夫曼树<ul>
<li>在含有个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树</li>
<li>哈夫曼树的构造<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5gv7T.png" alt="pC5gv7T.png"></li>
</ul>
</li>
<li>注：如果之后的两个单独的叶子结点的构造出的权值比它于树的根构造出的权值更小，那么两个叶子结点先自行构造<ul>
<li>如此题选C，此时9和12先进行自行的构造<img src="https://s1.ax1x.com/2023/07/16/pCIAbGV.png" alt="pCIAbGV.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li><strong>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</strong></li>
<li><strong>构建过程中共创建了n-1个新结点（非叶结点），哈夫曼树的结点总数为2n-1</strong><ul>
<li>如此题：度为m,此时若含有n个叶子结点，则总的需要处理的结点数为n-1个，此时每次将处理m-1个，因此非叶子结点的数量为$\frac{n-1}{m-1}$<img src="https://s1.ax1x.com/2023/07/16/pCIVe6U.png" alt="pCIVe6U.png"></li>
</ul>
</li>
<li><strong>哈夫曼树中不存在度为1的结点。</strong></li>
<li><strong>哈夫曼树并不唯一，但WPL必然相同且为最优</strong></li>
</ul>
</li>
</ul>
</li>
<li>哈夫曼编码（一种被广泛应用而且非常有效的数据压缩编码）<ul>
<li>固定长度编码与可变长度编码<ul>
<li>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。</li>
<li>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。</li>
<li>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</li>
</ul>
</li>
<li>前缀编码：若没有一个编码是另一个编码的前缀，则成为前缀编码，此时将不会产生歧义<ul>
<li>采用的前一位数的编码将会影响后一位数的编码<ul>
<li>例题<img src="https://s1.ax1x.com/2023/07/16/pCIAfKg.png" alt="pCIAfKg.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIA4bj.png" alt="pCIA4bj.png"></li>
</ul>
</li>
</ul>
</li>
<li>通过哈夫曼编码可以构造哈夫曼树，此时最大编码长度为树的带权路径长度（WPL），并且可以算出压缩的数据率<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC52mND.png" alt="pC52mND.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>并查集（集合逻辑结构）</p>
<ul>
<li><p>集合的表示：要将元素划分为互不相交的子集。可以用互不相交的树，来表示多个集合</p>
</li>
<li><p>存储结构：使用双亲表示法，双亲指针指向其父节点的序号</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC570F1.png" alt="pC570F1.png"></li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li><p>初始化：将所有元素初始化为-1。</p>
<ul>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE]; <span class="comment">//双亲指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span>; <span class="comment">//初始化时，数组指针设置为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查操作（时间复杂度为 O(n)）</p>
<ul>
<li><p>如何查到某个元素属于哪个集合：可以通过树的根结点来判断</p>
</li>
<li><p>如何判断两个元素之间的关系：通过对比各自所在的树的根结点来判断</p>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)	<span class="comment">//循环寻找x的根（一般设置为-1）</span></span><br><span class="line">        x=S[x]; </span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//此时找到x的根，返回之</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>并操作（时间复杂度为 O(1)，并操作n个独立元素为一个集合则需要O($n^{2}$)）</p>
<ul>
<li><p>让一棵树成为另一棵树的子树即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> ROOt2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>; <span class="comment">//此时要求两个是不同的集合</span></span><br><span class="line">    S[Root2]=Root1; <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对并查集的并操作作优化</p>
<ul>
<li>此时将根结点的值设置为负数（表示其树的结点的总数，有利于将较小的树合并到更大的树，可以控制高度不变）</li>
<li>当合并时，小树的双亲指针变为大树的数组下标，此时大树的指针需要累加结点总数</li>
<li>进行优化之后，查操作的时间复杂度可变为：$O ( \log _ { 2 } n )$</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5HUc8.png" alt="pC5HUc8.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>对并查集的进一步优化（优化查操作）</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5bn5n.png" alt="pC5bn5n.png"></li>
</ul>
</li>
<li><p>并查集的优化后的时间复杂度的变化</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5bQ2V.png" alt="pC5bQ2V.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第四章-串</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="数据结构第四章-串"><a href="#数据结构第四章-串" class="headerlink" title="数据结构第四章-串"></a>数据结构第四章-串</h2><blockquote>
<p>计算机学科基础：数据结构第四章串的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-串的定义（特殊的线性表，了解）"><a href="#1-串的定义（特殊的线性表，了解）" class="headerlink" title="1.串的定义（特殊的线性表，了解）"></a>1.串的定义（特殊的线性表，了解）</h3><ul>
<li>定义：串是由零个或多个字符组成的有限序列（串的数据对象限定为字符集）</li>
<li>串中字符的个数n称为串的长度。n=0时的串称为空串</li>
<li>串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。（以子串作为操作对象）</li>
<li>某个字符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。</li>
<li>两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。</li>
</ul>
<h3 id="2-串的模式匹配（串的定位操作✪）"><a href="#2-串的模式匹配（串的定位操作✪）" class="headerlink" title="2.串的模式匹配（串的定位操作✪）"></a>2.串的模式匹配（串的定位操作✪）</h3><ul>
<li><p>子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。</p>
</li>
<li><p>KMP算法（选择题考点✪）</p>
<ul>
<li><p>每次匹配失败之后，无需回溯主串指针，根据next数组的对应关系来决定当前的模式串的指针设置<br>next数组只与模式串有关，与主串无关</p>
</li>
<li><p>利用next数组控制指针回溯的举例</p>
<ul>
<li>此时在第五个元素匹配失败之后，只需要将模式串指针移动到2位置继续与主串的5位置比较<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCW1ak9.png" alt="pCW1ak9.png"></li>
</ul>
</li>
<li>移动之后的情况如下<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFsrZR.png" alt="pPFsrZR.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]; <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：O(m+n)</p>
</li>
</ul>
</li>
<li><p>求next数组（选择题考点，手算方法♚）</p>
<ul>
<li>next[j]的含义是在子串的第j个字符与主串发生失配时，则跳到子串的next[j]位置重新与主串当前位置进行比较</li>
<li>求解方法：<ul>
<li>首先1号2号位分别固定是0和1</li>
<li>若要比较第n位，在上方写出比较字符，只写出其中n-1位前的值（如比较第3位则只需要写出前2位）<br>下方平行地写出模式串完整字符</li>
<li>此时在比较字符的第n位之前画一个竖线，开始进行比较，在下方的模式串进行后移</li>
<li>当后移到某一位时，模式串能与上方的比较字符完全匹配时，此时记录当前的模式串位数为next数组中对应位的值<br>如果模式串已经全部后移出竖线右侧，说明此时next数组的值为1</li>
</ul>
</li>
<li>完全匹配的展示<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFcaz8.png" alt="pPFcaz8.png"></li>
</ul>
</li>
<li>例：比较第4位的情况<ul>
<li>此时画到第四位之前，将模式串逐步后移检查，此时会后移两位才能完全匹配<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFcmPx.png" alt="pPFcmPx.png"></li>
</ul>
</li>
<li>后移到模式串的第一位a时，此时与上方的比较字符的a匹配，此时为第2位，记录在next数组中的序号4位置<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFctit.png" alt="pPFctit.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对KMP算法的进一步优化（将next数组转变成nextval数组）</p>
<ul>
<li><p>nextval数组概述</p>
<ul>
<li>首先需要先把模式串的next数组算出来，初始的nextval数组可以确定第一个序号的值为0</li>
<li>此时从前往后（序号2开始）依次观察每个序号对应的next的值所对应的序号的模式串<br>如下方的序号2的next数组的值为1，1的序号下的模式串为a</li>
<li><p>若其next数组所对应的序号的模式串的与当前序号的模式串相同，<br>此时新建立的nextval的值改为其next数组所对应序号的nextval数组的值（2的nextval改为0）<br>否则与原来的next数组的值一致</p>
</li>
<li><p>转换流程（依次转换）</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWaD1J.png" alt="pCWaD1J.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>注意：比较字符相同后，赋值是赋予nextval数组的值，而非原数组的值，如下题选C</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWBegg.png" alt="pCWBegg.png"></li>
</ul>
</li>
<li><p>如果next数组最初的指针是从-1开始，则第一第二序号赋值为-1,0，之后的序号的指针起始位是0，如下题选C；</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWBkUP.png" alt="pCWBkUP.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第三章-栈,队列和数组</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88-%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数据结构第三章-栈，队列和数组"><a href="#数据结构第三章-栈，队列和数组" class="headerlink" title="数据结构第三章-栈，队列和数组"></a>数据结构第三章-栈，队列和数组</h2><blockquote>
<p>计算机学科基础：第三章栈，队列和数组的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-栈（✪）"><a href="#1-栈（✪）" class="headerlink" title="1.栈（✪）"></a>1.栈（✪）</h3><h4 id="栈的基本概念（操作受限的线性表）"><a href="#栈的基本概念（操作受限的线性表）" class="headerlink" title="栈的基本概念（操作受限的线性表）"></a>栈的基本概念（操作受限的线性表）</h4><ul>
<li>栈的定义：只允许在一端进行插入或删除操作的线性表</li>
<li>栈顶是允许进行插入删除操作的那一端</li>
<li>栈的特点：后进先出</li>
<li>卡特兰数：n个不同元素进栈，出栈元素的不同排列的个数为： $(\frac{1}{n+1})*C_{2n}^n$</li>
<li><strong>无论是顺序栈还是链栈，出入栈的时间复杂度都为O(1)</strong></li>
</ul>
<h4 id="顺序栈（✪）"><a href="#顺序栈（✪）" class="headerlink" title="顺序栈（✪）"></a>顺序栈（✪）</h4><ul>
<li><p>概念：采用顺序存储的栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，<br>同时附设一个指针(top)指示当前栈顶元素的位置。</p>
</li>
<li><p>指针的变化（具体问题具体分析）</p>
<ul>
<li>指针的设置：S.top，初始时设置S.top=-1，栈顶元素：S.data[S.top]</li>
<li>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素</li>
<li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1</li>
<li>栈空条件：栈空条件：S.top\==-1</li>
<li>栈满条件：S.top==MaxSize-1；栈长：S.top+1</li>
</ul>
</li>
<li><p>代码表示</p>
<ul>
<li><p>顺序栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//栈顶指针，指示当前栈顶元素的位置 </span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span><span class="comment">//初始化 </span></span><br><span class="line">&#123; </span><br><span class="line">	S.top=<span class="number">-1</span>; <span class="comment">//初始化栈顶指针 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Sqstack S)</span><span class="comment">//判空 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的进栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span><span class="comment">//进栈 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	S.data[++S.top]=x; <span class="comment">//此处表示当栈不满时，先加栈顶指针，再执行进栈操作 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span><span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x=S.data[S.top--];<span class="comment">//此时表示当栈不为空时，先将指针处元素赋予x,再将栈顶指针减一，执行出栈操作 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>读取栈顶的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTOP</span><span class="params">(SqStack S,<span class="type">int</span> &amp;x)</span><span class="comment">//读栈顶元素 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x=S.data[S.top];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<ul>
<li>若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，</li>
<li>则入栈操作变为S.data[S.top++]=x；</li>
<li>出栈操作变为x=S.data[—S,top]；</li>
</ul>
</li>
</ul>
</li>
<li><p>关于共享栈（非重点）</p>
<ul>
<li>共享栈的定义：利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，<br>将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCw87Cj.png" alt="pCw87Cj.png"></li>
</ul>
</li>
<li>共享栈的栈顶指针<ul>
<li>两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；</li>
<li>仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满</li>
</ul>
</li>
<li>共享栈的出入栈操作：当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反。</li>
<li>共享栈的特点：共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，<br>只有在整个存储空间被占满时才发生上溢，对存取效率没有影响</li>
</ul>
</li>
</ul>
<h4 id="链式栈（✠）"><a href="#链式栈（✠）" class="headerlink" title="链式栈（✠）"></a>链式栈（✠）</h4><ul>
<li><p>链栈的定义：链栈一般由单链表来实现，不带头节点，并规定所有的操作都在表头来进行（相当于栈顶），头指针指向栈顶元素。</p>
</li>
<li><p>链栈的优点：链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9nMLBF.jpg" alt="p9nMLBF.jpg"></li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>链栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;	<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域 </span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;S)</span><span class="comment">//初始化链栈 </span></span><br><span class="line">&#123;</span><br><span class="line"> 	S=<span class="literal">NULL</span>;<span class="comment">//头指针为空</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的入栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LiStack &amp;S,<span class="type">int</span> x)</span><span class="comment">//入栈操作 </span></span><br><span class="line">&#123;</span><br><span class="line">  Linknode *p=(Linknode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linknode));<span class="comment">//分配了一个结点的空间 </span></span><br><span class="line">  p-&gt;data=x;</span><br><span class="line">  p-&gt;next=S; </span><br><span class="line">  S=p; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;	 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LiStack &amp;S,<span class="type">int</span> &amp;x)</span><span class="comment">//出栈操作</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line"> x=S-&gt;data;</span><br><span class="line"> S=S-&gt;next;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; 	 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EmptyStack</span><span class="params">(LiStack S)</span><span class="comment">//判空</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>取栈顶元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTOP</span><span class="params">(LiStack S,<span class="type">int</span> &amp;x)</span><span class="comment">//取栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">  x=S-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; 	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-队列（✪）"><a href="#2-队列（✪）" class="headerlink" title="2.队列（✪）"></a>2.队列（✪）</h3><h4 id="队列的基本概念（操作受限的线性表）"><a href="#队列的基本概念（操作受限的线性表）" class="headerlink" title="队列的基本概念（操作受限的线性表）"></a>队列的基本概念（操作受限的线性表）</h4><ul>
<li>队列的定义：只允许在表的一端进行插入，而在表的另一端进行删除。</li>
<li>向队列中插入元素称为入队或进队（此端为队尾rear）；删除元素称为出队或离队（此端为队头front）</li>
<li>特点：先进先出</li>
</ul>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><ul>
<li><p>顺序队列的指针设置：<strong>顺序队列设置两个指针，队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置</strong></p>
</li>
<li><p>顺序队列的出入队操作</p>
<ul>
<li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加一</li>
<li>出队操作：队不空时，先取队头元素值，再将队头指针加一</li>
</ul>
</li>
<li><p>初始时：Q.front==Q.rear\==0，此即为判空的条件</p>
</li>
<li><p><strong>存在的问题：不能用 Q.rear==MaxSize作为判断队满的条件，并且还有可能造成假溢出</strong></p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwYUvn.png" alt="pCwYUvn.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front,rear; <span class="comment">//队头指针指向队头元素、队尾指针指向队尾元素的下一个位置 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="循环队列（✪）"><a href="#循环队列（✪）" class="headerlink" title="循环队列（✪）"></a>循环队列（✪）</h4><ul>
<li><p>循环队列的概念：采用循环队列时，将顺序队列想像成一个环形的空间（逻辑上视为一个环），<br>当队首指针Q.front==MaxSize-1后，再前进一个位置就自动到0，可采取除法取余运算（%）来实现。</p>
</li>
<li><p>循环队列的指针设置：<strong>入队出队时相应的指针按顺时针方向进1</strong></p>
<ul>
<li>初始时：Q.front=Q.rear=0</li>
<li>出队时，队首指针进1：Q.front=(Q.front+1)%MaxSize.</li>
<li>入队时，队尾指针进1：Q.rear=(Q.rear+1)%MaxSize.</li>
<li>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize.</li>
</ul>
</li>
<li><p>循环队列的判空条件：Q.front==Q.rear。</p>
</li>
<li><p>此时的局限性：<strong>若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队尾指针，此时将无法判断队满还是队空</strong></p>
</li>
<li><p>三种处理方式区分队空和队满的判断条件（✪）</p>
<ul>
<li><p>牺牲一个数组单元来区分队空和队满（♚）</p>
<ul>
<li><p>具体实现：<strong>入队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置“作为队满的标志</strong></p>
</li>
<li><p>此时判断队满和队空的条件</p>
<ul>
<li><strong>队满条件：(Q.rear+1)%Maxsize\==Q.front</strong></li>
<li><strong>队空条件：Q.front==Q.rear.</strong></li>
<li><strong>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize。</strong></li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwt8qx.png" alt="pCwt8qx.png"></li>
</ul>
</li>
<li>例题：本题选A<ul>
<li><img src="https://s1.ax1x.com/2023/07/04/pCscjpQ.png" alt="pCscjpQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>结构体类型中增设表示元素个数的数据成员（size）</p>
<ul>
<li>入队时：Q.size++；出队时：Q.size—，此时队空和队满都满足：Q.front\==Q.rear</li>
<li>队空的条件为：Q.s1ze\==0</li>
<li>队满的条件为：Q.size\==MaxSize</li>
</ul>
</li>
<li><p>结构体类型中增设tag数据成员，以区分是队满还是队空。</p>
<ul>
<li>初始化时tag=0；入队成功时令tag=1；出队成功时令tag=0</li>
<li>tag等于0时，若因删除导致Q.front\==Q.rear,则为队空</li>
<li>tag等于1时，若因插入导致Q.front\==Q.rear,则为队满</li>
</ul>
</li>
</ul>
</li>
<li><p>循环队列的代码实现</p>
<ul>
<li><p>循环队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	Q.rear=Q.front=<span class="number">0</span>;	<span class="comment">//初始化队首与队尾指针 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的判断队空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(SqQueue Q)</span><span class="comment">//判空 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的入队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//入队 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)	<span class="comment">//判断队列是否已满	</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Q.data[Q.rear]=x;</span><br><span class="line">	Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的出队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> &amp;x)</span><span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)	<span class="comment">//判空 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">	Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>取循环队列的队首元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue Q,<span class="type">int</span> &amp;x)</span><span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)<span class="comment">//判空 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="链式队列（✠）"><a href="#链式队列（✠）" class="headerlink" title="链式队列（✠）"></a>链式队列（✠）</h4><ul>
<li><p>链式队列的定义</p>
<ul>
<li><strong>一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点(即单链表的最后一个结点)</strong><br><strong>注意与顺序存储的不同</strong></li>
<li><strong>一般将链式队列设计成一个带头结点的单链表，统一插入和删除操作</strong></li>
<li><strong>最适合作为链队的链表是带队头指针和队尾指针的非循环单链表（带头结点）</strong>，<br>此时可快速在第一个位置实现删除操作，在最后一个位置实现插入操作（循环单链表画蛇添足了）</li>
<li><strong>用链式方式存储的队列，在进行插入运算时，头尾指针可能都要修改</strong><ul>
<li>当队列不为空时，只会修改rear尾指针。</li>
<li>当队列为空时，再当有头结点时，也只要修改rear</li>
<li>当队列为空且没有头结点时，头尾指向相同，在插入时就需要同时修改头和尾</li>
</ul>
</li>
</ul>
</li>
<li><p>不带头结点的链式队列</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwwUv4.png" alt="pCwwUv4.png"></li>
</ul>
</li>
<li>链式队列的判空：当Q.front\==NULL&amp;&amp;Q.rear==NULL时，链式队列为空</li>
<li>链式队列的出入队操作：<ul>
<li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点<br>若原队列为空队，则令Q.front也指向该结点</li>
<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点<br>若该结点为最后一个结点，则置Q.front和Q.rear都为NULL</li>
</ul>
</li>
</ul>
</li>
<li><p>带头结点的链式队列</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwwdKJ.png" alt="pCwwdKJ.png"></li>
</ul>
</li>
<li>链式队列的判空：Q.front==Q.rear</li>
<li>链式队列的出入队操作<ul>
<li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点</li>
<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点<br>若该结点为最后一个结点，则置Q.rear=Q.front</li>
</ul>
</li>
</ul>
</li>
<li><p>链式队列的优点</p>
<ul>
<li>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</li>
<li>假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。</li>
</ul>
</li>
<li><p>带头结点的链式队列的代码实现</p>
<ul>
<li><p>链式队列的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>//链式队列结点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//链式队列 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LinkNode *front,*rear;<span class="comment">//链式队列头指针与尾指针 </span></span><br><span class="line">&#125;LinkQueue;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span><span class="comment">//链式队列的初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//头指针和尾指针指向新建立的头结点 </span></span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始为空 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkQueue Q)</span><span class="comment">//链式队列的判空 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的入队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//链式队列的入队 </span></span><br><span class="line">&#123;</span><br><span class="line">	LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//创建新节点 </span></span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=s;</span><br><span class="line">	Q.rear=s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的出队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用链式存储方式的队列进行删除操作时需要：头尾指针可能都需要修改,因为如果此时队列中只有一个元素的话，删除之后，队列为空，需要将Q.rear=Q.front;</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span><span class="comment">//链式队列的出队 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)<span class="comment">//判空 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LinkNode *p=Q.front-&gt;next;	<span class="comment">//创建一个指针此时指向出队的结点 </span></span><br><span class="line">	x=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;	<span class="comment">//进行出队的操作</span></span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)<span class="comment">//	若原队列中只有一个结点，则删除之后变空。 </span></span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="双端队列（主要考察选择题✪）"><a href="#双端队列（主要考察选择题✪）" class="headerlink" title="双端队列（主要考察选择题✪）"></a>双端队列（主要考察选择题✪）</h4><ul>
<li>双端队列的概念：双端队列是指允许两端都可以进行入队和出队操作的队列，此时可以加上一定的限制<br>形成输出受限的双端队列和输入受限的双端队列</li>
<li>题目考查<ul>
<li><strong>作为选择题：常常以输入序列来判断相关的输出序列是否正确，此时的方法是画图进行分析。</strong></li>
<li><strong>特别地，对于输出序列受限的这一类的题目，可以将其的输出序列直接依次填入所画的双端队列图，由题目的输入序列来反推是否可以得到此输出序列</strong></li>
<li>例题：分别选C、C<ul>
<li><img src="https://s1.ax1x.com/2023/04/21/p9E0NGQ.png" alt="p9E0NGQ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-栈和队列的应用-侧重手算模拟-代码不需要掌握✪"><a href="#3-栈和队列的应用-侧重手算模拟-代码不需要掌握✪" class="headerlink" title="3.栈和队列的应用 (侧重手算模拟,代码不需要掌握✪)"></a>3.栈和队列的应用 (侧重手算模拟,代码不需要掌握✪)</h3><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><ul>
<li>过程：依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</li>
<li>匹配失败情况：①左括号单身②右括号单身③左右括号不匹配</li>
<li>流程图<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eIMRJ.jpg" alt="p9eIMRJ.jpg"></li>
</ul>
</li>
<li>算法实现<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eIuiF.jpg" alt="p9eIuiF.jpg"></li>
</ul>
</li>
</ul>
<h4 id="栈在表达式求值中的应用（✪）"><a href="#栈在表达式求值中的应用（✪）" class="headerlink" title="栈在表达式求值中的应用（✪）"></a>栈在表达式求值中的应用（✪）</h4><ul>
<li>中缀表达式<ul>
<li>中缀表达式包括:操作数、运算符、界限符</li>
<li>其运算符在两个操作数的中间（a+b-c*d）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mqljg.jpg" alt="p9mqljg.jpg"></li>
</ul>
</li>
</ul>
</li>
<li>后缀表达式（♚）<ul>
<li>定义：也称逆波兰表达式，运算符在两个操作数的后面（$ab+cd*-$）</li>
<li>中缀表达式转为后缀表达式<ul>
<li>手算（在确定中缀表达式的运算顺序时，只要左边的能算，就优先算左边的）<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eohtO.jpg" alt="p9eohtO.jpg"></li>
</ul>
</li>
<li>机算<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mbg1S.jpg" alt="p9mbg1S.jpg"></li>
</ul>
</li>
</ul>
</li>
<li>后缀表达式求值<ul>
<li>手算<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eTg2Q.png" alt></li>
</ul>
</li>
<li>机算<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9e7AsA.png" alt="p9e7AsA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>前缀表达式<ul>
<li>定义：也称波兰表达式，运算符在两个操作数的前面（$-+ab*cd$）</li>
<li>中缀表达式转前缀表达式<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eH1fO.jpg" alt="p9eH1fO.jpg"></li>
</ul>
</li>
<li>前缀表达式求值<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eH6Xj.png" alt="p9eH6Xj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h4><ul>
<li><p>关于函数的调用</p>
<ul>
<li><strong>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</strong></li>
<li>函数调用时，需要用一个函数调用栈存储相关信息：调用返回地址、实参、局部变量</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mjPIA.png" alt="p9mjPIA.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>关于递归</p>
<ul>
<li><p><strong>定义：若在一个函数、过程或数据结构的定义中又应用了它自身，则称为递归</strong></p>
<ul>
<li><p>递归调用时，函数调用栈可称为”递归工作栈”</p>
</li>
<li><p>每进入一层递归，就将递归调用所需信息压入栈顶</p>
</li>
<li>每退出一层递归，就从栈顶弹出相应信息</li>
</ul>
</li>
<li>递归模型不能是循环定义的，必须满足的两个条件：递归表达式（递归体）；边界条件（递归出口）。</li>
<li>适合用“递归”算法解决的问题：可以把原始问题转换为属性相同，但规模较小的问题，此时可以大大减少程序的代码量</li>
<li>可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换</li>
<li><p>递归程序的缺点</p>
<ul>
<li>太多层递归可能会导致栈溢出</li>
<li><strong>通常效率较低，可能包含很多重复计算</strong></li>
<li>空间复杂度较高</li>
</ul>
</li>
<li>消除递归不一定必须用栈来实现</li>
</ul>
</li>
<li><p>求阶乘问题</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="comment">//边界条件 </span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);<span class="comment">//递归表达式 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n=factorial(<span class="number">10</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mvmSx.jpg" alt="p9mvmSx.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>斐波那契数列问题</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mz2eU.png" alt="p9mz2eU.png"></li>
</ul>
</li>
</ul>
<h4 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h4><ul>
<li>可作为树的层次遍历、图的广度遍历、页面替换算法、可作为<strong>数据缓冲区（打印机应用）</strong></li>
</ul>
<h3 id="4-数组和特殊矩阵（选择题考点✪）"><a href="#4-数组和特殊矩阵（选择题考点✪）" class="headerlink" title="4.数组和特殊矩阵（选择题考点✪）"></a>4.数组和特殊矩阵（选择题考点✪）</h3><ul>
<li>数组的存储结构<ul>
<li>数组是由n(n≥1)个相同类型的数据元素构成的有限序列，是线性表的推广（顺序存储结构）</li>
<li><strong>广义表采取的是链式存储结构，一个广义表的表尾总是一个广义表</strong></li>
<li>多维数组的两种映射方法<ul>
<li>行优先<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6AC0e.png" alt="pC6AC0e.png"></li>
</ul>
</li>
<li>列优先<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6AM7Q.png" alt="pC6AM7Q.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>特殊矩阵的压缩存储<ul>
<li>压缩存储的定义：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间</li>
<li>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。<br>常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。</li>
<li>特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，<br>把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。</li>
<li>注意: 二维数组 ${A[n][n]}$ 和 ${A[0 \ldots n-1][0 \ldots n-1]}$ 的写法是等价的。<ul>
<li>如果数组写为 ${A[1 \ldots n][1 \ldots n]}$, 则说明指定了从下标 1 开始存储元素。</li>
<li>二维数组元素写为 ${a[i][j]}$, 注意数组元素下标 ${i}$ 和 ${j}$ 通常是从 0 开始的。</li>
<li>矩阵元素通常写为 ${a_{i, j}}$ 或 ${a_{(i)(j)}}$, 注意行号 ${i}$ 和列号 ${j}$ 是 从 1 开始的。</li>
</ul>
</li>
</ul>
</li>
<li>特殊矩阵（♚）<ul>
<li>处理特殊矩阵的方式，一般先找出前i-1行的规律，再将其与第i行相加即可<strong>（通过画出具体的方阵图来分析）</strong></li>
<li>对称矩阵<ul>
<li>此时n阶方阵中均有：$a_{i,j} = a_{j,i}$，则只需要存放主对角线和下三角形部分。</li>
<li>如果为将下三角部分的元素存入数组的对称矩阵，此时按行优先方式有以下结论<br>（前i-1行可由求和公式得出，为上三角形时，i与j互换）<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6EzZD.png" alt="pC6EzZD.png"></li>
</ul>
</li>
</ul>
</li>
<li>三角矩阵<ul>
<li>下三角形矩阵<ul>
<li>上三角区的所有元素均为同一常量。存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6ZG9A.png" alt="pC6ZG9A.png"></li>
</ul>
</li>
<li>行优先原则的下标<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6ZaB8.png" alt="pC6ZaB8.png"></li>
</ul>
</li>
</ul>
</li>
<li>上三角形矩阵<ul>
<li>行优先原则的下标<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6Z0Ag.png" alt="pC6Z0Ag.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>三对角矩阵（带状矩阵）<ul>
<li>三对角矩阵中，所有非零元素都集中在以主对角线为中心的三条对角线的区域，其它区域的元素都为0<br>当|i-j|&gt;1时，此时为0<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6ZvUe.png" alt="pC6ZvUe.png"></li>
</ul>
</li>
<li>行优先原则的下标<ul>
<li>前i-1行共 3(i-1)-1 个元素 （第一行需要减1）</li>
<li>$a_{i,j}$是i行第j-i+2个元素，$a_{i,j}$是第2i+j-2个元素</li>
<li>此时数组下标k为k=2i+j-3</li>
</ul>
</li>
<li>如何根据下标求出元素在数组中的具体位置<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6necn.png" alt="pC6necn.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>稀疏矩阵（<strong>压缩存储后必定会失去随机存储的功能</strong>）<ul>
<li>矩阵中非零元素的个数远远小于为0的元素</li>
<li>使用顺序存储方式压缩存储（三元组表）<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6Qze1.png" alt="pC6Qze1.png"></li>
</ul>
</li>
<li>使用链式存储方式压缩存储（十字链表）<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6liWD.png" alt="pC6liWD.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第二章-线性表</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="数据结构第二章-线性表"><a href="#数据结构第二章-线性表" class="headerlink" title="数据结构第二章 线性表"></a>数据结构第二章 线性表</h2><blockquote>
<p>计算机学科基础：数据结构第二章线性表的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1.线性表的定义"></a>1.线性表的定义</h3><ul>
<li><p>①定义：具有<u>相同数据类型</u>的n个<u>数据元素</u>的<u>有限序列</u>，<strong>线性表是一种逻辑结构，表示元素之间一对一的相邻关系</strong></p>
</li>
<li><p>②特点：<strong>表中的元素在逻辑上相邻，具有逻辑上的顺序性，有其先后次序，每个元素只有唯一的前驱元素</strong></p>
</li>
</ul>
<h3 id="2-顺序表（线性表的顺序存储结构✪）"><a href="#2-顺序表（线性表的顺序存储结构✪）" class="headerlink" title="2.顺序表（线性表的顺序存储结构✪）"></a>2.顺序表（线性表的顺序存储结构✪）</h3><ul>
<li><p>①定义：<strong>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素</strong><br><strong>从而使得逻辑上相邻的两个元素在物理位置上也相邻</strong></p>
</li>
<li><p>②特点</p>
<ul>
<li>顺序表中元素的逻辑顺序与其物理顺序相同</li>
<li>顺序表中的任意一个数据元素都可以<strong>随机存取</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li>
<li>顺序表的存储密度高，每个结点只存储数据元素。</li>
<li><strong>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</strong></li>
<li><strong>n个元素的顺序表可插入的位置有n+1个，移动次数总数为：n(n+1)/2</strong><br><strong>平均移动次数为：n/2</strong></li>
<li><strong>n个元素的顺序表删除元素时，平均移动次数为：(n-1)/2</strong></li>
<li><strong>n个元素的顺序表顺序查找的平均比较/查找次数为：(n+1)/2</strong></li>
</ul>
</li>
<li><p>③代码实现（用<strong>数组</strong>来描述线性表的顺序存储结构♚）</p>
<ul>
<li><p>顺序表的定义</p>
<ul>
<li><p>静态分配一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50 <span class="comment">//定义顺序表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//对顺序表进行初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>动态分配一维数组（存储数组的空间使用malloc函数进行动态分配）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data; <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> MaxSize,length; <span class="comment">//数组的最大容量和当前顺序表的长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqLsit L;</span><br><span class="line">	InitList(L); <span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="comment">//...向表中插入几个元素</span></span><br><span class="line">    IncreaseSize(L,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span><span class="comment">//使用动态分配方法的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span><span class="comment">//为数组分配新的空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L.data;<span class="comment">//申请一个新指针</span></span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize=L.Maxsize+len;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>顺序表的插入操作（平均时间复杂度：O(n)）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span><span class="comment">//顺序表的插入，指定位置，插入元素 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的删除操作（平均时间复杂度：O(n)）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//顺序表的删除，删除指定位置的元素，并传出此元素 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e=L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的按值查找位置 （平均时间复杂度：O(n)）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SqList L,<span class="type">int</span> e)</span><span class="comment">//按值查号，返回该第一个等于值的位置 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">		<span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//查到了则返回其位序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的按位查找元素 （平均时间复杂度：O(1)，此时为随机访问）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Get</span><span class="params">(SqList L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//按位查找，返回在位置i上的元素e </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e=L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-链表（线性表的链式存储结构✪）"><a href="#3-链表（线性表的链式存储结构✪）" class="headerlink" title="3.链表（线性表的链式存储结构✪）"></a>3.链表（线性表的链式存储结构✪）</h3><ul>
<li><p>①定义：<strong>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。</strong><br><strong>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</strong></p>
</li>
<li><p>②特点</p>
<ul>
<li>链式存储线性表时，不需要使用地址连续的存储单元，不要求逻辑上相邻的元素在物理上也相邻</li>
<li>插入和删除元素不需要移动元素，只需要修改指针。</li>
<li>单链表附加指针域，也存在浪费存储空间的缺点。</li>
<li>由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，<br>即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。</li>
<li><strong>设一个有序的单链表中有n个结点，现要求插入一个新节点后使得单链表仍然保持有序，则该操作的时间复杂度为O(n)</strong></li>
</ul>
</li>
<li><p>③代码实现（♚）</p>
<ul>
<li><p>单链表的定义</p>
<ul>
<li><p>单链表的结点由数据域（data，存放数据元素）和指针域（next，存放其后继结点的地址）组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList; <span class="comment">//别名，第一个强调它是一个结点，第二个强调它是一个链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：要表示一个单链表，只需声明一个头指针L，指向单链表的第一个结点。</span></span><br><span class="line"><span class="comment">// LNode *L;或 LinkList L;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>初始化单链表</p>
<ul>
<li><p>带头结点的单链表（头指针指向头结点）</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaMWPx.png" alt="pCaMWPx.png"></li>
</ul>
</li>
<li><p>为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点<br>头结点的数据域不带任何信息，指针域指向线性表的第一个<strong>数据结点</strong>（区分第一个结点和第一个数据结点）</p>
</li>
<li><p>头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点<br>而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p>
</li>
<li><p>引入头结点的优点</p>
<ul>
<li><strong>对于插入或删除第一个数据结点的操作，由于第一个数据结点的位置被存放在头结点的指针域中，</strong><br><strong>因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</strong></li>
<li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空）<br>因此空表和非空表的处理也就得到了统一。</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//初始化单链表 </span></span><br><span class="line">&#123;</span><br><span class="line">	L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//分配一个头结点 </span></span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不带头结点的单链表 （头指针指向第一个数据结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">	L=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>建立单链表</p>
<ul>
<li><p>使用头插法建立单链表（<strong>时间复杂度O(n)</strong>）</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCa8TUJ.png" alt="pCa8TUJ.png"></li>
</ul>
</li>
<li><p>从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头</p>
</li>
<li><p>读入数据的顺序与生成的链表中的元素的顺序是相反的</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//头插法建立单链表,可以用于实现逆置 </span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *s;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建头结点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//初始为空链表</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建新结点</span></span><br><span class="line">		s-&gt;data=x;</span><br><span class="line">		s-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=s;  <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用尾插法建立单链表（<strong>时间复杂度O(n)</strong>）</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCa8jKK.png" alt="pCa8jKK.png"></li>
</ul>
</li>
<li><p>该方法将新结点插入到当前链表的表尾，需要增加一个尾指针r，使其始终指向当前链表的尾结点</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TaliInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//尾插法建立单链表 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	LNode *s,*r=L;		<span class="comment">//尾插法需要建立一个尾指针r,刚开始都指向头结点 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=x;</span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">		r=s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">	&#125; </span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;	<span class="comment">//尾结点指针置空</span></span><br><span class="line">	<span class="keyword">return</span> L; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表按序号查找结点 （<strong>时间复杂度O(n)</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span><span class="comment">//循环单链表找到第i个位置的指针 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">//若i无效，返回NULL</span></span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;	<span class="comment">//相当于把头结点看作是0号位置</span></span><br><span class="line">	LNode *p=L;	<span class="comment">//刚开始P指向头结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p; <span class="comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表按值查找节点（<strong>时间复杂度O(n)</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,<span class="type">int</span> e)</span><span class="comment">//按值查找结点 </span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)	<span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">	 	p=p-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p; 	<span class="comment">//找到后返回该结点的指针，如果链表中没有该值将返回空值 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的插入结点操作</p>
<ul>
<li><p>指定的结点后插操作</p>
<ul>
<li><p>查找待插入位置的前驱结点的时间复杂度为O(n)，在给定的结点后面插入新结点的时间复杂度为O(1)</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaJDYj.png" alt="pCaJDYj.png"></li>
</ul>
</li>
<li><p>插入结点操作将值为×的新结点插入到单链表的第i个位置上。先检查插入位置的合法性<br>然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点</p>
</li>
<li><p>算法首先调用按序号查找算法GetElem（L，i-1），查找第i-1个结点。<br>假设返回的第i-1个结点为p，然后令新结点s的指针域指向p的后继结点，再令结点p的指针域指向新插入的结点s</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找插入位置的前驱结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertNext</span><span class="params">(LNode *p,<span class="type">int</span> e)</span><span class="comment">//指定结点的后插操作,需要找到其前驱结点,此时的p是指向待插入位置的前驱结点的指针  </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=p-&gt;next; </span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>指定结点的前插操作</p>
<ul>
<li><p><strong>查找待插入位置的结点的时间复杂度为O(n)，在给定的结点前面插入新结点的时间复杂度为O(1)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPrior</span><span class="params">(LNode *p,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;next=p-&gt;next; </span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	s-&gt;data=p-&gt;data;  <span class="comment">//交换了数据域 </span></span><br><span class="line">	p-&gt;data=e; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表的删除结点操作</p>
<ul>
<li><p>寻找待删除结点的前驱结点，再执行相关删除操作</p>
<ul>
<li><p>查找待删除位置的前驱结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaYsED.png" alt="pCaYsED.png"></li>
</ul>
</li>
<li><p>先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//删除第i个位置的元素，并用e返回删除元素的值,需要找到前驱结点 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *p=GetElem(L,i<span class="number">-1</span>);	<span class="comment">//循环单链表找到第i-1个位置的指针</span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *q=p-&gt;next;	<span class="comment">//新创建一个指针，并使该指针指向当前欲删除的结点 </span></span><br><span class="line">	e=q-&gt;data;</span><br><span class="line">	p-&gt;next=q-&gt;next;	<span class="comment">//修改前驱结点的指针域使其指向待删除结点的下一个结点,将*q结点从链中断开 </span></span><br><span class="line">	<span class="built_in">free</span>(q);	<span class="comment">//释放结点的存储空间 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寻找待删除结点，再执行相关删除操作</p>
<ul>
<li><p>查找待删除位置的结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p>
</li>
<li><p>删除结点P的操作可用删除P的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteNext</span><span class="params">(LNode *p,<span class="type">int</span> &amp;e)</span><span class="comment">//删除需删除结点的后继结点，但是此时由于该原本该删除的结点的数据域和指针域已经被实际删除的结点的值覆盖，因此相当于删除了需删除的结点 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *q=p-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">	p-&gt;data=q-&gt;data;</span><br><span class="line">	p-&gt;next=q-&gt;next</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表的求表长操作<strong>（时间复杂度为O(n)）</strong></p>
<ul>
<li><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，<br>为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span><span class="comment">//求表长 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	LNode *p=L-&gt;next; <span class="comment">//创建一个指针指向第一个数据结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-双链表（主要考察选择题✪）"><a href="#4-双链表（主要考察选择题✪）" class="headerlink" title="4.双链表（主要考察选择题✪）"></a>4.双链表（主要考察选择题✪）</h3><ul>
<li><p>①定义</p>
<ul>
<li>双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，<br>在指针已经指向相应结点的情况下，插入和删除的时间复杂度为O(1)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCatOFe.png" alt="pCatOFe.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>②代码实现</p>
<ul>
<li><p>双链表的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;; DNode,*DLinkList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitDLink</span><span class="params">(DLinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">	L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	L-&gt;prior=<span class="literal">NULL</span>;<span class="comment">//头结点的前驱指针永远指向NULL </span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的插入操作</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaUsET.png" alt="pCaUsET.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(DNode *p,DNode *s)</span><span class="comment">//在i位置上的p节点之后插入结点s，数值为e </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	s-&gt;next=p-&gt;next; <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		p-&gt;next-&gt;prior=s;</span><br><span class="line">	s-&gt;prior=p;  <span class="comment">//2</span></span><br><span class="line">	p-&gt;next=s; 	 <span class="comment">//3</span></span><br><span class="line">	p-&gt;data=e;	 <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; <span class="comment">//1和2步必须在第4步之前，否则p的后继结点的指针就会丢掉，导致插入失败</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>双链表的删除操作</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCadQTf.png" alt="pCadQTf.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(DNode *p)</span><span class="comment">//删除p结点的后继结点q </span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	DNode *q=p-&gt;next; <span class="comment">//找到p的后继结点q </span></span><br><span class="line">	<span class="keyword">if</span>(q==<span class="literal">NULL</span>)<span class="comment">//p结点没有后继 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next; </span><br><span class="line">	<span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		q-&gt;next-&gt;prior=p;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-循环链表（主要考察选择题✪）"><a href="#5-循环链表（主要考察选择题✪）" class="headerlink" title="5.循环链表（主要考察选择题✪）"></a>5.循环链表（主要考察选择题✪）</h3><ul>
<li><p>①循环单链表</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCawDbt.png" alt="pCawDbt.png"></li>
</ul>
</li>
<li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li>
<li>在循环单链表中，表尾结点r的next域指向L，故表中没有指针域为NULL的结点，<br>因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</li>
<li>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表</li>
<li>有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。<ul>
<li>其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，</li>
<li>而若设的是尾指针r，r-&gt;next即为头指针，对在表头或表尾插入元素都只需要O($1$)的时间复杂度。</li>
</ul>
</li>
</ul>
</li>
<li><p>②循环双链表</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCawbPU.png" alt="pCawbPU.png"></li>
</ul>
</li>
<li>循环双链表中，头结点的前指针指向表尾节点，判空的条件是头结点的前后指针域都等于头结点</li>
<li>循环双链表是有助于删除第一个结点、删除最后一个结点，在第一个结点前插入一个结点，在最后一个结点后添加一个结点<ul>
<li>选A、C，如果是循环单链表，没办法处理删除最后一个结点（无法快速找到最后一个结点的前驱结点）</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsd3sU.png" alt="pCsd3sU.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h3><ul>
<li><p><strong>静态链表借助数组来描述线性表的<u>链式存储结构</u>，也有指针域和数据域</strong></p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCa0zlQ.png" alt="pCa0zlQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>指针表示下一个元素的数组下标（游标），静态链表也需要事先分配一块连续的内存空间。</p>
</li>
<li><p>其插入和删除不需要移动元素，只需要修改指针。</p>
</li>
<li><p>以next==-1作为结束的标志。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-顺序表和链表的比较（✪）"><a href="#7-顺序表和链表的比较（✪）" class="headerlink" title="7.顺序表和链表的比较（✪）"></a>7.顺序表和链表的比较（✪）</h3><ul>
<li>1.存取（读写）方式<ul>
<li>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。</li>
<li>例如在第i个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。</li>
</ul>
</li>
<li>2.逻辑结构与物理结构<ul>
<li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。</li>
<li>而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li>
</ul>
</li>
<li>3.查找、插入和删除操作<ul>
<li>对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)<br>顺序表有序时，可采用折半查找，此时的时间复杂度为O($log_2n$).</li>
<li>对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)<br>而链表的平均时间复杂度为O(n)</li>
<li>顺序表的插入、删除操作，平均需要移动半个表长的元素。<br>链表的插入、删除操作，只需修改相关结点的指针域即可。</li>
<li>由于链表的每个结点都带有指针域，故而存储密度不够大。</li>
</ul>
</li>
<li>4.空间分配<ul>
<li>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，<br>因此需要预先分配足够大的存储空间。<ul>
<li>预先分配过大，可能会导致顺序表后部大量闲置；</li>
<li>预先分配过小，又会造成溢出。</li>
</ul>
</li>
<li>动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，<br>而且若内存中没有更大块的连续存储空间，则会导致分配失败。</li>
<li>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</li>
</ul>
</li>
<li>如何选取存储结构<ul>
<li>1.基于存储的考虑<ul>
<li>难以估计线性表的长度或存储规模时，不宜采用顺序表</li>
<li>链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</li>
</ul>
</li>
<li>2.基于运算的考虑<ul>
<li>在顺序表中按序访问的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n),<br>因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</li>
<li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的</li>
<li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</li>
</ul>
</li>
<li>3.基于环境的考虑<ul>
<li>顺序表容易实现，任何高级语言中都有数组类型，链表的操作是基于指针的，<br>相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</li>
<li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第一章-绪论</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="数据结构第一章-绪论"><a href="#数据结构第一章-绪论" class="headerlink" title="数据结构第一章 绪论"></a>数据结构第一章 绪论</h2><blockquote>
<p>计算机学科基础：数据结构第一章绪论的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1.数据结构的基本概念"></a>1.数据结构的基本概念</h3><ul>
<li>数据</li>
<li>数据元素：<u>数据的基本单位</u>，由若干个数据项组成<br><strong>数据项是不可分割的最小独立数据单位</strong></li>
<li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集</li>
<li>数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称<ul>
<li>原子类型：其值不可再分的数据类型。（如bool、int）</li>
<li>结构类型：其值可以再分解为若干成分（分量）的数据类型。(如结构体)</li>
<li><strong>抽象数据类型ADT</strong>：抽象数据组织及与之相关的操作<br>描述了数据的逻辑结构和抽象运算，定义了一个完整的数据结构，如线性表、栈、队列、树、图等）。</li>
</ul>
</li>
<li>数据结构<ul>
<li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)</li>
<li>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</li>
<li>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，<br>而算法的实现依赖于所采用的存储结构。</li>
</ul>
</li>
</ul>
<h3 id="2-数据结构的三要素"><a href="#2-数据结构的三要素" class="headerlink" title="2.数据结构的三要素"></a>2.数据结构的三要素</h3><ul>
<li>数据的逻辑结构：数据元素之间的逻辑关系，<strong>数据的逻辑结构独立于其存储结构</strong><ul>
<li>线性结构（数据元素之间只存在一对一的关系）<ul>
<li>一般线性表</li>
<li>受限线性表：栈和队列、串</li>
<li>线性表推广：数组</li>
</ul>
</li>
<li>非线性结构<ul>
<li>集合 （结构中的数据元素之间除“同属一个集合外”，别无其他关系）</li>
<li>树形结构：一般树、二叉树（数据元素之间存在一对多的关系）</li>
<li>图状结构：有向图、无向图（数据元素之间存在多对多的关系）</li>
</ul>
</li>
<li>概念型的例题<ul>
<li>此题选C，逻辑结构均是线性结构</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCs0g2t.png" alt="pCs0g2t.png"></li>
</ul>
</li>
</ul>
</li>
<li>数据的存储结构：存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。<br>包括数据元素的表示和关系的表示（<strong>存储数据时，不仅要存储各数据元素的值，也要存储数据元素之间的关系</strong>）<ul>
<li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中（如顺序表）<br>元素之间的关系由存储单元的邻接关系来体现。<ul>
<li>其优点是可以实现随机存取，每个元素占用最少的存储空间</li>
<li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li>
</ul>
</li>
<li>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，<br>借助指示元素存储地址的指针来表示元素之间的逻辑关系<ul>
<li>链式存储时，链式存储时各个不同结点的存储空间可以不连续，但结点内的存储单元地址一定连续</li>
<li>链式存储结构比顺序存储结构更能方便地表示各种逻辑结构</li>
<li>其优点是不会出现碎片现象，能充分利用所有存储单元</li>
<li>缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li>
</ul>
</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表。<br>索引表中的每项称为索引项，索引项的一般形式是(关键字，地址)。<ul>
<li>其优点是检索速度快：缺点是附加的索引表额外占用存储空间。</li>
<li>增加和删除数据时也要修改索引表，因而会花费较多的时间。</li>
</ul>
</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hsh)存储。<ul>
<li>其优点是检索、增加和删除结点的操作都很快</li>
<li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li>
</ul>
</li>
</ul>
</li>
<li>数据的运算：施加在数据上的运算包括运算的定义和实现。<ul>
<li>运算的定义是针对逻辑结构的，指出运算的功能</li>
<li>运算的实现是针对存储结构的，指出运算的具体操作步骤。</li>
<li><strong>不是每种数据结构都具备三种基本运算：插入、删除和查找</strong><br><strong>如栈和队列无法查找，二维数组无法删除</strong></li>
</ul>
</li>
</ul>
<h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul>
<li>算法的概念：<strong>对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li>
<li>五个重要特性<ul>
<li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li>
<li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li>
<li>可行性：算法中描述的操作都可以通过已经实现的基本运算<u>执行有限次</u>来实现。</li>
<li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>
<li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li>
</ul>
</li>
<li>四个目标<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，<br>这两者都与问题的规模有关。</li>
</ul>
</li>
</ul>
<h3 id="4-算法效率的度量（✪）"><a href="#4-算法效率的度量（✪）" class="headerlink" title="4.算法效率的度量（✪）"></a>4.算法效率的度量（✪）</h3><ul>
<li><p>时间复杂度</p>
<ul>
<li>一个语句的频度是指该语句在算法中<u>被重复执行的次数</u>。算法中所有语句的频度之和记为T(n)，<br><u>它是该算法问题规模n的函数</u>，时间复杂度主要分析T(n)的<u>数量级</u>，<strong>执行时间与时间复杂度的值成正比</strong>。</li>
<li>算法中基本运算（<strong>最深层循环内的语句</strong>）的频度与T(n)同数量级，<br><strong>因此通常采用算法中基本运算的频度f(n)来分析时间复杂度</strong>，$T ( n ) = O ( f ( n ) )$<ul>
<li>如此题中，问题规模始终都是n，执行时间与时间复杂度的值成正比，选C<ul>
<li><img src="https://s1.ax1x.com/2023/07/04/pCse6aQ.png" alt="pCse6aQ.png"></li>
</ul>
</li>
<li>此题可以反映时间复杂度是看问题规模的数量级（即看最高阶，抓大头选B）<ul>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsKhY4.png" alt="pCsKhY4.png"></li>
</ul>
</li>
<li>但是有两个变量的话就不一样了，如此题选C<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPMMWOs.png" alt="pPMMWOs.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>算法的时间复杂度不仅依赖于问题的规模，也取决于待输入数据的性质（如输入数据元素的初始状态)</strong></li>
</ul>
</li>
<li><p>空间复杂度：算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。</p>
</li>
<li><p>关于时间复杂度的例题（♚）</p>
<ul>
<li>步骤：首先确定循环中变化的值，之后跟据其变化情况列出其经过每轮循环之后的值<br>（先用实数，最后写出规律式（含频数k）），之后并与问题规模n组成不等式，最后求出k关于n的表达式</li>
<li>例1<ul>
<li>此时写出i的变化规律：$1,2,4…2^{k},2^{k}=n,k=log_{2}n$</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsnQ0O.png" alt="pCsnQ0O.png"></li>
</ul>
</li>
<li>例2<ul>
<li>此时写出x的变化规律：$4,8,16…2^{k+1},2^{k+1}&lt;n/2,k=log_{2}n/2-1=log_{2}n-2$，此时即选A</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsu8bT.png" alt="pCsu8bT.png"></li>
</ul>
</li>
<li>例3<ul>
<li>此时有内外两层的循环，且外层循环的值决定了内层循环的次数，应该以外层为基准来看</li>
<li>外层执行第一轮(i=1)：最内层语句执行2次，外层执行第二轮(i=2)，最内层语句执行4次，<br>外层执行第三轮(i=3)，最内层语句执行6次，</li>
<li>此时有规律得（外层执行第n轮时，最内层语句执行2n次）总次数即为相加（求和公式(2+2n)*n/2)=n(n+1)）</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsKneK.png" alt="pCsKneK.png"></li>
</ul>
</li>
<li><p>例4</p>
<ul>
<li><p>先看外层的循环取值</p>
</li>
<li><p>此时有$i=1,2,4……2^{k}&lt;n ，此时对应的内层总次数相加为1+2+……2^{k}=2^{k+1}-1&lt;2n$，时间复杂度为n</p>
</li>
<li><p><img src="https://s1.ax1x.com/2023/07/04/pCs3Arn.png" alt="pCs3Arn.png"></p>
</li>
</ul>
</li>
<li><p>例5</p>
<ul>
<li><p>此时有两层循环但是内层循环的次数不由外层循环的值确定，此时可以看做两个单独的循环，总次数即为此两次循环的积，选C</p>
</li>
<li><p><img src="https://s1.ax1x.com/2023/07/04/pCsKsln.png" alt="pCsKsln.png"></p>
</li>
</ul>
</li>
<li><p>例6</p>
<ul>
<li><p>将表达式简化后写出规律，i=0时，sum=1；i=1，sum=1+2，i=2，sum=1+2+3，则i=k时，sum=(1+k)k/2=n，此时选B</p>
</li>
<li><p><img src="https://s1.ax1x.com/2023/07/04/pCslT6s.png" alt="pCslT6s.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
