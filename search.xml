<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello_world</title>
    <url>/2024/08/10/hello-world/</url>
    <content><![CDATA[<h1 id="新阶段的第一篇博客"><a href="#新阶段的第一篇博客" class="headerlink" title="新阶段的第一篇博客"></a>新阶段的第一篇博客</h1><span id="more"></span>
<p>新的时期开始了！</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>说明</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习第四章-GoogleNet</title>
    <url>/2024/09/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AB%A0-GoogleNet/</url>
    <content><![CDATA[<h1 id="深度学习第四章-GoogleNet"><a href="#深度学习第四章-GoogleNet" class="headerlink" title="深度学习第四章-GoogleNet"></a>深度学习第四章-GoogleNet</h1><blockquote>
<p>本模型位于：E:\python文件\deep-learning-for-image-processing-master\pytorch_classification\Test4_googlenet</p>
</blockquote>
<span id="more"></span>
<h2 id="一-模型介绍"><a href="#一-模型介绍" class="headerlink" title="一.模型介绍"></a>一.模型介绍</h2><ul>
<li><p>引入了Inception结构（融合不同尺度的特征信息）</p>
<ul>
<li><img src="https://s21.ax1x.com/2024/09/02/pAV3x41.png" alt="pAV3x41.png"></li>
</ul>
</li>
<li><p>使用1x1的卷积核进行降维以及映射处理 （减少模型参数）</p>
<ul>
<li><img src="https://s21.ax1x.com/2024/09/02/pAV8Z4I.png" alt="pAV8Z4I.png"></li>
</ul>
</li>
<li><p>添加两个辅助分类器帮助训练</p>
</li>
<li>丢弃全连接层，使用平均池化层（大大减少模型参数）</li>
</ul>
<p>图示：</p>
<p><img src="https://s21.ax1x.com/2024/09/03/pAV0PJg.jpg" alt="pAV0PJg.jpg"></p>
<h2 id="二-数据集-花分类数据集"><a href="#二-数据集-花分类数据集" class="headerlink" title="二.数据集-花分类数据集"></a>二.数据集-花分类数据集</h2><ul>
<li>如同前一章的内容</li>
</ul>
<h2 id="三-网络模型搭建"><a href="#三-网络模型搭建" class="headerlink" title="三.网络模型搭建"></a>三.网络模型搭建</h2><h3 id="1-普通卷积层模版"><a href="#1-普通卷积层模版" class="headerlink" title="1.普通卷积层模版"></a>1.普通卷积层模版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicConv2d</span>(nn.Module): <span class="comment">#基本的卷积层模版</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, out_channels, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(BasicConv2d, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv = nn.Conv2d(in_channels, out_channels, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.conv(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.relu(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="2-inception模块模版"><a href="#2-inception模块模版" class="headerlink" title="2.inception模块模版"></a>2.inception模块模版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inception</span>(nn.Module): <span class="comment">#定义inception模版</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, ch1x1, ch3x3red, ch3x3, ch5x5red, ch5x5, pool_proj</span>):</span><br><span class="line">        <span class="built_in">super</span>(Inception, <span class="variable language_">self</span>).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.branch1 = BasicConv2d(in_channels, ch1x1, kernel_size=<span class="number">1</span>) <span class="comment">#分支一</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.branch2 = nn.Sequential( <span class="comment">#分支二</span></span><br><span class="line">            BasicConv2d(in_channels, ch3x3red, kernel_size=<span class="number">1</span>),</span><br><span class="line">            BasicConv2d(ch3x3red, ch3x3, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)   <span class="comment"># 保证输出大小等于输入大小</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.branch3 = nn.Sequential( <span class="comment">#分支三</span></span><br><span class="line">            BasicConv2d(in_channels, ch5x5red, kernel_size=<span class="number">1</span>),</span><br><span class="line">            BasicConv2d(ch5x5red, ch5x5, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)   <span class="comment"># 保证输出大小等于输入大小</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.branch4 = nn.Sequential( <span class="comment">#分支四</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            BasicConv2d(in_channels, pool_proj, kernel_size=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): <span class="comment">#定义前向传播函数</span></span><br><span class="line">        branch1 = <span class="variable language_">self</span>.branch1(x)</span><br><span class="line">        branch2 = <span class="variable language_">self</span>.branch2(x)</span><br><span class="line">        branch3 = <span class="variable language_">self</span>.branch3(x)</span><br><span class="line">        branch4 = <span class="variable language_">self</span>.branch4(x)</span><br><span class="line"></span><br><span class="line">        outputs = [branch1, branch2, branch3, branch4]</span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs, <span class="number">1</span>) <span class="comment">#进行合并</span></span><br></pre></td></tr></table></figure>
<h3 id="3-辅助分类器模版"><a href="#3-辅助分类器模版" class="headerlink" title="3.辅助分类器模版"></a>3.辅助分类器模版</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InceptionAux</span>(nn.Module): <span class="comment">#定义辅助分类器模版</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_channels, num_classes</span>):</span><br><span class="line">        <span class="built_in">super</span>(InceptionAux, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.averagePool = nn.AvgPool2d(kernel_size=<span class="number">5</span>, stride=<span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv = BasicConv2d(in_channels, <span class="number">128</span>, kernel_size=<span class="number">1</span>)  <span class="comment"># output[batch, 128, 4, 4]</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">2048</span>, <span class="number">1024</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">1024</span>, num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># aux1: N x 512 x 14 x 14, aux2: N x 528 x 14 x 14</span></span><br><span class="line">        x = <span class="variable language_">self</span>.averagePool(x)</span><br><span class="line">        <span class="comment"># aux1: N x 512 x 4 x 4, aux2: N x 528 x 4 x 4</span></span><br><span class="line">        x = <span class="variable language_">self</span>.conv(x)</span><br><span class="line">        <span class="comment"># N x 128 x 4 x 4</span></span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.5</span>, training=<span class="variable language_">self</span>.training)</span><br><span class="line">        <span class="comment"># N x 2048</span></span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc1(x), inplace=<span class="literal">True</span>)</span><br><span class="line">        x = F.dropout(x, <span class="number">0.5</span>, training=<span class="variable language_">self</span>.training)</span><br><span class="line">        <span class="comment"># N x 1024</span></span><br><span class="line">        x = <span class="variable language_">self</span>.fc2(x)</span><br><span class="line">        <span class="comment"># N x num_classes</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="4-GooleNet网络"><a href="#4-GooleNet网络" class="headerlink" title="4.GooleNet网络"></a>4.GooleNet网络</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoogLeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">1000</span>, aux_logits=<span class="literal">True</span>, init_weights=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GoogLeNet, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.aux_logits = aux_logits</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = BasicConv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">self</span>.maxpool1 = nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>) <span class="comment">#向上取整</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.conv2 = BasicConv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv3 = BasicConv2d(<span class="number">64</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">self</span>.maxpool2 = nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.inception3a = Inception(<span class="number">192</span>, <span class="number">64</span>, <span class="number">96</span>, <span class="number">128</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">        <span class="variable language_">self</span>.inception3b = Inception(<span class="number">256</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">192</span>, <span class="number">32</span>, <span class="number">96</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.maxpool3 = nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.inception4a = Inception(<span class="number">480</span>, <span class="number">192</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.inception4b = Inception(<span class="number">512</span>, <span class="number">160</span>, <span class="number">112</span>, <span class="number">224</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.inception4c = Inception(<span class="number">512</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.inception4d = Inception(<span class="number">512</span>, <span class="number">112</span>, <span class="number">144</span>, <span class="number">288</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.inception4e = Inception(<span class="number">528</span>, <span class="number">256</span>, <span class="number">160</span>, <span class="number">320</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">        <span class="variable language_">self</span>.maxpool4 = nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.inception5a = Inception(<span class="number">832</span>, <span class="number">256</span>, <span class="number">160</span>, <span class="number">320</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">        <span class="variable language_">self</span>.inception5b = Inception(<span class="number">832</span>, <span class="number">384</span>, <span class="number">192</span>, <span class="number">384</span>, <span class="number">48</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.aux_logits:</span><br><span class="line">            <span class="variable language_">self</span>.aux1 = InceptionAux(<span class="number">512</span>, num_classes)</span><br><span class="line">            <span class="variable language_">self</span>.aux2 = InceptionAux(<span class="number">528</span>, num_classes)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.avgpool = nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">#自适应池化层</span></span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(<span class="number">0.4</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(<span class="number">1024</span>, num_classes)</span><br><span class="line">        <span class="keyword">if</span> init_weights:</span><br><span class="line">            <span class="variable language_">self</span>._initialize_weights()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># N x 3 x 224 x 224</span></span><br><span class="line">        x = <span class="variable language_">self</span>.conv1(x)</span><br><span class="line">        <span class="comment"># N x 64 x 112 x 112</span></span><br><span class="line">        x = <span class="variable language_">self</span>.maxpool1(x)</span><br><span class="line">        <span class="comment"># N x 64 x 56 x 56</span></span><br><span class="line">        x = <span class="variable language_">self</span>.conv2(x)</span><br><span class="line">        <span class="comment"># N x 64 x 56 x 56</span></span><br><span class="line">        x = <span class="variable language_">self</span>.conv3(x)</span><br><span class="line">        <span class="comment"># N x 192 x 56 x 56</span></span><br><span class="line">        x = <span class="variable language_">self</span>.maxpool2(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># N x 192 x 28 x 28</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception3a(x)</span><br><span class="line">        <span class="comment"># N x 256 x 28 x 28</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception3b(x)</span><br><span class="line">        <span class="comment"># N x 480 x 28 x 28</span></span><br><span class="line">        x = <span class="variable language_">self</span>.maxpool3(x)</span><br><span class="line">        <span class="comment"># N x 480 x 14 x 14</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception4a(x)</span><br><span class="line">        <span class="comment"># N x 512 x 14 x 14</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training <span class="keyword">and</span> <span class="variable language_">self</span>.aux_logits:    <span class="comment"># 若处于训练模式则添加辅助分类器1</span></span><br><span class="line">            aux1 = <span class="variable language_">self</span>.aux1(x)</span><br><span class="line"></span><br><span class="line">        x = <span class="variable language_">self</span>.inception4b(x)</span><br><span class="line">        <span class="comment"># N x 512 x 14 x 14</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception4c(x)</span><br><span class="line">        <span class="comment"># N x 512 x 14 x 14</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception4d(x)</span><br><span class="line">        <span class="comment"># N x 528 x 14 x 14</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training <span class="keyword">and</span> <span class="variable language_">self</span>.aux_logits:    <span class="comment"># 若处于训练模式则添加辅助分类器2</span></span><br><span class="line">            aux2 = <span class="variable language_">self</span>.aux2(x)</span><br><span class="line"></span><br><span class="line">        x = <span class="variable language_">self</span>.inception4e(x)</span><br><span class="line">        <span class="comment"># N x 832 x 14 x 14</span></span><br><span class="line">        x = <span class="variable language_">self</span>.maxpool4(x)</span><br><span class="line">        <span class="comment"># N x 832 x 7 x 7</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception5a(x)</span><br><span class="line">        <span class="comment"># N x 832 x 7 x 7</span></span><br><span class="line">        x = <span class="variable language_">self</span>.inception5b(x)</span><br><span class="line">        <span class="comment"># N x 1024 x 7 x 7</span></span><br><span class="line"></span><br><span class="line">        x = <span class="variable language_">self</span>.avgpool(x)</span><br><span class="line">        <span class="comment"># N x 1024 x 1 x 1</span></span><br><span class="line">        x = torch.flatten(x, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># N x 1024</span></span><br><span class="line">        x = <span class="variable language_">self</span>.dropout(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        <span class="comment"># N x 1000 (num_classes)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training <span class="keyword">and</span> <span class="variable language_">self</span>.aux_logits:   <span class="comment"># eval model lose this layer</span></span><br><span class="line">            <span class="keyword">return</span> x, aux2, aux1</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_initialize_weights</span>(<span class="params">self</span>): <span class="comment">#初始化参数函数</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="variable language_">self</span>.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                nn.init.normal_(m.weight, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="四-训练模型"><a href="#四-训练模型" class="headerlink" title="四.训练模型"></a>四.训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = GoogLeNet(num_classes=<span class="number">5</span>, aux_logits=<span class="literal">True</span>, init_weights=<span class="literal">True</span>)</span><br><span class="line">net.to(device)</span><br><span class="line">loss_function = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.0003</span>)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">30</span></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line">save_path = <span class="string">&#x27;./googleNet.pth&#x27;</span></span><br><span class="line">train_steps = <span class="built_in">len</span>(train_loader)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># train</span></span><br><span class="line">    net.train()</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    train_bar = tqdm(train_loader, file=sys.stdout)</span><br><span class="line">    <span class="keyword">for</span> step, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_bar):</span><br><span class="line">        images, labels = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        logits, aux_logits2, aux_logits1 = net(images.to(device))</span><br><span class="line">        loss0 = loss_function(logits, labels.to(device))</span><br><span class="line">        loss1 = loss_function(aux_logits1, labels.to(device))</span><br><span class="line">        loss2 = loss_function(aux_logits2, labels.to(device))</span><br><span class="line">        loss = loss0 + loss1 * <span class="number">0.3</span> + loss2 * <span class="number">0.3</span> <span class="comment">#总损失结合相应带权重的辅助分类器的损失</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line"></span><br><span class="line">        train_bar.desc = <span class="string">&quot;train epoch[&#123;&#125;/&#123;&#125;] loss:&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>,</span><br><span class="line">                                                                 epochs,</span><br><span class="line">                                                                 loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># validate</span></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    acc = <span class="number">0.0</span>  <span class="comment"># accumulate accurate number / epoch</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        val_bar = tqdm(validate_loader, file=sys.stdout)</span><br><span class="line">        <span class="keyword">for</span> val_data <span class="keyword">in</span> val_bar:</span><br><span class="line">            val_images, val_labels = val_data</span><br><span class="line">            outputs = net(val_images.to(device))  <span class="comment"># eval model only have last output layer</span></span><br><span class="line">            predict_y = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">            acc += torch.eq(predict_y, val_labels.to(device)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    val_accurate = acc / val_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d] train_loss: %.3f  val_accuracy: %.3f&#x27;</span> %</span><br><span class="line">          (epoch + <span class="number">1</span>, running_loss / train_steps, val_accurate))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val_accurate &gt; best_acc:</span><br><span class="line">        best_acc = val_accurate</span><br><span class="line">        torch.save(net.state_dict(), save_path)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>硕士阶段学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础第三章-VGG网络</title>
    <url>/2024/09/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AB%A0-VGG%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="深度学习基础第三章-VGG网络"><a href="#深度学习基础第三章-VGG网络" class="headerlink" title="深度学习基础第三章-VGG网络"></a>深度学习基础第三章-VGG网络</h1><blockquote>
<p>本模型存放于目录：</p>
<p>E:\python文件\deep-learning-for-image-processing-master\pytorch_classification\Test3_vggnet</p>
</blockquote>
<span id="more"></span>
<h2 id="一-模型介绍"><a href="#一-模型介绍" class="headerlink" title="一.模型介绍"></a>一.模型介绍</h2><p>特点：</p>
<ul>
<li>通过堆叠多个3x3的卷积核来替代大尺度卷积核（减少所需参数）</li>
<li>论文中提到，可以通过堆叠两个3x3的卷积核替代5x5的卷积核，堆叠三个3x3的卷积核替代7x7的卷积核 （拥有相同的感受野）</li>
</ul>
<p><img src="https://s21.ax1x.com/2024/09/02/pAVk8Ag.jpg" alt="pAVk8Ag.jpg"></p>
<h2 id="二-数据集-花分类数据集"><a href="#二-数据集-花分类数据集" class="headerlink" title="二.数据集-花分类数据集"></a>二.数据集-花分类数据集</h2><h3 id="1-定义预处理函数"><a href="#1-定义预处理函数" class="headerlink" title="1.定义预处理函数"></a>1.定义预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_transform = &#123; <span class="comment">#对训练集与测试集图片进行预处理	</span></span><br><span class="line">    <span class="string">&quot;train&quot;</span>: transforms.Compose([transforms.RandomResizedCrop(<span class="number">224</span>), <span class="comment">#裁剪图片尺寸</span></span><br><span class="line">                                 transforms.RandomHorizontalFlip(), <span class="comment">#对图片进行随机翻转</span></span><br><span class="line">                                 transforms.ToTensor(), <span class="comment">#转换为张量形式</span></span><br><span class="line">                                 transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))]), <span class="comment">#标准化数据</span></span><br><span class="line">    <span class="string">&quot;val&quot;</span>: transforms.Compose([transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                               transforms.ToTensor(),</span><br><span class="line">                               transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-从磁盘中读取数据集"><a href="#2-从磁盘中读取数据集" class="headerlink" title="2.从磁盘中读取数据集"></a>2.从磁盘中读取数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_root = os.path.abspath(os.path.join(os.getcwd(), <span class="string">&quot;../..&quot;</span>))  <span class="comment"># get data root path</span></span><br><span class="line">image_path = os.path.join(data_root, <span class="string">&quot;data_set&quot;</span>, <span class="string">&quot;flower_data&quot;</span>)  <span class="comment"># flower data set path</span></span><br><span class="line"><span class="keyword">assert</span> os.path.exists(image_path), <span class="string">&quot;&#123;&#125; path does not exist.&quot;</span>.<span class="built_in">format</span>(image_path)</span><br><span class="line">train_dataset = datasets.ImageFolder(root=os.path.join(image_path, <span class="string">&quot;train&quot;</span>),</span><br><span class="line">                                     transform=data_transform[<span class="string">&quot;train&quot;</span>])</span><br><span class="line">train_num = <span class="built_in">len</span>(train_dataset)</span><br></pre></td></tr></table></figure>
<h3 id="3-保存各类比的字典索引"><a href="#3-保存各类比的字典索引" class="headerlink" title="3.保存各类比的字典索引"></a>3.保存各类比的字典索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;&#x27;daisy&#x27;:0, &#x27;dandelion&#x27;:1, &#x27;roses&#x27;:2, &#x27;sunflower&#x27;:3, &#x27;tulips&#x27;:4&#125;</span></span><br><span class="line">flower_list = train_dataset.class_to_idx</span><br><span class="line">cla_dict = <span class="built_in">dict</span>((val, key) <span class="keyword">for</span> key, val <span class="keyword">in</span> flower_list.items())</span><br><span class="line"><span class="comment"># write dict into json file</span></span><br><span class="line">json_str = json.dumps(cla_dict, indent=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;class_indices.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json_file.write(json_str)</span><br></pre></td></tr></table></figure>
<h3 id="4-加载训练集与测试集"><a href="#4-加载训练集与测试集" class="headerlink" title="4.加载训练集与测试集"></a>4.加载训练集与测试集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset,</span><br><span class="line">                                           batch_size=batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                                           num_workers=<span class="number">0</span></span><br><span class="line">validate_dataset = datasets.ImageFolder(root=os.path.join(image_path, <span class="string">&quot;val&quot;</span>),</span><br><span class="line">                                        transform=data_transform[<span class="string">&quot;val&quot;</span>])</span><br><span class="line">val_num = <span class="built_in">len</span>(validate_dataset)</span><br><span class="line">validate_loader = torch.utils.data.DataLoader(validate_dataset,</span><br><span class="line">                                              batch_size=batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                                              num_workers=nw)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;using &#123;&#125; images for training, &#123;&#125; images for validation.&quot;</span>.<span class="built_in">format</span>(train_num,</span><br><span class="line">                                                                       val_num))</span><br></pre></td></tr></table></figure>
<h2 id="三-网络模型搭建"><a href="#三-网络模型搭建" class="headerlink" title="三.网络模型搭建"></a>三.网络模型搭建</h2><h3 id="1-根据版本提供相应的网络结构"><a href="#1-根据版本提供相应的网络结构" class="headerlink" title="1.根据版本提供相应的网络结构"></a>1.根据版本提供相应的网络结构</h3><ul>
<li>由于vgg网络有很多版本，因此通过字典保存相应不同的结构</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典文件保存各网络模型的配置文件 （特征提取部分）</span></span><br><span class="line">cfgs = &#123; </span><br><span class="line">    <span class="string">&#x27;vgg11&#x27;</span>: [<span class="number">64</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">128</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;vgg13&#x27;</span>: [<span class="number">64</span>, <span class="number">64</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;vgg16&#x27;</span>: [<span class="number">64</span>, <span class="number">64</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;vgg19&#x27;</span>: [<span class="number">64</span>, <span class="number">64</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">&#x27;M&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_features</span>(<span class="params">cfg: <span class="built_in">list</span></span>): <span class="comment">#根据字典的列表得到相应的网络模型结构</span></span><br><span class="line">    layers = []</span><br><span class="line">    in_channels = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> cfg: <span class="comment">#遍历列表</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&quot;M&quot;</span>: <span class="comment">#此时为最大池化层</span></span><br><span class="line">            layers += [nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#其他为卷积层与激活层</span></span><br><span class="line">            conv2d = nn.Conv2d(in_channels, v, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">            layers += [conv2d, nn.ReLU(<span class="literal">True</span>)]</span><br><span class="line">            in_channels = v</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*layers) <span class="comment">#最终返回网络模型</span></span><br></pre></td></tr></table></figure>
<h3 id="2-定义网络模型"><a href="#2-定义网络模型" class="headerlink" title="2.定义网络模型"></a>2.定义网络模型</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VGG</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features, num_classes=<span class="number">1000</span>, init_weights=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(VGG, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.features = features <span class="comment">#定义特征提取层</span></span><br><span class="line">        <span class="variable language_">self</span>.classifier = nn.Sequential(  <span class="comment">#定义全连接层</span></span><br><span class="line">            nn.Linear(<span class="number">512</span>*<span class="number">7</span>*<span class="number">7</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, num_classes)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> init_weights: <span class="comment">#判断是否初始化参数</span></span><br><span class="line">            <span class="variable language_">self</span>._initialize_weights()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): <span class="comment">#前向传播过程</span></span><br><span class="line">        <span class="comment"># N x 3 x 224 x 224</span></span><br><span class="line">        x = <span class="variable language_">self</span>.features(x) <span class="comment">#特征提取层</span></span><br><span class="line">        <span class="comment"># N x 512 x 7 x 7</span></span><br><span class="line">        x = torch.flatten(x, start_dim=<span class="number">1</span>) <span class="comment">#展平</span></span><br><span class="line">        <span class="comment"># N x 512*7*7</span></span><br><span class="line">        x = <span class="variable language_">self</span>.classifier(x) <span class="comment">#全连接分类层</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_initialize_weights</span>(<span class="params">self</span>): <span class="comment">#初始化参数函数</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="variable language_">self</span>.modules(): <span class="comment">#遍历所有层</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.xavier_uniform_(m.weight) <span class="comment">#使用xavier方法对卷积层参数初始化</span></span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.constant_(m.bias, <span class="number">0</span>) <span class="comment">#若采用偏置，将其初始化为0</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                nn.init.xavier_uniform_(m.weight)</span><br><span class="line">                <span class="comment"># nn.init.normal_(m.weight, 0, 0.01)</span></span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-实例化网络模型（使用vgg16）"><a href="#3-实例化网络模型（使用vgg16）" class="headerlink" title="3.实例化网络模型（使用vgg16）"></a>3.实例化网络模型（使用vgg16）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vgg</span>(<span class="params">model_name=<span class="string">&quot;vgg16&quot;</span>, **kwargs</span>): <span class="comment">#实例化模型</span></span><br><span class="line">    <span class="keyword">assert</span> model_name <span class="keyword">in</span> cfgs, <span class="string">&quot;Warning: model number &#123;&#125; not in cfgs dict!&quot;</span>.<span class="built_in">format</span>(model_name)</span><br><span class="line">    cfg = cfgs[model_name]</span><br><span class="line">    model = VGG(make_features(cfg), **kwargs)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<h2 id="四·训练模型"><a href="#四·训练模型" class="headerlink" title="四·训练模型"></a>四·训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_name = <span class="string">&quot;vgg16&quot;</span> <span class="comment">#使用vgg16版本</span></span><br><span class="line">net = vgg(model_name=model_name, num_classes=<span class="number">5</span>, init_weights=<span class="literal">True</span>)</span><br><span class="line">net.to(device)</span><br><span class="line">loss_function = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.0001</span>)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">30</span></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line">save_path = <span class="string">&#x27;./&#123;&#125;Net.pth&#x27;</span>.<span class="built_in">format</span>(model_name) <span class="comment">#设置保存参数文件的路径</span></span><br><span class="line">train_steps = <span class="built_in">len</span>(train_loader)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="comment"># train</span></span><br><span class="line">    net.train()  <span class="comment">#将网络设置为训练模式，此时dropout层将发挥作用</span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    train_bar = tqdm(train_loader, file=sys.stdout) <span class="comment">#利用了 tqdm 库来在训练过程中添加一个进度条，使得用户可以直观地看到数据加载和训练的进度</span></span><br><span class="line">    <span class="keyword">for</span> step, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_bar):</span><br><span class="line">        images, labels = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = net(images.to(device))</span><br><span class="line">        loss = loss_function(outputs, labels.to(device))</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="comment"># 更新 train_bar（即之前通过 tqdm 包装的 train_loader 迭代器）的描述（description）字段。这个描述字段通常用于在进度条旁边显示额外的信息，比如当前的训练轮次（epoch）、总轮次、以及某个指标（如损失值）的当前值。</span></span><br><span class="line">        train_bar.desc = <span class="string">&quot;train epoch[&#123;&#125;/&#123;&#125;] loss:&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>,</span><br><span class="line">                                                                 epochs,</span><br><span class="line">                                                                 loss)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># validate</span></span><br><span class="line">    net.<span class="built_in">eval</span>()</span><br><span class="line">    acc = <span class="number">0.0</span>  <span class="comment"># accumulate accurate number / epoch</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        val_bar = tqdm(validate_loader, file=sys.stdout)</span><br><span class="line">        <span class="keyword">for</span> val_data <span class="keyword">in</span> val_bar:</span><br><span class="line">            val_images, val_labels = val_data</span><br><span class="line">            outputs = net(val_images.to(device))</span><br><span class="line">            predict_y = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">            acc += torch.eq(predict_y, val_labels.to(device)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    val_accurate = acc / val_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d] train_loss: %.3f  val_accuracy: %.3f&#x27;</span> %</span><br><span class="line">          (epoch + <span class="number">1</span>, running_loss / train_steps, val_accurate))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> val_accurate &gt; best_acc:</span><br><span class="line">        best_acc = val_accurate</span><br><span class="line">        torch.save(net.state_dict(), save_path)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="五-测试模型效果"><a href="#五-测试模型效果" class="headerlink" title="五.测试模型效果"></a>五.测试模型效果</h2><ul>
<li>代码与AlnexNet部分一致</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">data_transform = transforms.Compose(</span><br><span class="line">    [transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">     transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image</span></span><br><span class="line">img_path = <span class="string">&quot;../tulip.jpg&quot;</span></span><br><span class="line"><span class="keyword">assert</span> os.path.exists(img_path), <span class="string">&quot;file: &#x27;&#123;&#125;&#x27; dose not exist.&quot;</span>.<span class="built_in">format</span>(img_path)</span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"><span class="comment"># [N, C, H, W]</span></span><br><span class="line">img = data_transform(img)</span><br><span class="line"><span class="comment"># expand batch dimension</span></span><br><span class="line">img = torch.unsqueeze(img, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read class_indict</span></span><br><span class="line">json_path = <span class="string">&#x27;./class_indices.json&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> os.path.exists(json_path), <span class="string">&quot;file: &#x27;&#123;&#125;&#x27; dose not exist.&quot;</span>.<span class="built_in">format</span>(json_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    class_indict = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model</span></span><br><span class="line">model = vgg(model_name=<span class="string">&quot;vgg16&quot;</span>, num_classes=<span class="number">5</span>).to(device)</span><br><span class="line"><span class="comment"># load model weights</span></span><br><span class="line">weights_path = <span class="string">&quot;./vgg16Net.pth&quot;</span></span><br><span class="line"><span class="keyword">assert</span> os.path.exists(weights_path), <span class="string">&quot;file: &#x27;&#123;&#125;&#x27; dose not exist.&quot;</span>.<span class="built_in">format</span>(weights_path)</span><br><span class="line">model.load_state_dict(torch.load(weights_path, map_location=device))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># predict class</span></span><br><span class="line">    output = torch.squeeze(model(img.to(device))).cpu()</span><br><span class="line">    predict = torch.softmax(output, dim=<span class="number">0</span>)</span><br><span class="line">    predict_cla = torch.argmax(predict).numpy()</span><br><span class="line"></span><br><span class="line">print_res = <span class="string">&quot;class: &#123;&#125;   prob: &#123;:.3&#125;&quot;</span>.<span class="built_in">format</span>(class_indict[<span class="built_in">str</span>(predict_cla)],</span><br><span class="line">                                             predict[predict_cla].numpy())</span><br><span class="line">plt.title(print_res)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(predict)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;class: &#123;:10&#125;   prob: &#123;:.3&#125;&quot;</span>.<span class="built_in">format</span>(class_indict[<span class="built_in">str</span>(i)],</span><br><span class="line">                                              predict[i].numpy()))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>硕士阶段学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习第二章-AlexNet</title>
    <url>/2024/08/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0-AlexNet/</url>
    <content><![CDATA[<h1 id="深度学习第二章-AlexNet搭建"><a href="#深度学习第二章-AlexNet搭建" class="headerlink" title="深度学习第二章-AlexNet搭建"></a>深度学习第二章-AlexNet搭建</h1><blockquote>
<p>本模型存放于目录：</p>
<p>E:\python文件\deep-learning-for-image-processing-master\tensorflow_classification\Test2_alexnet</p>
</blockquote>
<span id="more"></span>
<h2 id="一-模型介绍"><a href="#一-模型介绍" class="headerlink" title="一.模型介绍"></a>一.模型介绍</h2><ul>
<li>首次利用GPU进行网络加速训练。</li>
<li>使用了ReLU激活函数，而不是传统的Sigmoid激活函数以及Tanh激活函数。</li>
<li>使用了LRN局部响应归一化。</li>
<li>在全连接层的前两层中使用了Dropout随机失活神经元操作，以减少过拟合。<ul>
<li><img src="https://s21.ax1x.com/2024/08/30/pAAq9vn.png" alt="pAAq9vn.png"></li>
</ul>
</li>
</ul>
<h2 id="二-数据集-花分类数据集"><a href="#二-数据集-花分类数据集" class="headerlink" title="二.数据集-花分类数据集"></a>二.数据集-花分类数据集</h2><h3 id="1-定义预处理函数"><a href="#1-定义预处理函数" class="headerlink" title="1.定义预处理函数"></a>1.定义预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_transform = &#123; <span class="comment">#处理训练集与测试集的方法</span></span><br><span class="line">        <span class="string">&quot;train&quot;</span>: transforms.Compose([transforms.RandomResizedCrop(<span class="number">224</span>), <span class="comment">#随机裁剪</span></span><br><span class="line">                                     transforms.RandomHorizontalFlip(), <span class="comment">#随机翻转</span></span><br><span class="line">                                     transforms.ToTensor(),</span><br><span class="line">                                     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))]),</span><br><span class="line">        <span class="string">&quot;val&quot;</span>: transforms.Compose([transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># cannot 224, must (224, 224)</span></span><br><span class="line">                                   transforms.ToTensor(),</span><br><span class="line">                                   transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-从磁盘中读取数据集"><a href="#2-从磁盘中读取数据集" class="headerlink" title="2.从磁盘中读取数据集"></a>2.从磁盘中读取数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_root = os.path.abspath(os.path.join(os.getcwd(), <span class="string">&quot;../..&quot;</span>))  <span class="comment"># 计算数据集的根目录，从当前目录向上回溯两级目录</span></span><br><span class="line">image_path = os.path.join(data_root, <span class="string">&quot;data_set&quot;</span>, <span class="string">&quot;flower_data&quot;</span>)  <span class="comment"># 从根目录下找到数据集所在的目录</span></span><br><span class="line"><span class="keyword">assert</span> os.path.exists(image_path), <span class="string">&quot;&#123;&#125; path does not exist.&quot;</span>.<span class="built_in">format</span>(image_path) <span class="comment">#检查图片路径是否存在，若不存在，则抛出一个异常</span></span><br><span class="line">train_dataset = datasets.ImageFolder(root=os.path.join(image_path, <span class="string">&quot;train&quot;</span>),</span><br><span class="line">                                     transform=data_transform[<span class="string">&quot;train&quot;</span>])  <span class="comment">#从指定的路径加载，创建训练数据集的对象，并使用预处理方法</span></span><br><span class="line">train_num = <span class="built_in">len</span>(train_dataset) <span class="comment">#计算训练集中的样本总数</span></span><br><span class="line">validate_dataset = datasets.ImageFolder(root=os.path.join(image_path, <span class="string">&quot;val&quot;</span>), </span><br><span class="line">                                        transform=data_transform[<span class="string">&quot;val&quot;</span>]) <span class="comment">#从指定的路径加载，创建测试数据集的对象，并使用预处理方法</span></span><br><span class="line">val_num = <span class="built_in">len</span>(validate_dataset) <span class="comment">#计算测试集中的样本总数</span></span><br></pre></td></tr></table></figure>
<h3 id="3-保存各类别的字典索引"><a href="#3-保存各类别的字典索引" class="headerlink" title="3.保存各类别的字典索引"></a>3.保存各类别的字典索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#123;&#x27;daisy&#x27;:0, &#x27;dandelion&#x27;:1, &#x27;roses&#x27;:2, &#x27;sunflower&#x27;:3, &#x27;tulips&#x27;:4&#125;</span></span><br><span class="line">flower_list = train_dataset.class_to_idx  <span class="comment">#保存一个字典文件,将每个类别的名称映射到该类别的索引</span></span><br><span class="line">cla_dict = <span class="built_in">dict</span>((val, key) <span class="keyword">for</span> key, val <span class="keyword">in</span> flower_list.items()) <span class="comment">#创建一个逆映射，将每个类别的索引映射到该类别的名称</span></span><br><span class="line">json_str = json.dumps(cla_dict, indent=<span class="number">4</span>) <span class="comment">#将cla_dict字典转换成JSON格式的字符串，通过indent=4参数设置缩进来提高可读性</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;class_indices.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> json_file: <span class="comment">#保存到指定的JSON文件中</span></span><br><span class="line">    json_file.write(json_str)</span><br></pre></td></tr></table></figure>
<h3 id="4-加载训练集与测试集"><a href="#4-加载训练集与测试集" class="headerlink" title="4.加载训练集与测试集"></a>4.加载训练集与测试集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset, <span class="comment">#加载数据集</span></span><br><span class="line">                                           batch_size=batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                                           num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">validate_loader = torch.utils.data.DataLoader(validate_dataset, <span class="comment">#加载测试集</span></span><br><span class="line">                                              batch_size=<span class="number">4</span>, shuffle=<span class="literal">False</span>,</span><br><span class="line">                                              num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;using &#123;&#125; images for training, &#123;&#125; images for validation.&quot;</span>.<span class="built_in">format</span>(train_num,</span><br><span class="line">                                                                       val_num))</span><br></pre></td></tr></table></figure>
<h2 id="三-网络模型搭建"><a href="#三-网络模型搭建" class="headerlink" title="三.网络模型搭建"></a>三.网络模型搭建</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlexNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">1000</span>, init_weights=<span class="literal">False</span></span>): <span class="comment">#设置类别个数，以及是否初始化权重</span></span><br><span class="line">        <span class="built_in">super</span>(AlexNet, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.features = nn.Sequential( <span class="comment">#将各层打包为一个模块, input[3, 224, 224]</span></span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">48</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">2</span>),  <span class="comment"># output[48, 55, 55]</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),                  <span class="comment"># output[48, 27, 27]</span></span><br><span class="line">            nn.Conv2d(<span class="number">48</span>, <span class="number">128</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),           <span class="comment"># output[128, 27, 27]</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),                  <span class="comment"># output[128, 13, 13]</span></span><br><span class="line">            nn.Conv2d(<span class="number">128</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),          <span class="comment"># output[192, 13, 13]</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">192</span>, <span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),          <span class="comment"># output[192, 13, 13]</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">192</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),          <span class="comment"># output[128, 13, 13]</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),                  <span class="comment"># output[128, 6, 6]</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.classifier = nn.Sequential(</span><br><span class="line">            nn.Dropout(p=<span class="number">0.5</span>), <span class="comment">#50%概率使全连接层失活</span></span><br><span class="line">            nn.Linear(<span class="number">128</span> * <span class="number">6</span> * <span class="number">6</span>, <span class="number">2048</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">            nn.Linear(<span class="number">2048</span>, <span class="number">2048</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">2048</span>, num_classes),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> init_weights:</span><br><span class="line">            <span class="variable language_">self</span>._initialize_weights()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.features(x)</span><br><span class="line">        x = torch.flatten(x, start_dim=<span class="number">1</span>) <span class="comment">#展平</span></span><br><span class="line">        x = <span class="variable language_">self</span>.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_initialize_weights</span>(<span class="params">self</span>): <span class="comment">#参数的初始化</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="variable language_">self</span>.modules(): <span class="comment">#遍历模型的所有模块，判断模块类型并进行权重初始化</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                nn.init.normal_(m.weight, <span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四-训练模型"><a href="#四-训练模型" class="headerlink" title="四.训练模型"></a>四.训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = AlexNet(num_classes=<span class="number">5</span>, init_weights=<span class="literal">True</span>)</span><br><span class="line">net.to(device)</span><br><span class="line">loss_function = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.0002</span>)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line">save_path = <span class="string">&#x27;./AlexNet.pth&#x27;</span> <span class="comment">#设置保存参数文件的路径</span></span><br><span class="line">best_acc = <span class="number">0.0</span> <span class="comment">#设置最佳准确率</span></span><br><span class="line">train_steps = <span class="built_in">len</span>(train_loader) <span class="comment">#保存训练集的长度</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs): </span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    net.train() <span class="comment">#将网络设置为训练模式，此时dropout层将发挥作用 </span></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    train_bar = tqdm(train_loader, file=sys.stdout) <span class="comment">#利用了 tqdm 库来在训练过程中添加一个进度条，使得用户可以直观地看到数据加载和训练的进度</span></span><br><span class="line">    <span class="keyword">for</span> step, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_bar):</span><br><span class="line">        images, labels = data</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = net(images.to(device))</span><br><span class="line">        loss = loss_function(outputs, labels.to(device))</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">		<span class="comment"># 更新 train_bar（即之前通过 tqdm 包装的 train_loader 迭代器）的描述（description）字段。这个描述字段通常用于在进度条旁边显示额外的信息，比如当前的训练轮次（epoch）、总轮次、以及某个指标（如损失值）的当前值。</span></span><br><span class="line">        train_bar.desc = <span class="string">&quot;train epoch[&#123;&#125;/&#123;&#125;] loss:&#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>,</span><br><span class="line">                                                                 epochs,</span><br><span class="line">                                                                 loss)</span><br><span class="line">        net.<span class="built_in">eval</span>() <span class="comment">#设置为测试模式，此时dropout层效果失效</span></span><br><span class="line">        acc = <span class="number">0.0</span>  <span class="comment"># accumulate accurate number / epoch</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            val_bar = tqdm(validate_loader, file=sys.stdout) <span class="comment">#进度条显示</span></span><br><span class="line">            <span class="keyword">for</span> val_data <span class="keyword">in</span> val_bar:</span><br><span class="line">                val_images, val_labels = val_data</span><br><span class="line">                outputs = net(val_images.to(device))</span><br><span class="line">                predict_y = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">                acc += torch.eq(predict_y, val_labels.to(device)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">        val_accurate = acc / val_num</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[epoch %d] train_loss: %.3f  val_accuracy: %.3f&#x27;</span> %  <span class="comment">#每一次迭代后，打印相关信息</span></span><br><span class="line">              (epoch + <span class="number">1</span>, running_loss / train_steps, val_accurate)) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val_accurate &gt; best_acc: <span class="comment">#保存历史最优准确率，并将该准确率下的参数情况传入到指定文件中</span></span><br><span class="line">            best_acc = val_accurate</span><br><span class="line">            torch.save(net.state_dict(), save_path)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>训练结果如下：</p>
<p><img src="https://s21.ax1x.com/2024/08/31/pAEsrFK.png" alt="pAEsrFK.png"></p>
<h2 id="五-测试模型效果"><a href="#五-测试模型效果" class="headerlink" title="五.测试模型效果"></a>五.测试模型效果</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">data_transform = transforms.Compose(</span><br><span class="line">    [transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">     transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># load image</span></span><br><span class="line">img_path = <span class="string">&quot;../tulip.jpg&quot;</span></span><br><span class="line"><span class="keyword">assert</span> os.path.exists(img_path), <span class="string">&quot;file: &#x27;&#123;&#125;&#x27; dose not exist.&quot;</span>.<span class="built_in">format</span>(img_path)</span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">plt.imshow(img) <span class="comment">#展示图片</span></span><br><span class="line"><span class="comment"># [N, C, H, W]</span></span><br><span class="line">img = data_transform(img) <span class="comment">#对图片进行预处理</span></span><br><span class="line"><span class="comment"># expand batch dimension</span></span><br><span class="line">img = torch.unsqueeze(img, dim=<span class="number">0</span>) <span class="comment">#添加一个维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read class_indict</span></span><br><span class="line">json_path = <span class="string">&#x27;./class_indices.json&#x27;</span> </span><br><span class="line"><span class="keyword">assert</span> os.path.exists(json_path), <span class="string">&quot;file: &#x27;&#123;&#125;&#x27; dose not exist.&quot;</span>.<span class="built_in">format</span>(json_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f: <span class="comment">#读取类别映射文件，并解码</span></span><br><span class="line">    class_indict = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model</span></span><br><span class="line">model = AlexNet(num_classes=<span class="number">5</span>).to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load model weights</span></span><br><span class="line">weights_path = <span class="string">&quot;./AlexNet.pth&quot;</span> </span><br><span class="line"><span class="keyword">assert</span> os.path.exists(weights_path), <span class="string">&quot;file: &#x27;&#123;&#125;&#x27; dose not exist.&quot;</span>.<span class="built_in">format</span>(weights_path)</span><br><span class="line">model.load_state_dict(torch.load(weights_path)) <span class="comment">#读取之前保存的参数文件</span></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment">#设置为测试模式</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># predict class</span></span><br><span class="line">    output = torch.squeeze(model(img.to(device))).cpu() <span class="comment">#输出，并移除张量中所有大小为1的维度</span></span><br><span class="line">    predict = torch.softmax(output, dim=<span class="number">0</span>) <span class="comment">#使用softmax将输出中的张量变成概率分布形式</span></span><br><span class="line">    predict_cla = torch.argmax(predict).numpy() <span class="comment">#找到其中最大的值</span></span><br><span class="line"></span><br><span class="line">print_res = <span class="string">&quot;class: &#123;&#125;   prob: &#123;:.3&#125;&quot;</span>.<span class="built_in">format</span>(class_indict[<span class="built_in">str</span>(predict_cla)], <span class="comment">#返回预测的类别名称与预测概率</span></span><br><span class="line">                                             predict[predict_cla].numpy())</span><br><span class="line">plt.title(print_res) <span class="comment">#展示图片与预测结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(predict)): <span class="comment">#遍历显示所用的预测结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;class: &#123;:10&#125;   prob: &#123;:.3&#125;&quot;</span>.<span class="built_in">format</span>(class_indict[<span class="built_in">str</span>(i)],</span><br><span class="line">                                              predict[i].numpy()))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果如图所示：</p>
<ul>
<li><p><img src="https://s21.ax1x.com/2024/08/31/pAEyAmR.png" alt="pAEyAmR.png"></p>
</li>
<li><p><img src="https://s21.ax1x.com/2024/08/31/pAEySYT.png" alt="pAEySYT.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>硕士阶段学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习第一章-LeNet搭建</title>
    <url>/2024/08/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0-LeNET%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="深度学习第一章-LeNet搭建"><a href="#深度学习第一章-LeNet搭建" class="headerlink" title="深度学习第一章-LeNet搭建"></a>深度学习第一章-LeNet搭建</h1><blockquote>
<p>基于PyTorch框架，本模型存放于目录：</p>
<p>E:\python文件\deep-learning-for-image-processing-master\pytorch_classification\Test1_official_demo</p>
<p>经卷积后的矩阵尺寸大小计算公式为：</p>
<p>N=(W-F+2P)/S+1</p>
<ul>
<li>输入图片大小W×W</li>
<li>Filter大小FXF</li>
<li>步长S</li>
<li>padding的像素数P</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure>
</blockquote>
<span id="more"></span>
<h2 id="一-设置运行设备：GPU运行"><a href="#一-设置运行设备：GPU运行" class="headerlink" title="一.设置运行设备：GPU运行"></a>一.设置运行设备：GPU运行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>) <span class="comment">#确认运行设备为GPU</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;定义了一个名字为Net的网络模型&#x27;&#x27;&#x27;</span></span><br><span class="line">net = Net().to(device) <span class="comment">#实例化一个网络模型,并将网络模型在GPU上运算</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;定义训练方法&#x27;&#x27;&#x27;</span></span><br><span class="line">data,target=data.to(device),target.to(device) <span class="comment">#将数据集添加到GPU上运算</span></span><br></pre></td></tr></table></figure>
<h2 id="二-下载数据集-CIFAR10"><a href="#二-下载数据集-CIFAR10" class="headerlink" title="二.下载数据集-CIFAR10"></a>二.下载数据集-CIFAR10</h2><p>It has the classes:’airplane’,’automobile’,’bird’,’cat’,’deer’,dog’,’frog’,’horse’, ship’,’truck’.</p>
<p>The images in CIFAR-10 are of size 3x32x32</p>
<h3 id="1-定义预处理函数"><a href="#1-定义预处理函数" class="headerlink" title="1.定义预处理函数"></a>1.定义预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform = transforms.Compose( <span class="comment">#预处理函数</span></span><br><span class="line">        [transforms.ToTensor(), <span class="comment">#将图片数据转换为张量</span></span><br><span class="line">         transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))]) <span class="comment">#进行标准化,分别为均值与标准差，			              #output[channel] = (input[channel] - mean[channel]) / std[channel]</span></span><br></pre></td></tr></table></figure>
<h3 id="2-分别下载训练集，测试集并加载"><a href="#2-分别下载训练集，测试集并加载" class="headerlink" title="2.分别下载训练集，测试集并加载"></a>2.分别下载训练集，测试集并加载</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 50000张训练图片</span></span><br><span class="line"><span class="comment"># 第一次使用时要将download设置为True才会自动去下载数据集</span></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>,  <span class="comment">#下载训练集集</span></span><br><span class="line">                                         download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">36</span>,  <span class="comment">#加载训练集</span></span><br><span class="line">                                           shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 10000张验证图片</span></span><br><span class="line"><span class="comment"># 第一次使用时要将download设置为True才会自动去下载数据集</span></span><br><span class="line">val_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                       download=<span class="literal">False</span>, transform=transform)</span><br><span class="line">val_loader = torch.utils.data.DataLoader(val_set, batch_size=<span class="number">5000</span>,</span><br><span class="line">                                         shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-设置一个数据迭代器"><a href="#3-设置一个数据迭代器" class="headerlink" title="3.设置一个数据迭代器"></a>3.设置一个数据迭代器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val_data_iter = <span class="built_in">iter</span>(val_loader) <span class="comment">#将数据转换为迭代器</span></span><br><span class="line">val_image, val_label = <span class="built_in">next</span>(val_data_iter) <span class="comment">#设置迭代器下的输入与输出</span></span><br><span class="line">val_image, val_label = val_image.to(device), val_label.to(device) <span class="comment">#移到GPU</span></span><br></pre></td></tr></table></figure>
<h2 id="三-定义网络模型"><a href="#三-定义网络模型" class="headerlink" title="三.定义网络模型"></a>三.定义网络模型</h2><ul>
<li><strong>张量的序列：（batch,channel,height,width）</strong></li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment">#网络模型搭建</span></span><br><span class="line">        <span class="built_in">super</span>(LeNet, <span class="variable language_">self</span>).__init__() <span class="comment">#必要的初识化函数</span></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.pool1 = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.pool2 = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>) </span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">32</span>*<span class="number">5</span>*<span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): <span class="comment">#前向传播设置</span></span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.conv1(x))    <span class="comment"># input(3, 32, 32) output(16, 28, 28)</span></span><br><span class="line">        x = <span class="variable language_">self</span>.pool1(x)            <span class="comment"># output(16, 14, 14)</span></span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.conv2(x))    <span class="comment"># output(32, 10, 10)</span></span><br><span class="line">        x = <span class="variable language_">self</span>.pool2(x)            <span class="comment"># output(32, 5, 5)</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">32</span>*<span class="number">5</span>*<span class="number">5</span>)       <span class="comment"># output(32*5*5),此处在进入全连接层时，需要将张量展平</span></span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc1(x))      <span class="comment"># output(120)</span></span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc2(x))      <span class="comment"># output(84)</span></span><br><span class="line">        x = <span class="variable language_">self</span>.fc3(x)              <span class="comment"># output(10)</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="四-训练网络模型"><a href="#四-训练网络模型" class="headerlink" title="四.训练网络模型"></a>四.训练网络模型</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">net = LeNet().to(device) <span class="comment">#实例化神经网络模型</span></span><br><span class="line">loss_function = nn.CrossEntropyLoss() <span class="comment">#设置损失函数为交叉熵函数</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>) <span class="comment">#设置参数更新方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line">    </span><br><span class="line">    running_loss = <span class="number">0.0</span> <span class="comment">#损失率累加</span></span><br><span class="line">    <span class="keyword">for</span> step, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader, start=<span class="number">0</span>):</span><br><span class="line">        inputs, labels = data <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        inputs, labels = inputs.to(device), labels.to(device) <span class="comment">#移到GPU</span></span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()  <span class="comment">#梯度清零以防止梯度累计</span></span><br><span class="line">        outputs = net(inputs) <span class="comment">#输入数据训练，得到预测值</span></span><br><span class="line">        loss = loss_function(outputs, labels) <span class="comment">#计算损失值</span></span><br><span class="line">        loss.backward()  <span class="comment">#根据损失值进行反向传播，计算梯度</span></span><br><span class="line">        optimizer.step() <span class="comment">#更新参数</span></span><br><span class="line">        running_loss += loss.item() <span class="comment">#进行损失值累加</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">500</span> == <span class="number">499</span>:    <span class="comment"># print every 500 mini-batches</span></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():  <span class="comment">#在测试过程中不要计算损失梯度</span></span><br><span class="line">                outputs = net(val_image)  <span class="comment"># [batch, 10]</span></span><br><span class="line">                predict_y = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">                accuracy = torch.eq(predict_y, val_label).<span class="built_in">sum</span>().item() / val_label.size(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[%d, %5d] train_loss: %.3f  test_accuracy: %.3f&#x27;</span> %</span><br><span class="line">                      (epoch + <span class="number">1</span>, step + <span class="number">1</span>, running_loss / <span class="number">500</span>, accuracy))</span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://s21.ax1x.com/2024/08/31/pAEswe1.png" alt="pAEswe1.png"></p>
<h2 id="五-保存训练完成之后的模型参数文件"><a href="#五-保存训练完成之后的模型参数文件" class="headerlink" title="五.保存训练完成之后的模型参数文件"></a>五.保存训练完成之后的模型参数文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">save_path = <span class="string">&#x27;./Lenet.pth&#x27;</span></span><br><span class="line">torch.save(net.state_dict(), save_path) </span><br></pre></td></tr></table></figure>
<h2 id="六-使用任意图片测试分类效果"><a href="#六-使用任意图片测试分类效果" class="headerlink" title="六.使用任意图片测试分类效果"></a>六.使用任意图片测试分类效果</h2><ul>
<li>此处在文件夹里面添加了一个文件名为“1.jpg”的飞机图片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)), <span class="comment">#将图像分辨率改变</span></span><br><span class="line">     transforms.ToTensor(), <span class="comment">#将图像数据变为张量形式</span></span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))]) <span class="comment">#标准化图像</span></span><br><span class="line"></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">net = LeNet()</span><br><span class="line">net.load_state_dict(torch.load(<span class="string">&#x27;Lenet.pth&#x27;</span>)) <span class="comment">#载入参数文件</span></span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;1.jpg&#x27;</span>)</span><br><span class="line">im = transform(im)  <span class="comment"># [C, H, W] #调整图像</span></span><br><span class="line">im = torch.unsqueeze(im, dim=<span class="number">0</span>)  <span class="comment"># [N, C, H, W] #增添一个维度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    outputs = net(im)</span><br><span class="line">    predict = torch.<span class="built_in">max</span>(outputs, dim=<span class="number">1</span>)[<span class="number">1</span>].numpy()</span><br><span class="line"><span class="built_in">print</span>(classes[<span class="built_in">int</span>(predict)])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>硕士阶段学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MRI超分辨率-初见</title>
    <url>/2024/08/23/MRI%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87-%E5%88%9D%E8%A7%81/</url>
    <content><![CDATA[<h1 id="MRI超分辨率-初见"><a href="#MRI超分辨率-初见" class="headerlink" title="MRI超分辨率-初见"></a>MRI超分辨率-初见</h1><blockquote>
<p>参考文献：<a href="https://kns.cnki.net/kcms2/article/abstract?v=MBTPQIn9ZKHwJKNtmL5eu7ZFUIb7_nCdbjKrKYFXDX6PgaFW9ljQXL28jn2X8Tj-Fz9N66Pw2G-7sZKyd45rdpBDmk8uzaCVlHLs8CrT9djwL1vEujSi471jNVkdUlEig7F0PF8coO7qxlD8DotHOeCi2IyxGNPoEJVYW6xeQwx-YP19kSVBS-Q5b6eyw2jueAmJScamN0AezEUaa59P5Xn_eLIAQ_aMAfpnTy3Ubv6W8vCSIDYLpFbFr3BReGkWAXsly07QS-ieh65-u_RMjowiogGdel8q&amp;uniplatform=NZKPT&amp;language=CHS">单幅3D磁共振图像超分辨率算法研究</a></p>
</blockquote>
<span id="more"></span>
<h2 id="一-研究背景"><a href="#一-研究背景" class="headerlink" title="一.研究背景"></a>一.研究背景</h2><h3 id="1-MRI图像存在的问题"><a href="#1-MRI图像存在的问题" class="headerlink" title="1.MRI图像存在的问题"></a>1.MRI图像存在的问题</h3><ul>
<li><p>MRI图像的质量受到信噪比（SNR，Signal to Noise Ratio）、分辨率和扫描时间等多方面因素影响</p>
</li>
<li><p>层厚的概念</p>
<ul>
<li><blockquote>
<p>层厚的定义：表示成像层面在三维空间中的厚度。在MRI扫描中，由于技术的限制，无法直接获取无限薄的层面，因此层面的选取在实际操作中都是有一定厚度的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>层厚对图片质量的影响</p>
<ul>
<li>分辨率：层厚直接影响到MRI图像的分辨率。层厚越小，图像的分辨率越高，能够显示更细微的解剖结构。但过小的层厚会导致扫描时间增加，且可能因信号强度不足而影响图像质量。</li>
<li>信噪比：层厚还影响图像的信噪比。层厚较小时，每个体素内质子数量减少，产生的信号强度降低，可能导致信噪比下降。而适当增加层厚，可以提高信号强度，改善图像质量。</li>
<li>扫描时间：层厚越大，扫描时间越短</li>
</ul>
</li>
</ul>
<h3 id="2-优化MRI图像的方法—-超分辨率"><a href="#2-优化MRI图像的方法—-超分辨率" class="headerlink" title="2.优化MRI图像的方法—-超分辨率"></a>2.优化MRI图像的方法—-超分辨率</h3><ul>
<li>定义：超分辨率（SR，Super-resolution）算法是一种从软件层面提高 MRI 图像分辨率的有效方案。从软件方面提升 MRI 图像分辨率的方式具有良好的可移植性与扩展性。</li>
<li>MRI 图像超分辨率问题是典型的病态逆问题，其主要目的是从一幅或多幅低分辨率MRI图像中重建出对应的高分辨率 MRI 图像</li>
</ul>
<h3 id="3-超分辨率的不同研究类别"><a href="#3-超分辨率的不同研究类别" class="headerlink" title="3.超分辨率的不同研究类别"></a>3.超分辨率的不同研究类别</h3><ul>
<li><p>静态对象与动态对象</p>
</li>
<li><p>单幅低分辨率图像和多幅低分辨率图像</p>
<ul>
<li><p>多幅的方法需要将多幅低分辨率的 MRI 图像进行配准与重采样</p>
</li>
<li><p>配准概念</p>
<blockquote>
<ul>
<li><p>配准（Image Registration）也被称为图像匹配或图像相关，是图像处理中的一个关键步骤。它旨在将两幅或多幅图像中的相应部分进行空间上的对齐，使它们在同一坐标系下具有相同的空间位置。这个过程要求相邻图像之间有一部分在逻辑上是相同的，即相邻的图像有一部分反映了同一目标区域，这是实现图像配准的基本条件。</p>
<p>配准通常包括两个主要步骤：空间变换和灰度变换。</p>
<ul>
<li><strong>空间变换</strong>：将图像像素的坐标从一个坐标系映射到另一个新的坐标系中，通常使用多项式函数或其他变换模型来描述这种映射关系。对于具有全局性形变的图像配准问题，非线性变换（如将直线映射为曲线）是一个常用的选择。</li>
<li><strong>灰度变换</strong>：在空间变换完成后，对变换后的图像值进行重新赋值，以确保图像在视觉上保持一致性和连续性。这一步骤与重采样紧密相关。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>重采样概念</p>
<blockquote>
<ul>
<li><p>重采样（Resampling）是指根据一类象元（像素）的信息内插出另一类象元信息的过程。在遥感、图像处理及GIS等领域中，重采样常用于从高分辨率图像中提取低分辨率图像，或者对图像进行几何校正、尺寸调整等操作。</p>
<p>重采样的方法多种多样，常见的包括最邻近法、双线性内插法和三次卷积内插法等。</p>
<ul>
<li><strong>最邻近法</strong>：将距离某像元位置最近的像元值作为该像元的新值。这种方法简单高效，但可能会产生半个像元大小的位移，计算不够精确。</li>
<li><strong>双线性内插法</strong>：通过取采样点到周围4个邻域像元的距离加权来计算其新值。这种方法通常比最邻近法产生的结果更加光滑，但可能会改变原始栅格值，丢失一些局部细微的特征。</li>
<li><strong>三次卷积内插法</strong>：通过增加参与内插计算的邻近像元的数目来提高重采样的精度。这种方法能够增强图像的细节表现，但计算量较大，且同样会改变原始栅格值。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>频域与空间域：空间域中处理更优</p>
</li>
<li><p>各向同性与各向异性</p>
<ul>
<li>各向同性 3D MRI 图像超分辨率方法主要目标是提高 3D MRI 图像所有层面的分辨率，使其整体的分辨率更高。</li>
<li>各向异性：由于成像技术的限制，图像在不同方向上的分辨率往往是不均等的。这种在不同方向上分辨率存在差异的现象被称为“各向异性”。<ul>
<li>对于3D MRI图像来说，这种各向异性主要体现在层面选择方向（通常指的是沿着成像序列中切片堆叠的方向，即深度或厚度方向）与层面内方向（即每个切片内部的二维空间，包括宽度和高度方向）的分辨率差异上</li>
<li>在3D MRI图像中，沿着层面选择方向（深度或厚度）的像素（或体素）尺寸通常比层面内方向的像素尺寸要大，因此在这个方向上的图像细节相对较少，分辨率较低。</li>
<li>相比之下，层面内的切片包含了更多的细节信息，即高频信息（图像中变化较快的部分，如边缘、纹理等），这些信息的分辨率较高。</li>
<li>对于各向异性的3D MRI图像，超分辨率方法的主要目标是提高层面选择方向的分辨率，以减小或消除与层面内方向分辨率之间的差异。</li>
<li>通过这种方法，可以使得3D MRI图像在所有方向上的分辨率更加均匀，从而提高图像的整体质量和可用性。</li>
</ul>
</li>
</ul>
<h3 id="4-超分辨率的研究算法分类"><a href="#4-超分辨率的研究算法分类" class="headerlink" title="4.超分辨率的研究算法分类"></a>4.超分辨率的研究算法分类</h3><ul>
<li>基于插值的超分辨率算法<ul>
<li>方法：预定义一个变换函数，并利用已知的 MRI 图像像素或体素信息来对未知的像素或体素信息进行拟合。</li>
<li>该类算法虽然简单高效，但也存在着一定的缺陷，如插值后的图像具有比较明显的块效应、振铃效应与锯齿效应。</li>
</ul>
</li>
<li>基于重构的超分辨算法<ul>
<li>方法：从图像的降质退化模型出发，对高分辨率 MRI 图像退化到低分辨率 MRI 图像的过程进行建模（运动变换、模糊及噪声等），而后求解成像系统的逆过程。这种算法会提取低分辨率图像中的关键信息，并通过先验知识来约束高分辨率图像的的重建过程。</li>
<li>该类算法在重建系数较小时能达到令人满意的结果，但当重建系数较大时，很难获得合适的人工定义的先验知识与正则参数，因此难以保证超分辨率图像的质量。</li>
</ul>
</li>
<li>基于学习的超分辨率算法（✪）<ul>
<li>从大量的训练数据中学习高分辨率图像和低分辨率图像之间某种映射关系，并根据学习到的映射关系提高目标低分辨率图像的分辨率</li>
<li>分类<ul>
<li>基于浅层学习的超分辨率算法<ul>
<li>将整个超分辨率过程分为样本库的建立（特征提取）、特征映射（学习与搜索）、高频信息重建三个阶段，且每个阶段独立优化</li>
</ul>
</li>
<li>基于深度学习的超分辨率算法（✪）<ul>
<li>直线结构    <ul>
<li>指整个图像超分辨率网络结构是一个不包含任何跳接或分支的线性结构，即模型是由多个卷积层依次堆叠组成。该类结构具有简单、效率高等特点</li>
<li>使用线性结构的算法具有结构简单、重建速度快等优点，但同时存在收敛速度慢，训练过程中容易产生梯度消失与爆炸的问题</li>
</ul>
</li>
<li>跳接结构<ul>
<li>是指在线性结构的基础上加入卷积层之间的跨层跳接。跳接结构通过信息跨层传递的方式来缓解梯度消失与爆炸问题，同时为设计更深的网络结构提供可能。</li>
<li>残差跳接是将不同卷积层的特征进行对应通道的相加，即融合后的特征图保持通道数量不变，但特征图内容发生了变化。</li>
<li>通道连接跳接则是将不同卷积层的特征以通道方向进行拼接，融合后的特征图不变，但通道数量增加。</li>
</ul>
</li>
<li>递归结构<ul>
<li>将卷积层的输出继续作为该层卷积的输入，由于多次卷积操作的参数是一样的，该种递归卷积的方式可以有效地减少网络的参数数量。</li>
</ul>
</li>
<li>生成对抗结构<ul>
<li>采用的是一种博弈论的思想，该类模型由生成器与鉴别器两部分组成。生成器生成高分辨率图像，鉴别器区分真实的高分辨率图像与生成器生成的高分辨率图像。</li>
</ul>
</li>
<li>注意力结构<ul>
<li>注意力结构则是利用人类视觉中的注意力机制，对网络所提取的特征进行重新校准</li>
<li>注意力结构可以有效的调整特征通道或特征本身不同区域的权重，专注于模型中对最终结果贡献大的特征或特征区域</li>
</ul>
</li>
</ul>
</li>
<li>图示<ul>
<li><img src="https://s21.ax1x.com/2024/08/27/pAk4BcT.png" alt="pAk4BcT.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二-基础知识（基于CNN的算法）"><a href="#二-基础知识（基于CNN的算法）" class="headerlink" title="二.基础知识（基于CNN的算法）"></a>二.基础知识（基于CNN的算法）</h2><h3 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1.数据预处理"></a>1.数据预处理</h3><ul>
<li><p><img src="https://s21.ax1x.com/2024/08/27/pAk4DjU.png" alt="pAk4DjU.png"></p>
</li>
<li><h4 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h4><ul>
<li>需将 MRI 图像的体素值归一化到相同的取值范围（如[0，1]），使优化时大部分位置的梯度方向近似于最优搜索方向，从而提高训练效率。否则会导致模型收敛慢。</li>
</ul>
</li>
<li><h4 id="模拟退化"><a href="#模拟退化" class="headerlink" title="模拟退化"></a>模拟退化</h4><ul>
<li>首先将高分辨率 MRI 图像经过傅里叶变换至 k 空间。<ul>
<li>k 空间中央部分包含的数据具有高信号振幅和低分辨率，决定 MRI 图像的对比度</li>
<li>边缘的部分具有低信号振幅和高分辨率，决定 MRI 图像的解剖细节。</li>
</ul>
</li>
<li>k 空间的模拟退化中，本文仅保留中央部分的信息。根据超分辨率重建系数对 k 空间数据的边缘部分进行截断处理，并用零填充的方式对截断的部分进行填充。随后对填充过的 k 空间数据进行傅里叶逆变换，将其转化至图像空间。</li>
<li>最后，对 MRI 图像进行空间下采样至目标大小，生成最终的低分辨率 MRI 图像</li>
<li>傅里叶变换：将图像从空间域（spatial domain）转换到频率域（frequency domain）。这种转换使我们能够分析图像的频率成分，即图像中不同模式的强度或频率。</li>
<li><img src="https://s21.ax1x.com/2024/08/27/pAk4f9x.png" alt="pAk4f9x.png"></li>
</ul>
</li>
<li><h4 id="块切分"><a href="#块切分" class="headerlink" title="块切分"></a>块切分</h4><ul>
<li>在构建训练集时将整幅 3D MRI 图像切割成固定大小的 3D MRI 图像块。本文采用固定步长的滑动窗口方式来对图像进 行切割，保证相邻图像块既有相似重叠区域又有不同区域，从而提升训练数据的 数量与训练数据的丰富度。</li>
</ul>
</li>
</ul>
<h3 id="2-模型框架"><a href="#2-模型框架" class="headerlink" title="2.模型框架"></a>2.模型框架</h3><ul>
<li><p><img src="https://s21.ax1x.com/2024/08/27/pAk4h36.png" alt="pAk4h36.png"></p>
</li>
<li><p>预采样模型框架</p>
<ul>
<li>该类框架需将低分辨率图像在输入网络前用传统的插值方法（线性插值法或双三次插值法）上采样到目标高分辨率图像的大小，而后再用 CNN 模型重建出高质量的纹理细节， 进一步提高图像的质量。</li>
</ul>
</li>
<li><p>后上采样模型框架</p>
<ul>
<li>该类模型框架以原始的低分辨率图像作为输入，将上采样任务放在模型的尾端。该类模型直接从原始低分辨率图像中提取特征并学习数据的原始分布，用可学习的上采样方式（如：反卷积与亚像素卷积）对图像进行上采样与重建。</li>
</ul>
</li>
<li><p>渐进式上采样模型框架</p>
<ul>
<li>该框架将大尺度超分辨率重建问题分解为多个小尺度的超分辨率重建问题。该框架利用级联的方式进行对图像进行逐步的上采样，并在此过程中融入多监督机制来缓解学习难度大的问题。</li>
</ul>
</li>
<li>迭代上下采样模型框架<ul>
<li>该类模型框架通过反复的将低分辨率空间图像上采样至高分辨率空间，再将高分辨率空间图像下采样至低分辨率空间，在此过程中利用投影误差来反复纠正超分辨率结果，达到提升超分辨性能的目的。</li>
</ul>
</li>
</ul>
<h2 id="三-评价标准"><a href="#三-评价标准" class="headerlink" title="三.评价标准"></a>三.评价标准</h2><ul>
<li>峰值信噪比（PSNR）<ul>
<li><script type="math/tex; mode=display">M S E = \frac { 1 } { N } \sum _ { I = 1 } ^ { N } ( I _ { y } ( i ) - \widehat { I } _ { y } ( i ) ) ^ { 2 }</script></li>
<li><script type="math/tex; mode=display">P S N R = 1 0 \cdot \log _ { 1 0 } ( \frac { L ^ { 2 } } { M S E } )</script></li>
</ul>
</li>
<li><p>结构相似度指数（SSIM）</p>
<ul>
<li><img src="https://s21.ax1x.com/2024/08/27/pAk45jO.png" alt="pAk45jO.png"></li>
</ul>
</li>
<li><p>主观评价</p>
</li>
</ul>
<h2 id="四-超分辨率的相关总结"><a href="#四-超分辨率的相关总结" class="headerlink" title="四.超分辨率的相关总结"></a>四.超分辨率的相关总结</h2><h3 id="1-超分辨率算法分类"><a href="#1-超分辨率算法分类" class="headerlink" title="1.超分辨率算法分类"></a>1.超分辨率算法分类</h3><h4 id="①-基于插值的算法"><a href="#①-基于插值的算法" class="headerlink" title="① 基于插值的算法"></a>① 基于插值的算法</h4><h4 id="②-基于重建的算法"><a href="#②-基于重建的算法" class="headerlink" title="② 基于重建的算法"></a>② 基于重建的算法</h4><h4 id="③-基于学习的算法-（常用）"><a href="#③-基于学习的算法-（常用）" class="headerlink" title="③ 基于学习的算法 （常用）"></a>③ 基于学习的算法 （常用）</h4><ul>
<li>基于深度学习的算法：基于深度学习的ＳＲ重建算法通常是构建一个端对端的网络模型，将ＬＲ图像输入到该特定网络模型中，通过特征映射和尺度放大等方式优化网络的损失函数，进而得到ＨＲ图 像</li>
</ul>
<h3 id="2-尺度放大方式"><a href="#2-尺度放大方式" class="headerlink" title="2.尺度放大方式"></a>2.尺度放大方式</h3><h4 id="①-上采样方法"><a href="#①-上采样方法" class="headerlink" title="① 上采样方法"></a>① 上采样方法</h4><h5 id="基于插值的上采样"><a href="#基于插值的上采样" class="headerlink" title="基于插值的上采样"></a>基于插值的上采样</h5><h5 id="基于反卷积的上采样-（常用）"><a href="#基于反卷积的上采样-（常用）" class="headerlink" title="基于反卷积的上采样 （常用）"></a>基于反卷积的上采样 （常用）</h5><h5 id="基于亚像素卷积的上采样"><a href="#基于亚像素卷积的上采样" class="headerlink" title="基于亚像素卷积的上采样"></a>基于亚像素卷积的上采样</h5><h4 id="②-上采样实施方式"><a href="#②-上采样实施方式" class="headerlink" title="② 上采样实施方式"></a>② 上采样实施方式</h4><h5 id="预先上采样"><a href="#预先上采样" class="headerlink" title="预先上采样"></a>预先上采样</h5><h5 id="单次上采样"><a href="#单次上采样" class="headerlink" title="单次上采样"></a>单次上采样</h5><h5 id="渐进上采样"><a href="#渐进上采样" class="headerlink" title="渐进上采样"></a>渐进上采样</h5><h5 id="迭代上采样-（常用）"><a href="#迭代上采样-（常用）" class="headerlink" title="迭代上采样 （常用）"></a>迭代上采样 （常用）</h5><h3 id="3-模型结构组成"><a href="#3-模型结构组成" class="headerlink" title="3.模型结构组成"></a>3.模型结构组成</h3><h4 id="①-基于CNN的模型（一般不使用池化层）"><a href="#①-基于CNN的模型（一般不使用池化层）" class="headerlink" title="① 基于CNN的模型（一般不使用池化层）"></a>① 基于CNN的模型（一般不使用池化层）</h4><h5 id="直线连接模型"><a href="#直线连接模型" class="headerlink" title="直线连接模型"></a>直线连接模型</h5><ul>
<li>最大问题就是随着网络深度的加深，参数逐渐增加，网络训练的难度越来越大，导致网络难以收敛，</li>
</ul>
<h5 id="残差连接模型"><a href="#残差连接模型" class="headerlink" title="残差连接模型"></a>残差连接模型</h5><ul>
<li>由于原始ＬＲ图像和输出的ＨＲ图像在很大程度上是相似的， 也就是说ＬＲ图像携带的低频信息与ＨＲ图像的低频信息基本一致。残差连接的应用使得原始的稠密矩阵学习转化为稀疏矩阵学习，因而使得计算量大幅度降低</li>
</ul>
<h5 id="密集连接模型"><a href="#密集连接模型" class="headerlink" title="密集连接模型"></a>密集连接模型</h5><ul>
<li>在保证网络中层与层之间最大程度的信息传输的前提下，直接将所有层连接起来，使网络中每一层输入为之前卷积层输出的总和，极大地增强了信息流动的能力，有效抑制了梯度爆炸和消失的问题。</li>
</ul>
<h5 id="注意力模型"><a href="#注意力模型" class="headerlink" title="注意力模型"></a>注意力模型</h5><ul>
<li>通过学习不同通道的重要性得到一个权重值，这相当于对信道间特征的相互关系进行建模， 自适应调整每个信道特征，从而在有效强化有用特 征通道的同时抑制无用特征通道，使计算资源得到更充分的利用。</li>
</ul>
<h4 id="②-基于CNN-RNN的模型"><a href="#②-基于CNN-RNN的模型" class="headerlink" title="② 基于CNN-RNN的模型"></a>② 基于CNN-RNN的模型</h4><ul>
<li>递归神经网络就是充分利用参数共享机制，使其在不增加参数的情况下加深网络的深度，降低网络的复杂度，加快训练速度</li>
</ul>
<h4 id="③-基于GAN的模型"><a href="#③-基于GAN的模型" class="headerlink" title="③ 基于GAN的模型"></a>③ 基于GAN的模型</h4><ul>
<li><img src="https://s21.ax1x.com/2024/08/27/pAk7O6x.png" alt="pAk7O6x.png"></li>
</ul>
<h3 id="4-损失函数分类"><a href="#4-损失函数分类" class="headerlink" title="4.损失函数分类"></a>4.损失函数分类</h3><h4 id="①基于像素的损失函数"><a href="#①基于像素的损失函数" class="headerlink" title="①基于像素的损失函数"></a>①基于像素的损失函数</h4><ul>
<li>均方误差（MSE）</li>
<li>平均绝对值误差（MAE）</li>
<li>本质上都是反映对应像素之间的误差关系，忽略了像素与邻域像素间存在的内在联系，因 而重建图像质量存在边缘模糊和振铃现象。</li>
</ul>
<h4 id="②基于感知的损失函数"><a href="#②基于感知的损失函数" class="headerlink" title="②基于感知的损失函数"></a>②基于感知的损失函数</h4><ul>
<li>内容损失函数</li>
<li>对抗损失函数</li>
<li>上下文损失函数</li>
</ul>
]]></content>
      <categories>
        <category>学术论文总结</category>
      </categories>
      <tags>
        <tag>MRI超分辨率</tag>
      </tags>
  </entry>
  <entry>
    <title>医学图像降噪-初见</title>
    <url>/2024/08/19/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E9%99%8D%E5%99%AA-%E5%88%9D%E8%A7%81/</url>
    <content><![CDATA[<h1 id="医学图像降噪-初见（未完待续）"><a href="#医学图像降噪-初见（未完待续）" class="headerlink" title="医学图像降噪-初见（未完待续）"></a>医学图像降噪-初见（未完待续）</h1><blockquote>
<p>医学图像降噪概况-参考论文：<a href="https://www.sciencedirect.com/science/article/pii/S1746809420301920">A review on medical image denoising algorithms</a></p>
</blockquote>
<span id="more"></span>
<h2 id="一-主要的问题"><a href="#一-主要的问题" class="headerlink" title="一.主要的问题"></a>一.主要的问题</h2><ul>
<li>医学图像将被噪音影响，噪声包括随机噪声，白噪声（在一定频率范围内的功率谱密度均匀分布的噪声），伪影</li>
<li>伪影（Artifacts）：与患者有关或者与机器有关，指的是原本被扫描或拍摄的物体上并不存在，但在最终生成的图像上却出现的各种形态的影像。</li>
</ul>
<h2 id="二-医学图像分类"><a href="#二-医学图像分类" class="headerlink" title="二.医学图像分类"></a>二.医学图像分类</h2><h3 id="1-Ultrasound-US-images（超声图像）"><a href="#1-Ultrasound-US-images（超声图像）" class="headerlink" title="1.Ultrasound (US) images（超声图像）"></a>1.Ultrasound (US) images（超声图像）</h3><ul>
<li><p>概述：利用超声波在组织内的传播、反射和衍射等现象，通过声波与组织之间的相互作用，获取人体内部结构的图像（对气体及骨性结构成像效果差）</p>
</li>
<li><p>斑点噪声（Speckle）</p>
<blockquote>
<p>由于超声波在人体组织中的散射效应而产生的随机分布的亮点或暗点。这些斑点噪声的形成主要是由于人体软组织对探头发射出的超声波会形成大量大小不等、方向各异的回波界面，这些回波在局部空间相互叠加或抵消，从而形成回声强度不一的斑点，即超声散斑。</p>
</blockquote>
</li>
</ul>
<h3 id="2-Magnetic-Resonance-MR-images（核磁共振图像）"><a href="#2-Magnetic-Resonance-MR-images（核磁共振图像）" class="headerlink" title="2.Magnetic Resonance (MR) images（核磁共振图像）"></a>2.Magnetic Resonance (MR) images（核磁共振图像）</h3><ul>
<li><p>利用原子核在磁场内共振所产生的信号经重建成像而得到的。</p>
<blockquote>
<p>当人体置于特定的磁场中，并接受一定频率的射频脉冲激励时，人体组织中的氢原子核会发生磁共振现象。射频脉冲终止后，氢原子核在驰豫过程中会感应出MR信号，这些信号被接收并经过空间编码和图像重建等处理过程，最终生成MR图像。</p>
</blockquote>
</li>
</ul>
<h3 id="3-Computed-Tomography-CT-计算机断层扫描"><a href="#3-Computed-Tomography-CT-计算机断层扫描" class="headerlink" title="3.Computed Tomography (CT,计算机断层扫描)"></a>3.Computed Tomography (CT,计算机断层扫描)</h3><ul>
<li>使用X射线束从一些不同的角度观察对象，然后将其横截面图像重建为3D数据</li>
<li>由X射线量子的统计涨落引起的量子噪声是CT投影（正弦图）中的主要噪声源</li>
</ul>
<h3 id="4-Positron-Emission-Tomog-raphy-images-PET-正电子发射断层扫描"><a href="#4-Positron-Emission-Tomog-raphy-images-PET-正电子发射断层扫描" class="headerlink" title="4.Positron Emission Tomog-raphy  images (PET,正电子发射断层扫描)"></a>4.Positron Emission Tomog-raphy  images (PET,正电子发射断层扫描)</h3><ul>
<li>PET通过检测放射性物质发出的辐射来产生身体的图像。这些物质被注射到体内，通常用放射性原子标记，如衰变时间短的碳11。</li>
</ul>
<h2 id="三-医学图像降噪的基本需求"><a href="#三-医学图像降噪的基本需求" class="headerlink" title="三.医学图像降噪的基本需求"></a>三.医学图像降噪的基本需求</h2><ul>
<li>边缘保护和细节</li>
<li>保持结构相似性（不出现伪影）</li>
<li>降低复杂度</li>
<li>对数据集的数量要求不多</li>
</ul>
<h2 id="四-相关技术"><a href="#四-相关技术" class="headerlink" title="四.相关技术"></a>四.相关技术</h2><h3 id="1-超声图像（US）"><a href="#1-超声图像（US）" class="headerlink" title="1.超声图像（US）"></a>1.超声图像（US）</h3><ul>
<li>斑点噪声（由散射现象引起的）会降低图片的质量</li>
<li>待续</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>医学图像去噪问题<ul>
<li>（i）保留边缘和其他更精细的细节</li>
<li>（ii）保持结构相似性</li>
<li>（iii）不出现伪影和</li>
<li>（iv）低操作复杂度。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学术论文总结</category>
      </categories>
      <tags>
        <tag>医学图像降噪</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第五章-输入/输出(I/O)管理</title>
    <url>/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-I-O-%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="操作系统第五章-输入-输出（I-O）管理"><a href="#操作系统第五章-输入-输出（I-O）管理" class="headerlink" title="操作系统第五章 输入/输出（I/O）管理"></a>操作系统第五章 输入/输出（I/O）管理</h2><blockquote>
<p>计算机学科基础：操作系统第五章输入/输出(I/O)管理的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-I-O管理概述（✠）"><a href="#一-I-O管理概述（✠）" class="headerlink" title="一.I/O管理概述（✠）"></a>一.I/O管理概述（✠）</h3><h4 id="1-I-O设备"><a href="#1-I-O设备" class="headerlink" title="1.I/O设备"></a>1.I/O设备</h4><ul>
<li><p>I/O设备的定义</p>
<ul>
<li>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</li>
<li>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</li>
<li>Write:操作：向外部设备写出数据；Read操作：从外部设备读入数据</li>
</ul>
</li>
<li><p>I/O设备的分类</p>
<ul>
<li>按信息交换的单位分类<ul>
<li>块设备：信息交换以数据块为单位。它属于有结构设备，<strong>如磁盘等</strong>。<br>磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读/写任意一块，<strong>如共享设备</strong>。</li>
<li>字符设备：信息交换以字符为单位。它属于无结构类型，<strong>如交互式终端机、打印机等</strong>。<br>传输速率较慢，不可寻址，在输入/输出时常采用<strong>中断驱动方式</strong></li>
</ul>
</li>
<li>按使用特性分类<ul>
<li>人机交互类外部设备：鼠标、键盘、打印机等一一用于人机交互，数据传输速度慢</li>
<li>存储设备：移动硬盘、光盘等一一用于数据存储，数据传输速度快</li>
<li>网络通信设备：调制解调器等一一用于网络通信，数据传输速度介于上述二者之间</li>
</ul>
</li>
<li>按传输速率分类<ul>
<li>低速设备。传输速率仅为每秒几字节到数百字节的一类设备，如键盘、鼠标等。</li>
<li>中速设备。传输速率为每秒数千字节至数万字节的一类设备，如激光打印机等。</li>
<li>高速设备。传输速率在数百千字节至千兆字节的一类设备，如磁盘机、光盘机等。</li>
</ul>
</li>
</ul>
</li>
<li>I/O设备的组成<ul>
<li>机械部件<ul>
<li>I/O设备的机械部件主要用来执行具体I/O操作<br>如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。</li>
</ul>
</li>
<li>电子部件<ul>
<li>I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板</li>
<li>I/O接口（I/O控制器，设备控制器）<ul>
<li>I/O接口（设备控制器）位于CPU与设备之间（作为中介），<br>它既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能</li>
<li>I/O设备的功能<ul>
<li>接受和识别CPU发出的命令（<strong>要有控制寄存器</strong>）<ul>
<li>如CPU发来的read/write命令，I/O控制器中会有相应的控制寄存器来存放命令和参数</li>
</ul>
</li>
<li>向CPU报告设备的状态（<strong>要有状态寄存器</strong>）<ul>
<li>I/O控制器中会有相应的状态寄存器用于记录1/0设备的当前状态。如：1表示空闲，0表示忙碌</li>
</ul>
</li>
<li>数据交换（<strong>要有数据寄存器，暂存输入输出的数据</strong>）<ul>
<li>I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。</li>
<li>输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据</li>
</ul>
</li>
<li>地址识别（<strong>由I/O逻辑实现</strong>)<ul>
<li>类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的“地址”。</li>
<li>I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</li>
</ul>
</li>
</ul>
</li>
<li>I/O接口的组成<ul>
<li>CPU与控制器之间的接口（<strong>实现控制器与CPU之间的通信</strong>）<ul>
<li>用于实现CPU与控制器之间的通信。</li>
<li>CPU通过控制线发出命令；通过地址线指明要操作的设备；<br>通过数据线来取出（输入）数据，或放入（输出）数据</li>
<li>数据线常与两类寄存器相连：数据寄存器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制/状态寄存器(存放从CPU送来的控制信息或设备的状态信息)。</li>
</ul>
</li>
<li>I/O逻辑（<strong>负责识别CPU发出的命令，并向设备发出命令，实现对设备的控制</strong>）<ul>
<li>用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。</li>
<li>CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。</li>
</ul>
</li>
<li>控制器与设备之间的接口（<strong>实现控制器与设备之间的通信</strong>）<ul>
<li>一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。每个接口中都存在数据、控制和状态三种类型的信号。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtdZlT.png" alt="pPtdZlT.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>I/O端口<ul>
<li>I/O端口是指设备控制器中可被CPU直接访问的寄存器</li>
<li>寄存器的分类<ul>
<li>数据寄存器：实现CPU和外设之间的数据缓冲。</li>
<li>状态寄存器：获取执行结果和设备的状态信息，以让CPU知道是否准备好。</li>
<li>控制寄存器：由CPU写入，以便启动命令或更改设备模式。</li>
</ul>
</li>
<li>寄存器的两种编址方式<ul>
<li>独立编址。为每个端口分配一个I/O端口号，所有I/O端口形成I/O端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的I/O指令才能访问端口</li>
<li>统一编址。又称<strong>内存映射I/O</strong>，每个端口被分配唯一的内存地址，且不会有内存被分配这一地址，通常分配给端口的地址靠近地址空间的顶端。可以采用对内存进行操作的指令来对控制器进行操作</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtdx41.png" alt="pPtdx41.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-I-O控制方式"><a href="#2-I-O控制方式" class="headerlink" title="2.I/O控制方式"></a>2.I/O控制方式</h4><ul>
<li>程序直接控制方式（轮询）<ul>
<li>完成一次读/写操作的流程<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPt0FzV.png" alt="pPt0FzV.png"></li>
</ul>
</li>
<li>流程图<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPt0AMT.png" alt="pPt0AMT.png"></li>
</ul>
</li>
<li>CPU干预的频率<ul>
<li>很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查。</li>
</ul>
</li>
<li>数据传送的单位：每次读/写一个字</li>
<li>数据的流向<ul>
<li>读操作（数据输入）：I/O设备→CPU→内存</li>
<li>写操作（数据输出）：内存→CPU→I/O设备</li>
<li>每个字的读/写都需要CPU的帮助</li>
</ul>
</li>
<li>主要缺点和主要优点<ul>
<li>优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可(因此才称为“程序直接控制方式”)</li>
<li><strong>缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>中断驱动方式<ul>
<li>完成一次读写操作的流程<ul>
<li>引入中断机制。由于I/O设备速度很慢，因此在CPU发出读/写命令后，可将等待I/O的进程阻塞，先切换到别的进程执行。</li>
<li>当I/O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</li>
<li>处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I/O的进程（或其他进程）的运行环境，然后继续执行。</li>
<li>注意<ul>
<li>①CPU会在每个指令周期的末尾检查中断</li>
<li>②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能。</li>
</ul>
</li>
</ul>
</li>
<li>流程图<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPt0Lk9.png" alt="pPt0Lk9.png"></li>
</ul>
</li>
<li>CPU干预的频率<ul>
<li>每次I/O操作开始之前、完成之后需要CPU介入。</li>
<li>等待I/O完成的过程中CPU可以切换到别的进程执行。</li>
</ul>
</li>
<li>数据传送的单位：每次读/写一个字</li>
<li>数据的流向<ul>
<li>读操作（数据输入）：I/O设备→CPU→内存</li>
<li>写操作（数据输出）：内存→CPU→I/O设备</li>
</ul>
</li>
<li>主要缺点和主要优点<ul>
<li>优点<ul>
<li>与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。</li>
<li>CPU和I/O设备可并行工作，CPU利用率得到明显提升。</li>
</ul>
</li>
<li>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li>
</ul>
</li>
</ul>
</li>
<li>DMA方式（直接存储器存取，外设—内存）<ul>
<li>特点<ul>
<li><strong>数据的传送单位是“块”</strong>。不再是一个字、一个字的传送，<strong>适用于磁盘设备</strong></li>
<li><strong>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为中介</strong></li>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。<ul>
<li>CPU指明此次要进行的操作(如：读操作)，并说明要读入多少数据、数据要存放在内存的什么位置，数据在外部设备上的地址(如：在磁盘上的地址)</li>
<li>控制器会根据CPU提出的要求完成数据的读/写工作，整块数据的传输完成后，才向CPU发出中断信号</li>
</ul>
</li>
</ul>
</li>
<li>DMA控制器<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtBYcV.png" alt="pPtBYcV.png"></li>
</ul>
</li>
<li>CPU干预的频率：<strong>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</strong>。</li>
<li>数据传送的单位：每次读/写一个或多个块（注意：<strong>每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的</strong>）</li>
<li>数据的流向  (不再需要经过CPU)<ul>
<li>读操作（数据输入）：I/O设备→内存</li>
<li>写操作（数据输出）：内存→I/O设备</li>
</ul>
</li>
<li>主要缺点和主要优点<ul>
<li>优点：数据传输以“块”为单位，CPU介入频率进一步降低。<br>数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。</li>
<li>缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。<br>如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。</li>
</ul>
</li>
</ul>
</li>
<li>通道控制方式（<strong>硬件</strong>）<ul>
<li>通道是一种硬件，与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</li>
<li>完成一次读写操作的流程<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtDiuT.png" alt="pPtDiuT.png"></li>
</ul>
</li>
<li>CPU干预的频率<strong>：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预。</strong></li>
<li>数据传送的单位：每次读/写一组数据块</li>
<li>数据的流向（在通道的控制下进行）<ul>
<li>读操作（数据输入）：I/O设备→内存</li>
<li>写操作（数据输出）：内存→I/O设备</li>
</ul>
</li>
<li>主要缺点和主要优点<ul>
<li>缺点：实现复杂，需要专门的通道硬件支持</li>
<li>优点：CPU、通道、I/O设备可并行作，资源利用率很高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-I-O软件层次结构"><a href="#3-I-O软件层次结构" class="headerlink" title="3.I/O软件层次结构"></a>3.I/O软件层次结构</h4><ul>
<li>概览<ul>
<li>分为四层，越上层越接近用户，下层为上层提供服务，屏蔽实现的具体细节，越下层越接近硬件</li>
<li>中间的三层处于内核部分，称为I/O（核心子系统）系统</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtD1bD.png" alt="pPtD1bD.png"></li>
</ul>
</li>
</ul>
</li>
<li>I/O操作的流程：用户程序→系统调用处理程序→设备驱动程序→中断处理程序。</li>
<li>用户层I/O软件<ul>
<li>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作</li>
<li><strong>用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务</strong></li>
</ul>
</li>
<li>设备独立性软件<ul>
<li><strong>设备独立性软件，又称设备无关性软件</strong>。与设备的硬件特性无关的功能几乎都在这一层实现。<br><strong>处理上层的系统调用参数</strong></li>
<li>功能<ul>
<li>①向上层提供统一的调用接口(如read/write系统调用) </li>
<li>②设备的保护</li>
<li>③差错控制</li>
<li><strong>④设备的分配与回收</strong></li>
<li><strong>⑤数据缓冲区管理</strong></li>
<li>⑥<strong>建立逻辑设备名到物理设备名的映射关系；</strong><ul>
<li>根据设备类型选择调用相应的驱动程序用户或用户层软件发出I/O操作相关系统调用的系统调用时，需要指明此次要操作的I/O设备的逻辑设备名，不同类型的I/O设备需要有不同的驱动程序处理</li>
<li>设备独立性软件需要通过逻辑设备表来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</li>
</ul>
</li>
<li>管理逻辑设备表的（LUT）方式<ul>
<li>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</li>
<li>第二种方式，为每个用户设置一张ULT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。<br>系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设备驱动程序（<strong>驱动程序与操作系统无关</strong>）<ul>
<li>不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序，驱动程序一般以一个独立的进程存在</li>
<li><strong>负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write)转化成特定设备“能听得懂”的一系列操作。</strong><br><strong>包括设置设备寄存器，检查设备状态等</strong></li>
<li><strong>计算数据所在磁盘的柱面号、磁头号、扇区号</strong></li>
</ul>
</li>
<li>中断处理程序<ul>
<li><strong>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</strong></li>
</ul>
</li>
</ul>
<h4 id="4-应用程序I-O接口"><a href="#4-应用程序I-O接口" class="headerlink" title="4.应用程序I/O接口"></a>4.应用程序I/O接口</h4><ul>
<li>输入/输出应用程序接口<ul>
<li>包括：字符设备接口、块设备接口、网络设备接口(网络套接字)<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtgkb6.png" alt="pPtgkb6.png"></li>
</ul>
</li>
<li>阻塞I/O与非阻塞I/O<ul>
<li>阻塞I/O：应用程序发出I/O系统调用，进程需转为阻塞态等待。<br>如字符设备接口一一从键盘读一个字符get</li>
<li>非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待。<br>如块设备接口一一往磁盘写数据write</li>
</ul>
</li>
</ul>
</li>
<li>设备驱动程序接口（<strong>驱动程序只与厂商有关，与操作系统无关</strong>）<ul>
<li>不同的操作系统，对设备驱动程序接口的标准各不相同。</li>
<li>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用</li>
</ul>
</li>
</ul>
<h4 id="5-提高磁盘I-O速度的方法"><a href="#5-提高磁盘I-O速度的方法" class="headerlink" title="5.提高磁盘I/O速度的方法"></a>5.提高磁盘I/O速度的方法</h4><ul>
<li>提前读。在读磁盘当前块时，把下一磁盘块也读入内存缓冲区。</li>
<li>延迟写。仅在缓冲区首部设置延迟写标志，然后释放此缓冲区并将其链入空闲缓冲区链表的尾部，<br>当其他进程申请到此缓冲区时，才真正把缓冲区信息写入磁盘块。</li>
<li>虚拟盘。是指用内存空间去仿真磁盘，又叫RAM盘。虚拟盘是一种易失性存储器。虚拟盘常用于存放临时文件。</li>
</ul>
<h3 id="二-设备独立性软件（✠）"><a href="#二-设备独立性软件（✠）" class="headerlink" title="二.设备独立性软件（✠）"></a>二.设备独立性软件（✠）</h3><h4 id="1-假脱机（SPOOLing）技术"><a href="#1-假脱机（SPOOLing）技术" class="headerlink" title="1.假脱机（SPOOLing）技术"></a>1.假脱机（SPOOLing）技术</h4><ul>
<li>脱机技术<ul>
<li>在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上<br>之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾</li>
<li><strong>引入脱机技术后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；</strong><br><strong>即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带</strong>。</li>
</ul>
</li>
<li>假脱机技术（<strong>用软件的方式模拟脱机技术</strong>）<ul>
<li>输入井和输出井<ul>
<li><strong>在磁盘上开辟出两个存储区域一一“输入井”和“输出井”</strong></li>
<li>“输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据</li>
<li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</li>
</ul>
</li>
<li>输入进程和输出进程<ul>
<li><strong>要实现SPOOLing技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”</strong>。</li>
<li>输入进程模拟脱机输入时的外围控制机</li>
<li>输出进程模拟脱机输出时的外围控制机</li>
</ul>
</li>
<li>输入缓冲区和输出缓冲区<ul>
<li><strong>两个缓冲区都是在内存中的</strong></li>
<li>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中</li>
<li>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtWvLR.png" alt="pPtWvLR.png"></li>
</ul>
</li>
</ul>
</li>
<li>共享打印机<ul>
<li>独占式设备一一只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求。</li>
<li>共享设备一一允许多个进程“同时”使用的设备（宏观上同时使用，微观上可能是交替使用）可以同时满足多个进程的使用请求。</li>
<li><strong>打印机是种“独占式设备”，SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将打印机变为共享设备</strong><ul>
<li><strong>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（外存中）；</strong><br><strong>相当于分配了一个逻辑设备，使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtf3lQ.png" alt="pPtf3lQ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-设备的分配与回收"><a href="#2-设备的分配与回收" class="headerlink" title="2.设备的分配与回收"></a>2.设备的分配与回收</h4><ul>
<li><strong>设备独立性是指用户在编程序时使用的设备与实际设备无关。一个程序应独立于分配给它的某类设备的具体设备，</strong><br><strong>即在用户程序中只指明I/O使用的设备类型即可。</strong></li>
<li>设备分配时应考虑的因素<ul>
<li>设备的固有属性<ul>
<li>独占设备：一个时段只能分配给一个进程（如打印机）</li>
<li>共享设备：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li>
<li><strong>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用</strong><br><strong>(如采用SPOOLing技术实现的共享打印机)</strong></li>
</ul>
</li>
<li>设备分配算法<ul>
<li>先来先服务、优先级高者优先、短任务优先等算法</li>
</ul>
</li>
<li>设备分配中的安全性<ul>
<li>安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。(考虑进程请求打印机打印输出的例子)一个时段内每个进程只能使用一个设备<ul>
<li>优点：破坏了“请求和保持”条件，不会死锁</li>
<li>缺点：对于一个进程来说，CPU和/O设备只能串行工作</li>
</ul>
</li>
<li>不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备<ul>
<li>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进</li>
<li>缺点：有可能发生死锁（死锁避免、死锁的检测和解除)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>静态分配与动态分配<ul>
<li>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源，破坏了“请求和保持”条件，不会发生死锁</li>
<li>动态分配：进程运行过程中动态申请设备资源</li>
</ul>
</li>
<li>设备分配管理中的数据结构<ul>
<li>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</li>
<li>设备控制表(DCT)：系统为每个设备配置一张DCT，用于记录设备情况<ul>
<li><strong>设备类型（逻辑设备名）：如打印机/扫描仪/键盘</strong></li>
<li><strong>设备标识符：即物理设备名，系统中的每个设备的物理设备名唯一</strong></li>
<li>设备状态：忙碌/空闲/故障</li>
<li><strong>指向控制器表的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息</strong></li>
<li>重复执行次数或时间：当重复执行多次I/O操作后仍不成功，才认为此次I/O失败</li>
<li>设备队列的队首指针：指向正在等待该设备的进程队列(由进程PCB组成队列)<br>系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中</li>
</ul>
</li>
<li>控制器控制表(COCT)：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。<ul>
<li><strong>控制器标识符：各个控制器的唯一ID</strong></li>
<li>控制器状态：忙碌/空闲/故障</li>
<li><strong>指向通道表的指针：每个控制器由一个通道控制，该指针可找到相应通道的信息</strong></li>
<li>控制器队列的队首指针</li>
<li>控制器队列的队尾指针：指向正在等待该控制器的进程队列(由进程PCB组成队列)</li>
</ul>
</li>
<li>通道控制表(CHCT)：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理<ul>
<li>通道标识符：各个通道的唯一ID</li>
<li>通道状态：忙碌/空闲/故障</li>
<li>与通道连接的控制器表首址：可通过该指针找到该通道管理的所有控制器相关信息(COCT)</li>
<li>通道队列的队首指针</li>
<li>通道队列的队尾指针：指向正在等待该通道的进程队列(由进程PCB组成队列)</li>
</ul>
</li>
<li><strong>系统设备表(SDT)：记录了系统中全部设备的情况，每个设备对应一个表目。</strong></li>
</ul>
</li>
<li>设备分配的步骤<ul>
<li>步骤<ul>
<li>①根据进程请求的物理设备名查找SDT(注：物理设备名是进程请求分配设备时提供的参数)</li>
<li>②根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li>
<li>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ul>
</li>
<li>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</li>
<li>缺点<ul>
<li>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>②若换了一个物理设备，则程序无法运行</li>
<li>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ul>
</li>
<li><strong>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</strong></li>
</ul>
</li>
<li><p>设备分配的改进</p>
<ul>
<li><p>增加设备的独立性并考虑多通路情况</p>
<ul>
<li><p>增加设备的独立性</p>
<ul>
<li>进程使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。</li>
<li>若该设备忙，则又查找第二个该类设备的DCT。仅当所有该类设备都忙时，才把进程挂到该类设备的等待队列上</li>
<li>只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。</li>
</ul>
</li>
<li><p>考虑多通路情况</p>
<ul>
<li>为防止I/O系统的“瓶颈”现象，通常采用多通路的I/O系统结构。此时对控制器和通道的分配同样要经过几次反复，<br>即若设备（控制器）所连接的第一个控制器（通道）忙时，则应查看其所连接的第二个控制器（通道）</li>
<li>仅当所有控制器（通道）都忙时，此次的控制器（通道）分配才算失败，才把进程挂到控制器（通道）的等待队列上<br>而只要有一个控制器（通道）可用，系统便可将它分配给进程。</li>
<li>设备分配过程中，先后分别访问的数据结构为SDT→DCT→COCT→CHCT。要成功分配一个设备，必须要：<br>①设备可用；②控制器可用；③通道可用。所以，“设备分配，要过三关”。</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑设备表(LUT)：<strong>建立了逻辑设备名与物理设备名之间的映射关系</strong></p>
<ul>
<li>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</li>
<li>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</li>
<li>此时不仅可以通过物理设备名查找物理设备，还可以通过逻辑设备名访问物理设备</li>
<li>此时更改物理设备后不用修改访问改设备的应用程序</li>
</ul>
</li>
<li>设备分配的步骤<ul>
<li>①根据进程请求的逻辑设备名查找SDT(注：用户编程时提供的逻辑设备名其实就是“设备类型”)</li>
<li><strong>②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项。</strong></li>
<li>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ul>
</li>
<li>逻辑设备表的设置问题<ul>
<li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li>
<li>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-高速缓存与缓冲区"><a href="#3-高速缓存与缓冲区" class="headerlink" title="3.高速缓存与缓冲区"></a>3.高速缓存与缓冲区</h4><ul>
<li><p>高速缓存</p>
<ul>
<li>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度<br>利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中</li>
<li><strong>磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</strong></li>
<li>高速缓存在内存中分为两种形式<ul>
<li>一种是在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定</li>
<li>另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O时共享。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲区的定义</p>
<ul>
<li>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</li>
<li>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合；<br>如存储器管理中所用的联想寄存器（快表），由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本</li>
<li>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</li>
</ul>
</li>
<li>缓冲区的作用<ul>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾<ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtI6gO.png" alt="pPtI6gO.png"></li>
</ul>
</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制<ul>
<li>如果是字符型设备则每输出完一个字符就要向CPU发送一次中断信号</li>
</ul>
</li>
<li>解决数据粒度不匹配的问题<ul>
<li>输出进程每次可以生成一块数据但I/O设备每次只能输出一个字符</li>
</ul>
</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ul>
</li>
<li>单缓冲<ul>
<li>操作系统会在主存中为其分配一个缓冲区，用户进程的内存空间中，会分出一片工作区来接受输入/输出数据（一般也默认工作区大小与缓冲区相同）</li>
<li>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；</li>
<li>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</li>
<li><strong>分析问题的初始状态：工作区满；缓冲区空处理一块数据的平均耗时时间：Max(C,T)+M</strong><ul>
<li><img src="https://s1.ax1x.com/2023/08/25/pPtHKzV.png" alt="pPtHKzV.png"></li>
</ul>
</li>
</ul>
</li>
<li>双缓冲<ul>
<li><strong>分析问题的初始状态：工作区空，一个缓冲区满，另一个缓冲区空；处理一块数据平均耗时Max(T,C+M)</strong></li>
</ul>
</li>
<li>单缓冲与双缓冲的区别<ul>
<li>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受。</li>
<li>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</li>
<li>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。</li>
</ul>
</li>
<li>例题<ul>
<li>例1<ul>
<li>选B<img src="https://s1.ax1x.com/2023/08/25/pPN9BOs.png" alt="pPN9BOs.png"></li>
<li><img src="https://s1.ax1x.com/2023/08/25/pPN9ckV.png" alt="pPN9ckV.png"></li>
</ul>
</li>
<li>例2<ul>
<li>选C<img src="https://s1.ax1x.com/2023/08/25/pPN9fl4.png" alt="pPN9fl4.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三-磁盘与固态硬盘（✪）"><a href="#三-磁盘与固态硬盘（✪）" class="headerlink" title="三.磁盘与固态硬盘（✪）"></a>三.磁盘与固态硬盘（✪）</h3><h4 id="1-磁盘的结构"><a href="#1-磁盘的结构" class="headerlink" title="1.磁盘的结构"></a>1.磁盘的结构</h4><ul>
<li>磁盘、磁道、扇区的概念<ul>
<li>磁盘由表面涂有磁性物质的圆形盘片组成</li>
<li>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区</li>
<li>每个扇区就是一个磁盘块”。各个扇区存放的数据量相同(如1KB)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPN3pHx.png" alt="pPN3pHx.png"></li>
</ul>
</li>
</ul>
</li>
<li>如何在磁盘中读/写数据<ul>
<li>磁头移动到目标位置，盘片旋转，对应扇区划过磁道才能完成读/写（机械操作）</li>
<li>存储一个文件时，当一个磁道存储不下时，选择同一个柱面的不同盘面进行存储，此时可以避免磁臂移动，减少了处理时间</li>
</ul>
</li>
<li>盘面、柱面的概念<ul>
<li>磁盘有多个盘片“摞”起来，每个盘片有两个盘面</li>
<li>所有盘面中相对位置相同的磁道组成柱面</li>
</ul>
</li>
<li>磁盘的物理地址<ul>
<li><strong>可用(柱面号，盘面号，扇区号)来定位任意一个“磁盘块”。</strong></li>
<li>①根据“柱面号”移动磁臂，让磁头指向指定柱面</li>
<li>②激活指定盘面对应的磁头；</li>
<li>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNutDf.png" alt="pPNutDf.png"></li>
</ul>
</li>
</ul>
</li>
<li>磁盘的分类<ul>
<li>根据磁头是否可移动<ul>
<li>固定头磁盘（每个磁道有一个磁头，则一个盘面有多个磁头）</li>
<li>移动头磁盘（每个盘面只有一个磁头）</li>
</ul>
</li>
<li>根据盘片是否可更换：固定盘磁盘可换盘磁盘</li>
</ul>
</li>
<li>簇/块：操作系统限制的存储空间分配基本单位<br>簇：windows系统的说法；块：Linux、Uniⅸ系统的说法<ul>
<li>本题需为簇的整数倍，选2048B<img src="https://s1.ax1x.com/2023/08/26/pPNDsk4.png" alt="pPNDsk4.png"></li>
</ul>
</li>
</ul>
<h4 id="2-磁盘的管理"><a href="#2-磁盘的管理" class="headerlink" title="2.磁盘的管理"></a>2.磁盘的管理</h4><ul>
<li>磁盘初始化<ul>
<li>Step1：进行低级格式化（物理格式化）：将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。<ul>
<li>管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码，如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误</li>
</ul>
</li>
<li>Step2：将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）</li>
<li>Step3：进行逻辑格式化（高级格式化），创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）、产生引导扇区</li>
</ul>
</li>
<li>引导块<ul>
<li>计算机启动时需要运行初始化程序（自举程序）来完成初始化</li>
<li>ROM中存放很小的自举装入程序，ROM(只读存储器）中的数据在出厂时就写入了，并且以后不能再修改</li>
<li>完整的自举程序存放在初始块（引导块/启动分区）上，启动分区位于磁盘的固定位置，拥有启动分区的磁盘为系统磁盘或启动磁盘</li>
<li>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</li>
</ul>
</li>
<li>坏块管理<ul>
<li>简单的磁盘：逻辑格式化时对整个磁盘进行坏块检查，将坏块标记出来；<br>如在FAT表上标明。（在这种方式中，坏块对操作系统不透明）</li>
<li>复杂的磁盘：磁盘控制器维护一个坏块链，在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化<br>并会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</li>
</ul>
</li>
</ul>
<h4 id="3-磁盘调度算法（♚）"><a href="#3-磁盘调度算法（♚）" class="headerlink" title="3.磁盘调度算法（♚）"></a>3.磁盘调度算法（♚）</h4><ul>
<li>一次读/写操作需要的时间<ul>
<li>寻道（找）时间${\mathrm{T}_{\mathrm{S}}}$: 在读/写数据前, <strong>将磁头移动到指定磁道所花的时间</strong>。<ul>
<li>启动磁头臂是需要时间的。假设耗时为${s}$;</li>
<li><strong>移动磁头也是需要时间的。假设磁头匀速移动, 每跨越一 个磁道耗时为${m}$, 总共需要跨越${n}$条磁道。则:</strong><br><strong>寻道时间${T_{s}=s+m * n}$</strong></li>
<li>现在的硬盘移动一个磁道大约需要0.2ms,磁臂启动时间约为2ms</li>
<li>寻道时间在所有时间中，寻道时间需要移动磁臂，所占用的时间最长</li>
</ul>
</li>
<li>延迟时间${\mathrm{T}_{\mathrm{R}}}$: 通过旋转磁盘, <strong>使磁头定位到目标扇区所需要的时间</strong>。<ul>
<li><strong>设磁盘转速为${r}$(单位: 转/秒, 或转/分), 则平均所需的延迟时间${T_{R}=(1 / 2) *(1 / r)=1 / 2 r}$</strong></li>
<li>1/r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1/2</li>
<li>硬盘的典型转速为5400转/分，或7200转/分</li>
</ul>
</li>
<li>传输时间${\mathrm{T}_{\mathrm{t}}}$: <strong>从磁盘读出或向磁盘写入数据所经历的时间</strong><ul>
<li><strong>设磁盘转速为${r}$，此次读/写的字节数为${b}$，每个磁道上的字节数为${\mathrm{N}}$。则传输时间${T_{t}=(1 / r) *(b / N)=b /(r N)}$</strong></li>
<li>每个磁道要可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储。而读/写一个磁道所需的时间刚好又是转一圈所需要的时间1/r</li>
</ul>
</li>
<li>注意事项<ul>
<li><strong>寻道时间主要受磁盘调度算法的影响</strong></li>
<li><strong>延迟时间受到磁盘空闲空间分配程序以及文件的物理结构的影响</strong></li>
<li><strong>扇区数据的处理时间对旋转延迟有影响但是影响不大。</strong></li>
</ul>
</li>
</ul>
</li>
<li>磁盘调度算法（最优化传输时间）<ul>
<li>先来先服务(FCFS)<ul>
<li>根据进程请求访问磁盘的先后顺序进行调度。</li>
<li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li>
<li>缺点：如果有大量进程竞争使用磁盘，请求访问的破道很分散，则FCFS在性能上很差，寻道时间长。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNQCE8.png" alt="pPNQCE8.png"></li>
</ul>
</li>
</ul>
</li>
<li>最短寻找时间优先(SSTF)<ul>
<li>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</li>
<li>优点：性能较好，平均寻道时间短</li>
<li>缺点：<strong>可能产生“饥饿”现象</strong>，磁头有可能在一个小区域内来回来去地移动</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNQNb6.png" alt="pPNQNb6.png"></li>
</ul>
</li>
</ul>
</li>
<li>扫描算法(SCAN)<ul>
<li>解决饥饿问题：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法(SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫<strong>电梯算法</strong>。（<strong>移动时，只有到了最边上的磁道才能改变磁头移动方向</strong>）</li>
<li><strong>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</strong></li>
<li>缺点<ul>
<li><strong>①只有到达最边上的磁道时才能改变磁头移动方向；</strong><br><strong>事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</strong></li>
<li><strong>②SCAN算法对于各个位置磁道的响应频率不平均</strong></li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNlkdK.png" alt="pPNlkdK.png"></li>
</ul>
</li>
</ul>
</li>
<li>LOOK调度算法<ul>
<li><strong>还是要向一个边上移动，但是不用移动到底</strong>，如果在磁头移动方向上已经<strong>没有别的请求，就可以立即改变磁头移动方向</strong>。(边移动边观察，因此叫LOOK)，解决扫描算法非要移动到最边上的问题</li>
<li>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>
<li>缺点：未解决响应不均衡的问题</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNl2l9.png" alt="pPNl2l9.png"></li>
</ul>
</li>
</ul>
</li>
<li>C-SCAN算法<ul>
<li>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时<strong>直接快速移动至起始端</strong>而不处理任何请求。<br>解决对于各个位置磁道的响应频率不平均</li>
<li>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</li>
<li>缺点：只有到达最边上的磁道时才能改变磁头移动方向，另外，比起SCAN算法来，平均寻道时间更长。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNl5TK.png" alt="pPNl5TK.png"></li>
</ul>
</li>
</ul>
</li>
<li>C-LOOK算法<ul>
<li>如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，磁头只需要返回到<strong>最靠近边缘的并且需要访问的磁道上即可</strong></li>
<li>优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNlbSH.png" alt="pPNlbSH.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>减少延迟时间的方法<ul>
<li>关于延迟时间的产生<ul>
<li><strong>假设要连续读取几个相邻扇区：磁头读取一块的内容后，需要一小段时间处理，而盘片又在不停地旋转</strong><br>因此，如果扇区相邻着排列，则读完1号扇区后无法连续不断地读入2号扇区，必须等盘片继续旋转，2号扇区再次划过磁头，才能完成扇区读入</li>
<li>结论：<strong>磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的延迟时间</strong></li>
</ul>
</li>
<li>磁盘地址结构的设计<ul>
<li>为什么？磁盘的物理地址是(柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)</li>
<li>答：读取地址连续的磁盘块时，采用（柱面号盘面号，扇区号）的地址结构可以<strong>减少磁头移动消耗的时间</strong></li>
</ul>
</li>
<li>两种方法（使<strong>读取连续的逻辑扇区</strong>所需要的延迟时间更小）<ul>
<li>交替编号：让编号相邻的扇区在物理上不相邻</li>
<li>错位命名：让相邻盘面的扇区编号“错位”</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNJSDs.png" alt="pPNJSDs.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p>例1</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNDMOf.png" alt="pPNDMOf.png"></li>
</ul>
</li>
<li><p>例2</p>
<ul>
<li>此时转1圈需要60/3000秒，每个扇区的时间再除以10，选C<br><img src="https://s1.ax1x.com/2023/08/26/pPNDGkQ.png" alt="pPNDGkQ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-固态磁盘（SSD）"><a href="#4-固态磁盘（SSD）" class="headerlink" title="4.固态磁盘（SSD）"></a>4.固态磁盘（SSD）</h4><ul>
<li>原理：基于闪存技术Flash Memory，属于电可擦除ROM，即EEPROM</li>
<li>组成<ul>
<li>闪存翻译层：负责翻译逻辑块号，找到对应页(Page)</li>
<li>存储介质：包含多个闪存芯片(Flash Chip)，每个芯片包含多个块(block)，每个块包含多个页(page)</li>
</ul>
</li>
<li>读写性能特征<ul>
<li><strong>以页(page)为单位读/写：相当于磁盘的”扇区”</strong></li>
<li><strong>以块(bock)为单位”擦除”：擦干净的块，其中的每页都可以写一次，读无限次</strong></li>
<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li>
<li><strong>读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页</strong></li>
</ul>
</li>
<li>与机械硬盘相比的特点<ul>
<li>SSD读写速度快，<strong>随机访问性能高</strong>，用电路控制访问位置；<br>机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li>
<li>SSD安静无噪音、耐摔抗震、能耗低、造价更贵</li>
<li><strong>SSD的一个”块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</strong></li>
</ul>
</li>
<li>磨损均衡技术<ul>
<li>思想：将“擦除”平均分布在各个块上，以提升使用寿命</li>
<li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块</li>
<li>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务（<strong>更优秀</strong>）</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/26/pPNM9fJ.png" alt="pPNM9fJ.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第四章-文件管理</title>
    <url>/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="操作系统第四章-文件管理"><a href="#操作系统第四章-文件管理" class="headerlink" title="操作系统第四章 文件管理"></a>操作系统第四章 文件管理</h2><blockquote>
<p>计算机学科基础：操作系统第四章文件管理的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-文件系统基础（✪）"><a href="#一-文件系统基础（✪）" class="headerlink" title="一.文件系统基础（✪）"></a>一.文件系统基础（✪）</h3><h4 id="1-文件控制块（FCB）和索引结点"><a href="#1-文件控制块（FCB）和索引结点" class="headerlink" title="1.文件控制块（FCB）和索引结点"></a>1.文件控制块（FCB）和索引结点</h4><ul>
<li><p>文件的概念：以硬盘为载体的存储在计算机上的信息集合</p>
</li>
<li><p>FCB（目录项）</p>
<ul>
<li><p>定义：一个文件对应一个FCB，一个FCB就是一个目录项；文件系统在创建文件时，建立一个文件目录项；多个FCB组成文件目录</p>
</li>
<li><p>FCB的组成</p>
<ul>
<li>文件的基本信息（文件名、物理地址、逻辑结构、物理结构等）<ul>
<li>FCB实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取“</li>
</ul>
</li>
<li>存取控制信息（是否可读/可写、禁止访问的用户名单等）</li>
<li>使用信息(如文件的建立时间、修改时间等)</li>
</ul>
</li>
</ul>
</li>
<li><p>索引结点（FCB的瘦身策略，iNode）</p>
<ul>
<li><strong>除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点，简称i结点</strong><br><strong>目录项中只包含文件名、索引结点指针，因此每个目录项的长度大幅减小</strong></li>
<li><strong>由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I/O的次数就少了很多</strong></li>
<li><strong>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</strong></li>
<li><strong>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存/活动索引结点”</strong><br>相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件</li>
<li>文件的打开过程描述<ul>
<li>①检索目录，要求打开的文件应该是已经创建的文件，它应登记在文件目录中，否则会出错。<br>在检索到指定文件后，就将其磁盘Node复制到活动iNode表中。</li>
<li>②把参数mode所给出的打开方式与活动iNode中在创建文件时所记录的文件访问权限相比较，如果合法，则此次打开操作成功。</li>
<li>③当打开合法时，为文件分配用户打开文件表表项和系统打开文件表表项，并为后者设置初值，<br>通过指针建立表项与活动Node之间的联系，再把文件描述符fd返回给调用者。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYZtTs.png" alt="pPYZtTs.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-目录的结构（一种特殊的文件）"><a href="#2-目录的结构（一种特殊的文件）" class="headerlink" title="2.目录的结构（一种特殊的文件）"></a>2.目录的结构（一种特殊的文件）</h4><ul>
<li>单级目录结构：一个系统只有一张目录表，<strong>不允许文件重名</strong></li>
<li>两级目录结构<ul>
<li>分为主文件目录和用户文件目录<ul>
<li>主文件目录记录用户名及相应用户文件目录的存放位置</li>
<li>用户文件目录由该用户的文件FCB组成</li>
</ul>
</li>
<li><strong>不同用户的文件可以重名，但不能对文件进行分类</strong></li>
</ul>
</li>
<li>树形目录结构<ul>
<li><strong>不同目录下的文件可以重名，可以对文件进行分类，不方便文件共享</strong></li>
<li>系统根据”文件路径”找到目标文件</li>
<li>从根目录出发的路径是“绝对路径”，<br>从”当前目录出发的路径是相对路径”，可以减少磁盘I/O次数</li>
</ul>
</li>
<li>无环图目录结构<ul>
<li>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图<br><strong>可以更方便地实现多个用户间的文件共享</strong>。</li>
<li>为共享结点设置一个共享计数器，计数器为0时才真正删除该结点</li>
<li>共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJ7FHA.png" alt="pPJ7FHA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-文件的逻辑结构"><a href="#3-文件的逻辑结构" class="headerlink" title="3.文件的逻辑结构"></a>3.文件的逻辑结构</h4><ul>
<li>逻辑结构：在用户看来文件内部的数据应该是如何组织起来的。</li>
<li>无结构文件（流式文件）<ul>
<li>文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如：Windows操作系统中的txt文件</li>
</ul>
</li>
<li>有结构文件（记录式文件）<ul>
<li>定义<ul>
<li>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：数据库表文件。</li>
<li><strong>一般来说，每条记录有一个数据项可作为关键字</strong>。</li>
<li>根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。</li>
</ul>
</li>
<li>分类（逻辑上如何组织）<ul>
<li>顺序文件<ul>
<li>定义：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。<strong>各个记录在物理上可以顺序存储或链式存储。</strong></li>
<li>两种结构<ul>
<li>串结构：记录之间的顺序与关键字无关</li>
<li>顺序结构：记录之间的顺序按关键字顺序排列</li>
</ul>
</li>
<li><strong>可变长记录的顺序文件无法实现随机存取，定长记录的顺序存储方式可以</strong></li>
<li><strong>定长记录、顺序结构的顺序文件可以快速检索（根据关键字快速找到记录）</strong></li>
<li>最大缺点：不方便增加/删除记录</li>
</ul>
</li>
<li>索引文件<ul>
<li>建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加/删除记录</li>
<li>索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，<strong>因此索引文件可支持随机存取</strong></li>
<li><strong>若索引表按关键字顺序排列，则可支持快速检索</strong></li>
<li><strong>解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取。但索引表可能占用很多空间</strong></li>
</ul>
</li>
<li>索引顺序文件<ul>
<li>将记录分组，每组对应一个索引表项</li>
<li>检索记录时先顺序查索引表，找到分组，再顺序查找分组</li>
<li>当记录过多时，可建立多级索引表</li>
<li><strong>当只有一级索引号时，对于n个记录最好的分组记录为：$分为\sqrt{n}组,每组\sqrt{n}个记录$，此时平均查询次数为$\sqrt{n}/2*2$</strong><ul>
<li>若要为N个记录的文件建立K级索引，则最优的分组是每组$N^{\frac{1}{K+1}}$个记录（一般）采用一级索引即可k=1</li>
<li>检索一个记录的平均查找次数是$N^{\frac{1}{K+1}}/2*(K+1)$</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJzaJH.png" alt="pPJzaJH.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>例题<ul>
<li>本题可以看做是只有一张索引表，此时的查找记录最少时为$\sqrt{10000}/2*2=100$，此时为D<br><img src="https://s1.ax1x.com/2023/08/23/pPYUNWT.png" alt="pPYUNWT.png"></li>
</ul>
</li>
</ul>
<h4 id="4-文件的物理结构（♚）"><a href="#4-文件的物理结构（♚）" class="headerlink" title="4.文件的物理结构（♚）"></a>4.文件的物理结构（♚）</h4><ul>
<li><p>磁盘块</p>
<ul>
<li>在内存管理中，进程的逻辑地址空间被分为一个一个页面，在外存管理中，文件的逻辑地址空间也被分为了一个一个的文件“块”<br>很多操作系统中，磁盘块的大小与内存块、页面的大小相同</li>
<li>内存与磁盘之间的数据交换（即读/写操作、磁盘I/O)都是以块”为单位进行的。即每次读入一块，或每次写出一块</li>
<li>文件的逻辑地址也可以表示为(逻辑块号，块内地址)的形式。</li>
<li>操作系统为文件分配存储空间都是以块为单位的，用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射</li>
</ul>
</li>
<li><p>文件的分配方式（<strong>对非空闲磁盘块的管理，实现逻辑地址到物理地址的映射</strong>）</p>
<ul>
<li>连续分配<ul>
<li><strong>连续分配方式要求每个文件在磁盘上占有一组连续的块。</strong></li>
<li><strong>文件目录中记录存放的起始块号和长度（总共占用几个块）</strong><ul>
<li>给出要访问的逻辑块号，操作系统找到该文件对应的目录项(FCB)，物理块号=起始块号+逻辑块号</li>
<li>只需转换块号就行，块内地址保持不变，此时可实现到物理块号的映射</li>
</ul>
</li>
<li><strong>连续分配支持顺序访问和直接访问（即随机访问）</strong><ul>
<li>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</li>
<li>连续分配的文件在顺序读/写时速度最快</li>
</ul>
</li>
<li><strong>缺点：不方便文件拓展：存储空间利用率低，会产生磁盘碎片</strong><br>可以用紧凑来处理碎片，但是需要耗费很大的时间代价。</li>
</ul>
</li>
<li>链接分配（离散分配）<ul>
<li>隐式链接<ul>
<li><strong>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</strong></li>
<li><strong>目录中记录了文件存放的起始块号和结束块号</strong>。也可以增加一个字段来表示文件的长度<ul>
<li>操作系统找到该文件对应的目录项(FCB)，从目录项中找到起始块号(即0号块)，将0号逻辑块读入内存，<br>由此知道1号逻辑块存放的物理块号，以此类推，读入i号逻辑块总共需要$i+1$次磁盘I/O</li>
</ul>
</li>
<li>优点：<strong>很方便文件拓展，不会有碎片问题，外存利用率高</strong>。<ul>
<li>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</li>
</ul>
</li>
<li>缺点：<strong>只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJbo1f.png" alt="pPJbo1f.png"></li>
</ul>
</li>
</ul>
</li>
<li>显式链接<ul>
<li><strong>目录中只需记录文件的起始块号，把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT）</strong><ul>
<li>FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的</li>
<li><strong>逻辑块号转换成物理块号的过程不需要读磁盘操作</strong><ul>
<li>用户给出要访问的逻辑块号ⅰ，操作系统找到该文件对应的目录项 (FCB)，从目录项中找到起始块号，<br>之后查询内存中的文件分配表FAT，往后找到ⅰ号逻辑块对应的物理块号。</li>
</ul>
</li>
</ul>
</li>
<li><strong>一个磁盘仅设置一张FAT，开机时，将FAT读入内存，并常驻内存</strong>。</li>
<li>FAT不仅记录了文件中各个块的先后链接顺序，同时还标记了空闲的磁盘块，操作系统可以通过FAT对文件空闲存储空间实现管理</li>
<li>优点<ul>
<li><strong>采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问</strong></li>
<li><strong>由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</strong>。</li>
<li><strong>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展，外存利用率高</strong></li>
</ul>
</li>
<li>缺点：文件分配表的需要占用一定的存储空间</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJqxVH.png" alt="pPJqxVH.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>索引分配（离散分配）<ul>
<li>索引表<ul>
<li><strong>系统会为每个文件建立一张索引表，一张索引表的每个索引表项记录了文件的各个逻辑块对应的物理块，索引表中的“逻辑块号”可以是隐含的。</strong></li>
<li><strong>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块；目录需要记录文件名和其对应的索引块</strong></li>
<li><strong>索引表的功能类似于内存管理中的页表：建立逻辑页面到物理页之间的映射关系</strong><ul>
<li>用户给出要访问的逻辑块号ⅰ，操作系统找到该文件对应的目录项(FCB)，从目录项中可知索引表存放位置，<strong>将索引表从外存读入内存，并查找索引表即可知道ⅰ号逻辑块在外存中的存放位置</strong></li>
</ul>
</li>
<li>优点：<strong>索引分配方式可以支持随机访问，文件拓展也很容易实现</strong>，需要给文件分配一个空闲块，并增加一个索引表项</li>
<li>缺点：但是索引表需要占用一定的存储空间</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJOFYR.png" alt="pPJOFYR.png"></li>
</ul>
</li>
</ul>
</li>
<li>解决由于文件太大导致，一个磁盘块装不下此文件索引表的问题<ul>
<li>链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放，需要很多的I/O操作，太低效</li>
<li>多层索引<ul>
<li>原理类似于多级页表，使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</li>
<li>若采用多层索引，则各层索引表大小不能超过一个磁盘块</li>
<li><strong>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</strong></li>
<li><strong>文件的最大长度：$最多存放索引项个数^{k}*磁盘块大小$</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJx3VS.png" alt="pPJx3VS.png"></li>
</ul>
</li>
<li>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘。</li>
</ul>
</li>
<li>混合索引<ul>
<li>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）</li>
<li>对于小文件，只需较少的读磁盘次数就可以访问目标数据块（一般计算机中小文件更多）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJxDVU.png" alt="pPJxDVU.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三种外存分配方式的区别</p>
<ul>
<li>连续分配：需访问磁盘1次</li>
<li>链接分配：需访问磁盘n次</li>
<li>索引分配：m级需访问磁盘m+1次</li>
<li><img src="https://s1.ax1x.com/2023/08/23/pPJxoIe.png" alt="pPJxoIe.png"></li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li>例1：此时最大长度直接套公式计算：1KB/4=$2^8$个项，此时最大长度为${2^{8<em>2}}$</em>1KB=64MB<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYaeB9.png" alt="pPYaeB9.png"></li>
</ul>
</li>
<li>例2：若此题的磁盘块没有读入内存，还需要分别加1(读入索引结点)，此时选D<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYahCV.png" alt="pPYahCV.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-文件的操作"><a href="#5-文件的操作" class="headerlink" title="5.文件的操作"></a>5.文件的操作</h4><ul>
<li><p>文件描述符（即索引号）</p>
<ul>
<li><strong>打开文件时，将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户进程</strong><br><strong>“索引号”也称“文件描述符”</strong></li>
<li><strong>打开文件时并不会把文件数据直接读入内存，读数据时才需要读入内存，写数据时需要写出外存。</strong></li>
<li><strong>读/写文件时用“文件描述符”即可指明文件，不再需要用到文件名</strong></li>
</ul>
</li>
<li><p>创建文件(create系统调用)</p>
<ul>
<li>分配外存空间<ul>
<li>利用空闲链表法、位示图、成组链接法等管理策略，在外存中找到空闲空间</li>
</ul>
</li>
<li>在目录中创建目录项<ul>
<li>目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ul>
</li>
</ul>
</li>
<li>删除文件(delete系统调用)<ul>
<li>回收外存空间<ul>
<li>回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理</li>
</ul>
</li>
<li>从目录表中删除文件对应的目录项</li>
</ul>
</li>
<li>打开文件(open系统调用)<ul>
<li>过程<ul>
<li>从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</li>
<li><strong>将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户</strong><ul>
<li>打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”</li>
</ul>
</li>
<li><strong>打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作</strong></li>
<li>每个进程有自己的打开文件表，系统中也有一张总的打开文件表<ul>
<li>进程打开文件表中特有的属性：读写指针、访问权限(只读？读写？)</li>
<li>系统打开文件表中特有的属性：打开计数器（有多少个进程打开了该文件）</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYkxeA.png" alt="pPYkxeA.png"></li>
</ul>
</li>
</ul>
</li>
<li>关于打开文件表（注意用户打开文件表的读写指针和访问权限以及系统打开文件表的打开计数器）<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYAPW8.png" alt="pPYAPW8.png"></li>
</ul>
</li>
</ul>
</li>
<li>关闭文件(close系统调用)<ul>
<li>将用户进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count减1，若count=0，则删除对应表项。</li>
</ul>
</li>
<li>读文件(read系统调用)<ul>
<li><strong>根据读指针、读入数据量、内存位置等信息将文件数据从外存读入内存</strong></li>
<li>将文件数据读入内存，才能让CPU处理，双击后，应用程序通过read系统调用，将文件数据从外存读入内存，并显示在屏幕上（必须要打开文件之后）</li>
<li><strong>读/写文件“文件描述符”即可指明文件不再需要用到“文件名</strong></li>
</ul>
</li>
<li>写文件(write系统调用)<ul>
<li>根据写指针、写出数据量、内存位置将文件数据从内存写出外存</li>
<li>点击“保存”后，应用程序通过write系统调用，将文件数据从内存写回外存</li>
</ul>
</li>
</ul>
<h4 id="6-文件的保护"><a href="#6-文件的保护" class="headerlink" title="6.文件的保护"></a>6.文件的保护</h4><ul>
<li><p>口令保护</p>
<ul>
<li>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确</li>
<li>实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全</li>
</ul>
</li>
<li><p>加密保护</p>
<ul>
<li>用一个“密码”对文件加密，用户想要访问文件时，需要提供相同的“密码”才能正确的解密</li>
<li>安全性高，但加密/解密需要耗费一定的时间 (如异或加密)</li>
</ul>
</li>
<li>访问控制<ul>
<li>在每个文件的FCB（或索引结点）中增加一个访问控制表(ACL)，记录各个用户（或各组用户）对文件的访问权限<br>对文件的访问类型可以分为：读/写/执行/删除等</li>
<li>精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作，系统需要管理分组的信息<ul>
<li>如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</li>
<li>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</li>
<li>若想要让某个用户能够读取文件，只需要把该用户放入文件主的伙伴这个分组即可</li>
</ul>
</li>
<li>实现灵活，可以实现复杂的文件保护功能</li>
</ul>
</li>
</ul>
<h4 id="7-文件共享"><a href="#7-文件共享" class="headerlink" title="7.文件共享"></a>7.文件共享</h4><ul>
<li><p>文件共享与文件复制的区别</p>
<ul>
<li>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</li>
<li>多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</li>
<li>如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</li>
</ul>
</li>
<li><p><strong>基于索引结点的共享方式（硬链接）</strong></p>
<ul>
<li>各个用户的目录项指向同一个索引结点，索引结点中需要有链接计数count，用于表示链接到本索引结点上的用户目录项数<br>若cout=2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件</li>
<li>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1.<ul>
<li>若cout&gt;0,说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li>
<li>当count=0时系统负责删除文件。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYe7vT.png" alt="pPYe7vT.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>基于符号链的共享方式（软链接）</strong><ul>
<li><strong>在一个Link型的文件中记录共享文件的存放路径(Windows快捷方式)</strong></li>
<li>操作系统根据路径一层层查找目录，最终找到共享文件即使软链接指向的共享文件已被删除，Link型文件依然存在，<br>只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</li>
<li><strong>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软链接访问共享文件的速度要比硬链接更慢</strong></li>
</ul>
</li>
<li>例题<ul>
<li>例1：此时新创建硬链接的文件的索引节点指向F1的索引结点，删除F1后其技术值变为1，软链接的计数值不变，即选B<br><img src="https://s1.ax1x.com/2023/08/23/pPYwWlT.png" alt="pPYwWlT.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二-文件系统（✪）"><a href="#二-文件系统（✪）" class="headerlink" title="二.文件系统（✪）"></a>二.文件系统（✪）</h3><h4 id="1-文件系统布局"><a href="#1-文件系统布局" class="headerlink" title="1.文件系统布局"></a>1.文件系统布局</h4><ul>
<li>文件系统的概述<ul>
<li><strong>操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统</strong></li>
<li>文件系统由三部分组成：与文件管理有关的软件、被管理文件及实施文件管理所需的数据结构。</li>
<li>文件系统的功能<ul>
<li>对于用户而言，文件系统最主要的功能是实现对文件的基本操作，<br><strong>让用户可以按名存储和查找文件</strong>，组织成合适的结构，并应当具有基本的文件共享和文件保护功能。</li>
<li>从系统角度看，文件系统负责对文件的存储空间进行组织、分配；负责文件的存储并对存入文件进行保护、检索。</li>
</ul>
</li>
</ul>
</li>
<li>文件系统在磁盘中的结构<ul>
<li>磁盘的物理格式化：即低级格式化，划分扇区，检测坏扇区，并用备用扇区替换坏扇区</li>
<li>磁盘的逻辑格式化：磁盘分区(分卷Volume)后，对各分区进行逻辑格式化，完成文件系统初始化</li>
<li>文件系统在磁盘中的组成<ul>
<li>主引导记录(MBR)<ul>
<li>位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。</li>
<li>表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR，MBR做的第一件事是确定活动分区，读<br>入它的第一块，即引导块。</li>
</ul>
</li>
<li>引导块<ul>
<li><strong>MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统</strong>。为统一起见，每个分区都从一个引导块开始。Windows系统称之为分区引导扇区。</li>
</ul>
</li>
<li>超级块<ul>
<li><strong>包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存</strong>。</li>
<li>超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。</li>
</ul>
</li>
<li>其它组成<ul>
<li>文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出。</li>
<li>后面也许跟的是一组i结点，每个文件对应一个结点，ⅰ结点说明了文件的方方面面。</li>
<li>接着可能是根目录，它存放文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/24/pPYhUy9.png" alt="pPYhUy9.png"></li>
</ul>
</li>
</ul>
</li>
<li>文件系统在内存中的结构<ul>
<li>近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/24/pPY58v4.png" alt="pPY58v4.png"></li>
</ul>
</li>
</ul>
</li>
<li>文件系统的层次结构（了解）<ul>
<li><img src="https://s21.ax1x.com/2024/08/12/pApQybF.png" alt="pApQybF.png"></li>
</ul>
</li>
</ul>
<h4 id="2-外存空闲空间管理（♚）"><a href="#2-外存空闲空间管理（♚）" class="headerlink" title="2.外存空闲空间管理（♚）"></a>2.外存空闲空间管理（♚）</h4><ul>
<li><p>存储空间的划分与初始化</p>
<ul>
<li>包含文件系统的物理磁盘分区被称为卷（逻辑卷、逻辑盘）C盘、D盘……</li>
<li>存储空间的初始化：将各个文件卷划分为目录区、文件区<ul>
<li>目录区主要存放文件目录信息(FCB)、用于磁盘存储空间管理的信息</li>
<li>文件区用于存放文件数据</li>
</ul>
</li>
<li>有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷</li>
</ul>
</li>
<li><p>存储空间管理（对空闲块的组织、分配与回收）</p>
<ul>
<li><p>空闲表法（连续分配方式）</p>
<ul>
<li>与内存的动态分配相似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲表<br>每个空闲区对应一个空闲表项，包括表项序号，空闲区的第一个盘块号，空闲盘块数，再以起始盘块号递增的次序排列</li>
<li>分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间，同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</li>
<li>回收磁盘块：与内存管理中的动态分区分配很类似，回收时需要注意表项的合并问题。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYiJeI.png" alt="pPYiJeI.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>空闲链表法</p>
<ul>
<li>空闲盘块链（适用于离散分配）<ul>
<li>以盘块为单位组成一条空闲链，空闲盘块中存储着下一个空闲盘块的指针<br>操作系统保存着链头、链尾指针。</li>
<li>分配磁盘块：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li>
<li>回收磁盘块：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li>
<li>为文件分配多个盘块时可能要重复多次操作</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYi6wq.png" alt="pPYi6wq.png"></li>
</ul>
</li>
</ul>
</li>
<li>空闲盘区链（离散分配、连续分配都适用）<ul>
<li>以盘区为单位组成一条空闲链；连续的空闲盘块组成一个空闲盘区；空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针；操作系统保存着链头、链尾指针。</li>
<li>分配磁盘块<ul>
<li>若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索按照算法规则找到一个大小符合要求的空闲盘区，分配给文件</li>
<li>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据</li>
</ul>
</li>
<li>回收磁盘块<ul>
<li>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。</li>
<li>若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li>
</ul>
</li>
<li>为个文件分配多个盘块时效率更高</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYdrPx.png" alt="pPYdrPx.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>位示图法（离散分配、连续分配都适用）</p>
<ul>
<li><p>位示图</p>
<ul>
<li><p>每个二进制位对应一个盘块。“0”代表盘块空闲，“1”代表盘块已分配。</p>
</li>
<li><p>位示图一般用连续的“字”来表示，字的字长是16位，字中的每一位对应一个盘块。<br>因此可以用（字号，位号）对应一个盘块号。</p>
</li>
<li><p>计算方法</p>
<ul>
<li><p><strong>位示图法中行和列都从1开始编号</strong></p>
<ul>
<li>(字号，位号)=(i，j) 的二进制位对应的盘块号：$b=n(i-1)+j$</li>
<li>b号盘块对应的字号：$i=(b-1)/n +1$，位号：$j=(b-1)\%n+1$</li>
</ul>
</li>
<li><p><strong>位示图法中行和列都从0开始编号</strong></p>
<ul>
<li><p>(字号，位号)=(i，j) 的二进制位对应的盘块号：$b=ni+j$</p>
</li>
<li><p>b号盘块对应的字号：$i=b/n$，位号：$j=b\%n$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/23/pPYF0N6.png" alt="pPYF0N6.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘的分配</p>
<ul>
<li>若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”</li>
<li>②根据字号、位号算出对应的盘块号，将相应盘块分配给文件，并将相应位设置为“1”</li>
</ul>
</li>
<li><p>磁盘的回收</p>
<ul>
<li>①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0”</li>
</ul>
</li>
</ul>
</li>
<li><p>成组链接法（了解）</p>
<ul>
<li><strong>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大</strong>。<br>UNIX系统中采用了成组链接法对磁盘空闲块进行管理。</li>
<li>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。<br>并且要保证内存与外存的“超级块”数据一致，<strong>适合大型文件系统</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li>盘块号${=}$起始块号${+\lfloor}$盘块号${/(1024 \times 8)\rfloor=32+\lfloor 409612 /(1024 \times 8)\rfloor=32+50=82}$, 这里问的是块内字节号而不是位号, 因此还需除以${8(1 \mathrm{B}=8}$位${)}$, 块内字节号${=\lfloor(}$盘块号${\%(1024 \times 8)) / 8\rfloor=1}$。<br><img src="https://s1.ax1x.com/2023/08/24/pPYHxKS.png" alt="pPYHxKS.png"></li>
</ul>
</li>
</ul>
<h4 id="3-虚拟文件系统-VFS-与文件系统挂载"><a href="#3-虚拟文件系统-VFS-与文件系统挂载" class="headerlink" title="3.虚拟文件系统(VFS)与文件系统挂载"></a>3.虚拟文件系统(VFS)与文件系统挂载</h4><ul>
<li>虚拟文件系统<ul>
<li>虚拟文件系统的特点<ul>
<li><strong>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</strong></li>
<li>VFS要求下层的文件系统必须实现某些规定的函数功能，如：open/read/write<br>一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li>
<li>每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统<br><strong>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</strong></li>
<li>打开文件后，即创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/24/pPY5TMQ.png" alt="pPY5TMQ.png"></li>
</ul>
</li>
</ul>
</li>
<li>文件系统挂载（文件系统装载）<ul>
<li>挂载的过程<ul>
<li>在VFS中注册新挂载的文件系统。内存中的挂载表(mount table)包含每个文件系统的相关信息，包括文件系统类型、容量大小等</li>
<li>新挂载的文件系统，要向VFS提供一个<strong>函数地址列表</strong></li>
<li>将新文件系统加到挂载点(mount point)，也就是将新文件系统挂载在某个父目录下</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/24/pPYIVJK.png" alt="pPYIVJK.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第三章-内存管理</title>
    <url>/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="操作系统第三章-内存管理"><a href="#操作系统第三章-内存管理" class="headerlink" title="操作系统第三章 内存管理"></a>操作系统第三章 内存管理</h2><blockquote>
<p>计算机学科基础：操作系统第三章内存管理的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-内存管理的概念（✪）"><a href="#一-内存管理的概念（✪）" class="headerlink" title="一.内存管理的概念（✪）"></a>一.内存管理的概念（✪）</h3><h4 id="1-内存管理的基本原理与要求"><a href="#1-内存管理的基本原理与要求" class="headerlink" title="1.内存管理的基本原理与要求"></a>1.内存管理的基本原理与要求</h4><ul>
<li><p>存储管理的目的：方便用户和提高内存利用率<br>对内存的访问以字或字节为单位</p>
</li>
<li><p>逻辑地址与物理地址</p>
<ul>
<li>逻辑地址<ul>
<li>编译后，每个目标模块都从0号单元开始编址，这称为该目标模块的相对地址（或逻辑地址）。</li>
<li>当链接程序将各个模块链接成一个完整的可执行目标程序时，<br>链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间（或虚拟地址空间）</li>
<li>进程在运行时，看到和使用的地址都是逻辑地址。用户程序和程序员只需知道逻辑地址，<br>而内存管理的具体机制则是完全透明的。</li>
<li>不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。</li>
</ul>
</li>
<li>物理地址<ul>
<li>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。</li>
<li><strong>当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。</strong></li>
<li>操作系统通过内存管理部件(MMU)将进程使用的逻辑地址转换为物理地址。进程使用虚拟内存空间中的地址，操作系统在相关硬件的协助下，将它“转换”成真正的物理地址。</li>
<li>逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用。</li>
</ul>
</li>
</ul>
</li>
<li><p>程序的链接和装入</p>
<ul>
<li>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，有以下三个步骤：</li>
<li>编译：由源代码文件生成目标模块(高级语言“<strong>翻译”为机器语言</strong>)</li>
<li>链接：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块，<strong>形成逻辑地址</strong><ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），<br>之后不再拆开。</li>
<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式<br>其优点是便于修改和更新，便于实现对目标模块的共享</li>
<li>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。<br>其优点是能加快程序的装入过程，还可节省大量的内存空间</li>
</ul>
</li>
<li>装入：将装入模块装入内存，装入后<strong>形成物理地址（实现将逻辑地址转换为物理地址）</strong><ul>
<li>绝对装入<ul>
<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。<br>此时编译、链接后得到的装入模块的指令直接就使用了绝对地址，装入程序按照装入模块中的地址，将程序和数据装入内存。</li>
<li>绝对装入只适用于单道程序环境。</li>
<li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。<br>通常情况下都是编译或汇编时再转换为绝对地址</li>
</ul>
</li>
<li>静态重定位（可重定位装入，装入时转换为物理地址）<ul>
<li>编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。</li>
<li><strong>可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址</strong>（地址变换是在装入时一次完成的）</li>
<li>适用于早期多道批处理系统</li>
<li>静态重定位的特点<ul>
<li>在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。</li>
<li><strong>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</strong></li>
</ul>
</li>
</ul>
</li>
<li>动态重定位（动态运行时装入，执行时转换为物理地址）<ul>
<li><strong>程序在内存中若发生移动</strong>，则需要采用动态的装入方式。<strong>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要<u>执行时</u>才进行</strong>。</li>
<li><strong>装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持，在运行时将逻辑地址转换为物理地址</strong><ul>
<li>重定位寄存器：存放装入模块存放的起始位置</li>
</ul>
</li>
<li>动态重定位的优点：<ul>
<li>可以将程序分配到不连续的存储区；</li>
<li>在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存<br>可以向用户提供一个比存储空间大得多的地址空间</li>
<li>便于程序段的共享。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP3N4qP.png" alt="pP3N4qP.png"></li>
</ul>
</li>
</ul>
</li>
<li>进程的内存映像<ul>
<li>组成<ul>
<li>只读代码段：即程序的二进制代码或<strong>由const关键字修饰的常变量</strong>，代码段是只读的，可以被多个进程共享。</li>
<li>读/写数据段：即程序运行时加工处理的对象，包括定义<strong>在函数外的全局变量、由static关键字修饰的静态变量</strong></li>
<li>堆：用来存放动态分配的变量。通过调用malloc函数动态地向高地址分配空间</li>
<li>共享库的存储映射区：是被调用的库函数</li>
<li>栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长，<strong>在函数大括号内定义的局部变量、函数调用时传入的参数</strong></li>
<li>进程控制块(PCB):存放在系统区。操作系统通过PCB来控制和管理进程，在操作系统内核区。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP3RRzt.png" alt="pP3RRzt.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>内存管理的主要功能</p>
<ul>
<li><p>内存空间的分配与回收</p>
<ul>
<li>由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率</li>
<li>包括连续分配的管理方式和非连续分配的管理方式<ul>
<li>连续分配管理方式包括：单一连续分配、固定分区分配、动态分区分配（可变分区分配）</li>
<li>非连续分配管理方式包括：基本分页存储管理、基本分段存储管理、段页式存储管理</li>
</ul>
</li>
</ul>
</li>
<li><p>地址转换</p>
<ul>
<li>在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，<br>把逻辑地址转换成相应的物理地址（地址重定位）</li>
</ul>
</li>
<li><p>内存空间的扩充</p>
<ul>
<li>利用虚拟存储技术或自动覆盖技术、交换技术，从逻辑上扩充内存</li>
<li><strong>覆盖技术适用于单一连续分配和固定分区分配</strong></li>
</ul>
</li>
<li><p>内存共享</p>
<ul>
<li>指允许多个进程访问内存的同一部分。例如，多个合作进程可能需要访问同一块数据，因此必须支持对内存共享区域进行受控访问。</li>
</ul>
</li>
<li><p>内存保护（界地址保护）</p>
<ul>
<li>保证各道作业在各自的存储空间内运行，互不干扰，不会越界访问，需要操作系统与硬件合作</li>
<li>方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，<br>CPU检查是否越界。</li>
<li>方法二：采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。<br>重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-连续分配管理方式"><a href="#2-连续分配管理方式" class="headerlink" title="2.连续分配管理方式"></a>2.连续分配管理方式</h4><ul>
<li>连续分配：指为用户进程分配的必须是一个<strong>连续的内存空间</strong>。</li>
<li>内部碎片与外部碎片<ul>
<li>内部碎片，程序小于固定分区的大小时，有些部分没有用上，会存在空间浪费</li>
<li>外部碎片，是指内存中的某些空闲分区由于太小而难以利用，内存的利用率下降</li>
<li>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，<br>因此这些“碎片”不能满足进程的需求。可以通过紧凑(拼凑)技术来解决外部碎片。</li>
</ul>
</li>
<li>三种连续分配方式<ul>
<li>单一连续分配<ul>
<li>只支持单道程序，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；<br>用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</li>
<li>优点：实现简单；<strong>无外部碎片</strong>；<strong>可以采用覆盖技术扩充内存；无须采取内存保护</strong></li>
<li>缺点：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>；存储器利用率极低。</li>
</ul>
</li>
<li>固定分区分配<ul>
<li>最简单的一种<strong>多道程序存储管理方式</strong>，它将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。<br>当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。</li>
<li>固定分区划分分区的两种方法<ul>
<li>分区大小相等：程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。<br>适合用于用一台计算机控制多个相同对象的场合</li>
<li>分区大小不等：划分为多个较小的分区、适量的中等分区和少量大分区。</li>
</ul>
</li>
<li>分区使用表<ul>
<li>概述（一个数据结构，实现各个分区的分配与回收）<ul>
<li>每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）</li>
<li>分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为“已分配”，若找不到这样的分区，则拒绝分配。</li>
<li>回收内存时，只需将对应表项的状态置为“未分配”即可。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP3WakQ.png" alt="pP3WakQ.png"></li>
</ul>
</li>
</ul>
</li>
<li>优点：实现简单，<strong>无外部碎片</strong>。</li>
<li>缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不<strong>采用覆盖技术来解决</strong>，但这又会降低性能 ；<br>会<strong>产生内部碎片</strong>，内存利用率低</li>
</ul>
</li>
<li>动态分区分配（可变分区分配）<ul>
<li>支持多道程序，<strong>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</li>
<li>记录空闲内存分区的两种数据结构<ul>
<li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号分区大小、分区起始地址等信息</li>
<li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>
<li>分配内存和回收内存时，修改相应的表项，<strong>回收时出现相邻的空闲分区要合并（采用拼接技术）</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP3WXhd.png" alt="pP3WXhd.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点：<strong>会产生外部碎片（可用紧凑来解决），不会产生内部碎片</strong></li>
<li>动态分区分配算法：在动态分区分配中，当内存中很多个空闲分区都能满足需求时，应该选择哪个分区进行分配<ul>
<li>首次适应算法  (First Fit)<ul>
<li>算法思想：<strong>每次都从低地址开始查找，找到第一个能满足大小的空闲分区</strong>。</li>
<li>如何实现：<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），<br>找到大小能满足要求的第一个空闲分区。、</li>
<li>优点：<strong>算法开销小，性能最优</strong>（回收分区后不需要重新进行空闲分区的排序）</li>
<li>缺点：会使内存的低地址部分产生很多小的空闲分区，每次查找时都要经过这些分区，增加了开销</li>
</ul>
</li>
<li>最佳适应算法  (Best Fit)<ul>
<li>算法思想：保证当“大进程”到来时能有连续的大片空间，可以<strong>尽可能多地留下大片的空闲区，即优先使用更小的空闲区。</strong></li>
<li>如何实现：<strong>空闲分区按容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），<br>找到大小能满足要求的第一个空闲分区；</li>
<li>缺点<ul>
<li>每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，<strong>产生很多的外部碎片</strong></li>
<li><strong>在发生次序变动时需要对链表进行重新排列，开销大</strong></li>
</ul>
</li>
</ul>
</li>
<li>最坏/大适应算法  (Worst Fit)<ul>
<li>算法思想：为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，<strong>这样分配后剩余的空闲区就不会太小，更方便使用。</strong></li>
<li>如何实现：<strong>空闲分区按容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），<br>找到大小能满足要求的第一个空闲分区；在发生次序变动时需要对链表进行重新排列</li>
<li>缺点：<ul>
<li>每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。<strong>如果之后有“大进程”到达，就没有内存分区可用了</strong>。</li>
<li><strong>在发生次序变动时需要对链表进行重新排列，开销大</strong></li>
</ul>
</li>
</ul>
</li>
<li>邻近适应算法  (Next Fit)<ul>
<li>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。<br>如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</li>
<li>如何实现：<strong>空闲分区以地址递增的顺序排列</strong>（可排成一个循环链表）。<strong>每次分配内存时从上次查找结束的位置开始查找空闲分区链</strong>（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
<li>优点：开销小（回收分区后不需要重新进行空闲分区的排序）</li>
<li>缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，<br>也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后<strong>导致无大分区可用</strong>（最大适应算法的缺点）</li>
</ul>
</li>
<li>四种算法的区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP3hIeK.png" alt="pP3hIeK.png"></li>
</ul>
</li>
<li>例题<ul>
<li><img src="https://s1.ax1x.com/2023/08/20/pP8djns.png" alt="pP8djns.png"></li>
<li><img src="https://s1.ax1x.com/2023/08/20/pP8dvBn.png" alt="pP8dvBn.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-基本分页存储管理（♚）"><a href="#4-基本分页存储管理（♚）" class="headerlink" title="4.基本分页存储管理（♚）"></a>4.基本分页存储管理（♚）</h4><ul>
<li>分页存储的基本概念<ul>
<li>内存空间与进程空间的划分<ul>
<li>内存空间中的概念<ul>
<li>页框、页帧：将内存划分为一个个大小相等的分区，即内存中的块（也称为内存块、物理块、物理页面）</li>
<li>页框号：每个页框的编号，从0开始（又称为页帧号、内存块号、物理块号、物理页号）</li>
</ul>
</li>
<li>进程中的概念<ul>
<li>页、页面：将进程的逻辑地址空间也分为与页框大小相等的一个个部分</li>
<li>页号、页面号：每个页面的编号，<strong>从0开始</strong></li>
<li>页面大小由多种因素决定，一旦决定就是等长的<ul>
<li>页面小，用于管理页面的页表就大，但是页内碎片小</li>
<li>页面大，用于管理页面的页表就小，但是页内碎片大</li>
</ul>
</li>
</ul>
</li>
<li>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。<br><strong>进程的页面与内存的页框存在着一一对应的关系</strong>，但各个页面不必连续存放，可以放在不相邻的各个页框中</li>
<li>注：<strong>分页管理不会产生外部碎片</strong>；进程只会在为最后一个页面申请一个主存块空间时，才<strong>可能会产生内部碎片</strong>，<br>但这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）</li>
</ul>
</li>
<li>页表的概念（页号与物理块号的映射）<ul>
<li>为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，<br>它记录页面在内存中对应的物理块号，页表一般存放在内存的PCB中。</li>
<li>一个进程对应一张页表，页表由页表项组成，每个页表项由页号和块号（页框号）组成<br>页号由0到1，块号是与之对应的在内存中的物理地址。</li>
<li>每个页表项的长度是相同的</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP37tiT.png" alt="pP37tiT.png"></li>
</ul>
</li>
</ul>
</li>
<li>确定页表的相关数据<ul>
<li>确定页表项的大小（页面长度）<ul>
<li>页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）</li>
<li>可通过计算机中内存块的数量$\rightarrow$ 页表项中的块号至少占多少个字节 </li>
<li>假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节？<ul>
<li>内存块大小=页面大小=4KB=$2^{12}$B</li>
<li>4GB的内存总共会被分为$2^{32}/2^{12}=2^{20}$个内存块</li>
<li>内存块号的范围应该是${0 \sim 2^{20}-1}$</li>
<li>内存块号至少要用 20 bit 来表示</li>
<li>即至少要用3B来表示块号${(3 * 8=24 \mathrm{bit})}$<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP3xSiR.png" alt="pP3xSiR.png"></li>
<li><strong>页表记录的只是内存块号，而不是内存块的起始地址</strong></li>
<li>$j$号内存块的起始地址=$j*内存块大小$</li>
</ul>
</li>
<li>由于页号是隐含的，因此每个页表项占3B，存储页号为n的整个页表至少需要$3*(n+1)B$</li>
</ul>
</li>
</ul>
</li>
<li>找到页号所对应的块号的存储地址<ul>
<li>假设页表中的各页表项从内存地址为X的地方开始连续存放，此时ⅰ号页表项的存放地址=$X+内存块大小*i$</li>
</ul>
</li>
</ul>
</li>
<li>实现逻辑地址到物理地址的转换<ul>
<li>1.计算出逻辑地址对应的[页号，页内偏移量]<ul>
<li>页号=逻辑地址/页面长度（取除法的整数部分）</li>
<li>页内偏移量=逻辑地址%页面长度（取除法的余数部分）</li>
</ul>
</li>
<li>2.找到对应页面在内存中的起始地址（查页表）</li>
<li>3.物理地址=页面起始始址+页内偏移量</li>
<li>假设在某计算机系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址110对应的页号、页内偏移量是多少？<ul>
<li>页号=110/50=2</li>
<li>页内偏移量=110%50=10</li>
<li>通过页号查询页表，可知页面在内存中物理块号，从而知道页面的起始地址</li>
<li>页面在内存中的起始地址+页内偏移量=实际的物理地址</li>
</ul>
</li>
</ul>
</li>
<li>逻辑地址结构（页号P，页内偏移量W）<ul>
<li>如果页面大小刚好是<strong>2的整数幂</strong>，则计算机硬件可快速拆分逻辑地址，</li>
<li><strong>如果每个页面的大小为$2^{k}$B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分为页号</strong></li>
<li>地址长度为 32 位时，其中${0 \sim 11}$位为页内地址，即每页大小为${4 \mathrm{KB} 、 12 \sim 31}$位为页号, 即最多允许${2^{20}}$页</li>
<li>计算机直接将页号所对应的块的起始地址与页内偏移量的二进制拼接起来即可得到物理地址<ul>
<li>注：这里的块号与页号的关系需要查询相应的页表<img src="https://s1.ax1x.com/2023/08/19/pP3OJ8f.jpg" alt="pP3OJ8f.jpg"></li>
</ul>
</li>
<li>页面大小&lt;-&gt;页内偏移量位数-&gt;逻辑地址结构<ul>
<li>如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是$2^k$个内存单元</li>
<li>如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有$2^M$个页面</li>
</ul>
</li>
<li>特点<ul>
<li>在分页存储管理（页式管理）的系统中，<strong>只要确定了每个页面的大小，逻辑地址结构就确定了</strong>。因此，页式管理中地址是一维的。</li>
<li>即只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基本地址变换机构<ul>
<li>基本地址变换机构的构成<ul>
<li>通常会在系统中设置一个页表寄存器(PTR)，<strong>存放页表在内存中的起始地址F和页表长度M</strong></li>
<li>进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中</li>
<li>当进程被调度时，操作系统内核会把它们放到页表寄存器中</li>
</ul>
</li>
<li>逻辑地址到物理地址的转换过程（由硬件自动完成）<ul>
<li>将页表始址和页表长度装入页表寄存器中。设页面大小为L，逻辑地址A到物理地址E的变换过程如下<ul>
<li>①计算页号P (P=A/L) 和页内偏移量W (W=A%L).</li>
<li>②比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。</li>
<li>③页表中页号P对应的页表项地址=页表始址F+页号P×页表项长度，取出该页表项内容b，即为物理块号。<br>注意区分页表长度和页表项长度。页表长度是指一共有多少页，页表项长度是指页地址占多大的存储空间。</li>
<li>④计算E=b×L+W，用得到的物理地址E去访问内存。</li>
</ul>
</li>
<li>实例<ul>
<li>若页面大小L为1KB，页号2对应的物理块为b=8，计算逻辑地址A=2500的物理地址E的过程如下<ul>
<li>P=2500/1K=2，W=2500%1K=452，查找得到页号2对应的物理块的块号为8，E=8×1024+452=8644。</li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><strong>重定位寄存器：整个系统中设置一个即可</strong></li>
<li><img src="https://s1.ax1x.com/2023/08/19/pP3jbHH.png" alt="pP3jbHH.png"></li>
</ul>
</li>
</ul>
</li>
<li>关于页表项的大小问题<ul>
<li>理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询，<br>常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项，因此选择长度为4B</li>
</ul>
</li>
<li>如何加快地址转换<ul>
<li>设置快表（TLB）并增大快表容量</li>
<li>让页表常驻内存</li>
</ul>
</li>
</ul>
</li>
<li><p>具有快表的地址变换机构</p>
<ul>
<li>快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓存(TLB不是内存！)，用来存放最近访问的页表项的副本<br>可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</li>
<li><p>快表的工作过程</p>
<ul>
<li><p>过程</p>
<ul>
<li>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，<br>再将内存块号与页内偏移量拼接形成物理地址，最后访问该物理地址对应的内存单元。<br>因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li>
<li>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，<br>并且将页表项复制到快表中，再将内存块号与页内偏移量拼接形成物理地址，最后访问该物理地址对应的内存单元。<br>因此，若快表未命中，则访问某个逻辑地址需要两次访存</li>
<li>在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。<br>但若快表已满，则必须按照一定的算法对旧的页表项进行替换</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8k1OI.png" alt="pP8k1OI.png"></li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8Ak9g.png" alt="pP8Ak9g.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>局部性原理</p>
<ul>
<li>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。<br>因为局部性原理，一般来说快表的命中率可以达到90%以上。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8AEcj.png" alt="pP8AEcj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两级页表</p>
<ul>
<li>单机页表的问题<ul>
<li>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。<ul>
<li>多级页表可以减少页表所占的连续内存空间</li>
</ul>
</li>
<li>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。<ul>
<li>可以由虚拟存储器解决：作业不必全部装入内存且不用一直驻留在内存</li>
</ul>
</li>
</ul>
</li>
<li>两级页表的原理、地址结构<ul>
<li>把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表</li>
<li>再把原来的逻辑地址结构的页号划分为为10位的一级页号与10位的二级页号</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8ZzRS.png" alt="pP8ZzRS.png"></li>
</ul>
</li>
<li>两级页表的访问过程<ul>
<li>按照地址结构将逻辑地址拆分成三部分</li>
<li>从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li>
<li>根据二级页号查表，找到最终想访问的内存块号</li>
<li>结合页内偏移量得到物理地址</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8e9MQ.png" alt="pP8e9MQ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多级页表<ul>
<li>多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级</li>
<li>多级页表的访存次数（假设没有快表机构）N级页表访问一个逻辑地址需要N+1次访存</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8mZTI.png" alt="pP8mZTI.png"></li>
</ul>
</li>
<li>例题<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPJPI76.png" alt="pPJPI76.png"></li>
<li><img src="https://s1.ax1x.com/2023/08/22/pPJPHhD.png" alt="pPJPHhD.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-基本分段存储管理（♚）"><a href="#5-基本分段存储管理（♚）" class="headerlink" title="5.基本分段存储管理（♚）"></a>5.基本分段存储管理（♚）</h4><ul>
<li><p>分段存储管理的概述</p>
<ul>
<li>引入分段存储管理可以满足：方便编程、分段共享、分段保护、动态链接与动态增长</li>
<li>进程的地址空间：<strong>按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址</strong><br><strong>一个程序如何分段在用户编程时决定</strong></li>
<li>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻<br><strong>分段不会产生内部碎片，会产生外部碎片</strong></li>
<li>分段的逻辑地址结构<ul>
<li>由段号（段名）和段内地址（段内偏移量）所组成。</li>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>段内地址位数决定了每个段的最大长度是多少</li>
</ul>
</li>
<li>分段存储管理将程序按照逻辑段进行划分，有利于程序的动态链接</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8n38K.png" alt="pP8n38K.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>段表</p>
<ul>
<li>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。<br>需为每个进程建立一张段映射表，简称“段表”。</li>
<li>每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li>
<li>各个段表项的长度是相同的。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。<br>若段表存放的起始地址为M，则K号段对应的段表项存放的地址为M+K*6（段表项长度为6字节）</li>
</ul>
</li>
<li><p>地址转换</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8n4P0.png" alt="pP8n4P0.png"></li>
</ul>
</li>
<li><p>分段地址变换机构</p>
<ul>
<li>过程<ul>
<li>①从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。<br>注意，在地址变换的题目中，要注意逻辑地址是用二进制数还是用十进制数给出的。</li>
<li>②比较段号S和段表长度M，若S≥M，则产生越界中断，否则继续执行。</li>
<li>③段表中段号S对应的段表项地址=段表始址F+段号S×段表项长度，取出该段表项的前几位得到段长C。<br>若段内偏移量≥C，则产生越界中断，否则继续执行。</li>
<li>④取出段表项中该段的始址b，计算E=b+W，用得到的物理地址E去访问内存。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8uVit.png" alt="pP8uVit.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>分页和分段的对比</p>
<ul>
<li><strong>页是信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。</li>
<li><strong>段是信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。</li>
<li><strong>分页会产生内部碎片，不会产生外部碎片（段页式有内部碎片）</strong><br><strong>分段会产生外部碎片，不会产生内部碎片</strong></li>
<li><strong>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</strong>。</li>
<li><strong>分页的用户进程地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。</li>
<li><strong>分段的用户进程地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
<li><strong>分段比分页更容易实现信息的共享和保护</strong>。<ul>
<li>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。</li>
<li>分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。<ul>
<li>地址越界保护将段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度，则产生越界中断</li>
<li>再将段表项中的段长和逻辑地址中的段内偏移进行比较，若段内偏移大于段长，也会产生越界中断。</li>
<li>分页管理只需要判断页号是否越界，页内偏移是不可能越界的。</li>
</ul>
</li>
<li>关于可重入程序<ul>
<li>当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。</li>
<li><strong>不能被修改的代码</strong>称为纯代码或<strong>可重入代码</strong>（不属于临界资源），可重入代码<strong>是可以共享的</strong>。</li>
<li><strong>可修改的代码是不能共享的</strong>（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</li>
</ul>
</li>
<li>可重入程序主要是通过共享来使用同一块存储空间的，或通过动态链接的方式将所需的程序映射到相关进程中去<br>可以<strong>减少对程序段的调入与调出，因此减少了对换数量</strong></li>
</ul>
</li>
<li>访问一个逻辑地址需要几次访存？<ul>
<li>分页（单级页表）：第一次访存一一查内存中的页表，第二次访存一一访问目标内存单元。总共两次访存</li>
<li>分段：第一次访存一一查内存中的段表，第二次访存一一访问目标内存单元。总共两次访存</li>
<li>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-段页式管理"><a href="#6-段页式管理" class="headerlink" title="6.段页式管理"></a>6.段页式管理</h4><ul>
<li>分页与分段的优缺点分析<ul>
<li>分页管理<ul>
<li>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</li>
<li>不方便按照逻辑模块实现信息的共享和保护</li>
</ul>
</li>
<li>分段管理<ul>
<li>很方便按照逻辑模块实现信息的共享和保护，不会产生内部碎片</li>
<li>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</li>
</ul>
</li>
<li>段页式管理会产生内部碎片</li>
</ul>
</li>
<li><p>段页式管理</p>
<ul>
<li>段页式系统中，进程首先划分为段，每段再进一步划分为页，每个进程一张段表，每个段一张页表</li>
<li>将地址空间按照程序自身的逻辑关系划分为若干个段，在将各段分为大小相等的页面</li>
<li>将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8MMUs.png" alt="pP8MMUs.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>段页式管理的逻辑地址结构</p>
<ul>
<li>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。<ul>
<li><img src="https://s1.ax1x.com/2023/08/19/pP8MBP1.png" alt="pP8MBP1.png"></li>
</ul>
</li>
<li>段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页</li>
<li>页内偏移量决定了页面大小、内存块大小是多少</li>
<li>若系统是按字节寻址的，则段号占16位，因此在该系统中，每个进程最多有$2^{16}=64K$个段</li>
<li>页号占4位，因此每个段最多有$2^4=16$页<br>页内偏移量占12位，因此每个页面/每个内存块大小为$2^{12}=4096=4KB$</li>
</ul>
</li>
<li>段页式管理中的段表与页表<ul>
<li>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。<br>每个段表项长度相等，段号是隐含的。</li>
<li>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</li>
<li>图片<ul>
<li><img src="https://s21.ax1x.com/2024/08/12/pApQw3q.png" alt="pApQw3q.png"></li>
</ul>
</li>
</ul>
</li>
<li>段页式管理的逻辑地址转换<ul>
<li>过程（需进行三次访存，也可用快表解决）<ul>
<li>1.由逻辑地址得到段号、页号、页内偏移量</li>
<li>2.段号与段表寄存器中的段长度比较，检查是否越界</li>
<li>3.由段表始址、段号找到对应段表项</li>
<li>4.根据段表中记录的页表长度，检查页号是否越界</li>
<li>5.由段表中的页表地址、页号得到查询页表，找到相应页表项</li>
<li>6.由页面存放的内存块号、页内偏移量得到最终的物理地址</li>
<li>7.访问目标单元</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/20/pP8dOXj.png" alt="pP8dOXj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二-虚拟内存管理（✪）"><a href="#二-虚拟内存管理（✪）" class="headerlink" title="二.虚拟内存管理（✪）"></a>二.虚拟内存管理（✪）</h3><h4 id="1-虚拟内存的基本概念"><a href="#1-虚拟内存的基本概念" class="headerlink" title="1.虚拟内存的基本概念"></a>1.虚拟内存的基本概念</h4><ul>
<li>传统存储管理方式的缺点<ul>
<li>许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</li>
<li>一次性<ul>
<li><strong>作业必须一次性全部装入内存后，才能开始运行</strong>。</li>
<li>当作业很大而不能全部被装入内存时，将使该作业无法运行</li>
<li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li>
</ul>
</li>
<li>驻留性<ul>
<li><strong>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束</strong>。</li>
<li>运行中的进程会因等待I/O而被阻塞，可能处于长期等待状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存的概述</p>
<ul>
<li><p>概述</p>
<ul>
<li>虚拟内存在物理上扩展内存相对有限的条件下，在逻辑上扩充内存，实际的物理内存大小没有变</li>
<li><strong>虚拟内存使用外存上的空间来扩充内存空间，通过一定的换入/换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。</strong></li>
<li>因为虚拟内存技术调换页面时需要访问外存，会导致平均访存时间增加，若使用了不合适的替换算法，则会大大降低系统性能。</li>
</ul>
</li>
<li><p>虚拟内存空间的大小限制（区分实际容量和最大容量的决定因素）</p>
<ul>
<li>虚存的<strong>实际容量</strong> ≤ 内存容量和外存容量之和<ul>
<li>这是硬件的硬性条件规定的，若虚存的实际容量超过了这个容量，则没有相应的空间来供虚存使用。</li>
</ul>
</li>
<li>虚存的<strong>最大容量</strong> ≤ 计算机的地址位数能容纳的最大容量<ul>
<li><strong>虚拟内存的最大容量由计算机的地址结构决定</strong></li>
<li>假设地址是32位的，按字节编址，一个地址代表1B存储空间，则虚存的最大容量≤4GB($2^{32}$B)。</li>
<li>这是因为若虚存的最大容量超过4GB，则32位的地址将无法访问全部虚存，也就是说4GB以后的空间被浪费了，相当于没有一样，没有任何意义。</li>
</ul>
</li>
<li>实际虚存的容量是取条件以上两种情况的交集，即两个条件都要满足，仅满足一个条件是不行的。</li>
</ul>
</li>
</ul>
</li>
<li>虚拟内存的特征<ul>
<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>
<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
<li>注<strong>：还有离散性（基于非连续分配方式）</strong></li>
</ul>
</li>
<li><p>虚拟内存技术的实现（<strong>只能基于非连续分配的技术</strong>）</p>
<ul>
<li><p>虚拟内存管理方式的基础</p>
<ul>
<li>虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式的基础上</li>
<li>局部性原理（<strong>虚拟存储管理系统的基础，实现多次性</strong>）<ul>
<li>在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</li>
<li>概念<ul>
<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；<br>如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</li>
<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。<br>(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</li>
<li>高速缓存技术：使用频繁的数据放到更高速的存储器中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存技术的三个方式：</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
<li>实现虚拟内存中操作系统提供的功能<ul>
<li>请求调页（或请求调段）功能<ul>
<li><strong>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</strong></li>
</ul>
</li>
<li>页面置换（或段置换）的功能<ul>
<li><strong>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</strong></li>
</ul>
</li>
</ul>
</li>
<li>实现虚拟内存的硬件支持<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-缺页中断"><a href="#2-缺页中断" class="headerlink" title="2.缺页中断"></a>2.缺页中断</h4><ul>
<li>缺页中断是访存指令引起的，说明所要访问的页面不在内存中，进行缺页中断处理并调入所要访问的页后，<strong>访存指令显然应该重新执行被中断的那一条指令</strong></li>
<li>关于缺页中断的次数<ul>
<li><strong>缺页中断的次数等于其访问的页帧数。若页面尺寸增大而可容纳的最大页数不变，存放程序需要的页帧数就会减少，因此缺页中断的次数也会减少</strong>。</li>
<li><strong>在请求分页存储管理中，若采用FIFO页面置换算法，则当可供分配的页帧数增加时，缺页中断的次数可能增加也可能减少</strong><br><strong>其它页面置换算法的缺页中断次数则会随着可供分配的页帧数的增加而减少</strong></li>
<li>无论采用什么页面置换算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以缺页次数大于或等于页号数量。</li>
</ul>
</li>
<li>影响缺页率的因素<ul>
<li>页置换算法<ul>
<li>页缓冲队列是将淘汰的页面缓存下来，暂时不写回磁盘，队列长度会影响页面置换的长度，但是不会影响缺页率</li>
</ul>
</li>
<li>工作集的大小</li>
<li>进程的数量</li>
</ul>
</li>
</ul>
<h4 id="3-请求分页管理方式"><a href="#3-请求分页管理方式" class="headerlink" title="3.请求分页管理方式"></a>3.请求分页管理方式</h4><ul>
<li><p>引入的原因</p>
<ul>
<li><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道。并且还需要页面在外存中存放的位置</p>
</li>
<li><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，需要记录各个页面是否被修改的信息。</p>
</li>
</ul>
</li>
<li><p>请求分页存储管理的主要特点</p>
<ul>
<li>请求分页存储管理就是为了解决内存容量不足而使用的方法，它基于局部性原理实现了以时间换取空间的目的。</li>
<li><strong>主要特点是间接扩充了内存</strong>。</li>
</ul>
</li>
<li><p>请求页表项的结构</p>
<ul>
<li>新增四个字段<ul>
<li>状态位P（合法位）。<strong>用于指示该页是否已调入内存，供程序访问时参考</strong>。<br><strong>决定了是否会发生页面故障</strong></li>
<li>访问字段A。用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，<br><strong>供置换算法换出页面时参考</strong>。</li>
<li>修改位M。<strong>标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存</strong>。</li>
<li>外存地址。用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGOmKU.png" alt="pPGOmKU.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>缺页中断机构</p>
<ul>
<li>过程<ul>
<li>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断</li>
<li>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</li>
<li>如果内存中有空闲块，则为<strong>进程分配一个空闲块（分配页框）</strong>，将所缺页面从外存装入该块（<strong>磁盘I/O</strong>），并<strong>修改页表中相应的页表项</strong>。</li>
<li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。<br>未修改过的页面不用写回外存。</li>
</ul>
</li>
<li>特点<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部异常（故障）。</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
</li>
</ul>
</li>
<li><p>地址变换机构</p>
<ul>
<li>与基本分页存储管理的不同之处<ul>
<li>需要检查所需页面是否在内存中，查看快表和请求页表</li>
<li>若页面不在内存中则产生缺页中断，需要请求调页</li>
<li>若内存空间不够，还需换出页面</li>
<li>页面调入内存后，需要修改相应页表项</li>
</ul>
</li>
<li>基本流程<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGOub4.png" alt="pPGOub4.png"></li>
</ul>
</li>
<li>注意事项<ul>
<li>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是<ul>
<li>查快表（未命中）一一查慢表（发现未调入内存）一一调页（调入的页面对应的表项会直接加入快表）一一查快表（命中）一一访问目标内存单元</li>
</ul>
</li>
<li>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</li>
<li>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</li>
<li>③需要用某种“页面置换算法”来决定一个换出页面</li>
<li>④换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销</li>
<li>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li>
<li>⑥快表中有的页面一定是在内存中的。若某个页面被换出外存则快表中的相应表项也要删除，否则可能访问错误的页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-页框分配"><a href="#4-页框分配" class="headerlink" title="4.页框分配"></a>4.页框分配</h4><ul>
<li>驻留集<ul>
<li><strong>指请求分页存储管理中给进程分配的物理块的集合</strong>。</li>
<li>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</li>
<li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少：</li>
<li>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</li>
</ul>
</li>
<li>分配策略<ul>
<li>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。<strong>即驻留集大小不变</strong></li>
<li>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变</li>
</ul>
</li>
<li>置换策略<ul>
<li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li>
<li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。<ul>
<li>全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配</li>
</ul>
</li>
</ul>
</li>
<li>三种内存分配置换策略<ul>
<li>固定分配局部置换<ul>
<li>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</li>
<li>缺点：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。</li>
<li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li>
</ul>
</li>
<li>可娈分配全局置换<ul>
<li>过程<ul>
<li>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。</li>
<li>当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；</li>
<li>若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。<ul>
<li>系统会锁定一些页面，这些页面中的内容不能置换出外存（如：重要的内核数据可以设为锁定）</li>
</ul>
</li>
</ul>
</li>
<li>缺点：采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。<br><strong>被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加</strong>。</li>
</ul>
</li>
<li>可变分配局部置换<ul>
<li>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。</li>
<li>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；<br>反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li>
<li>区别<ul>
<li><strong>可变分配全局置换：只要缺页就给分配新物理块</strong></li>
<li><strong>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>页面调入的时机<ul>
<li>预调页策略<ul>
<li>根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则测又是低效的。（主要是空间局部性原理）<br>因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右</li>
<li><strong>这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分，在运行前调入</strong></li>
</ul>
</li>
<li>请求调页策略<ul>
<li>进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，在运行时调入</li>
<li><strong>但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。</strong></li>
</ul>
</li>
</ul>
</li>
<li>页面调入的区域<ul>
<li>外存中的交换区与文件区<ul>
<li>交换区：读/写速度更快，采用连续分配方式</li>
<li>文件区：读/写速度更慢，采用离散分配方式</li>
<li>若交换区的磁盘利用率过高，说明物理内存非常短缺，此时的处理策略如下<ul>
<li><strong>增大物理内存容量</strong>，使每个程序得到更多的页框，能减少缺页率，进而减少换入换出过程，提高CPU的利用率</li>
<li><strong>减少多道程序的度数</strong>，可减少主存中的进程数，减少换入换出频率，可以提高CPU的利用率</li>
<li><strong>使用更快的磁盘交换区和更快速的CPU没有用</strong></li>
</ul>
</li>
</ul>
</li>
<li>三种调入调出区域处理<ul>
<li>系统拥有足够的对换区空间<ul>
<li><strong>在进程运行前，需将进程相关的数据从文件区复制到对换区</strong>。</li>
<li><strong>页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快</strong>。</li>
</ul>
</li>
<li>系统缺少足够的对换区空间<ul>
<li><strong>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。</strong></li>
<li><strong>对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</strong>。</li>
</ul>
</li>
<li>UNIX方式<ul>
<li><strong>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入</strong>。</li>
<li><strong>若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>页面调入的方法<ul>
<li>当进程所访问的页面不在内存中时(存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。</li>
<li>该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I/O，将所缺页调入内存，并修改页表。</li>
<li>如果内存已满，则先按某种置换算法从内存中选出一页准备换出<ul>
<li>如果该页未被修改过(修改位为0)，则无须将该页写回磁盘</li>
<li>如果该页已被修改(修改位为1)，则必须将该页写回磁盘</li>
</ul>
</li>
<li>然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。<br>调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-页面置换算法（♚）"><a href="#5-页面置换算法（♚）" class="headerlink" title="5.页面置换算法（♚）"></a>5.页面置换算法（♚）</h4><ul>
<li>页面置换的概述<ul>
<li>进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。</li>
<li>选择调出页面的算法就称为页面置换算法。好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或以后较长时间内不会再访问的页面先调出。</li>
</ul>
</li>
<li>最佳置换算法（OPT）<ul>
<li>概述<ul>
<li>选择的被淘汰页面是以后永不使用的页面，或是在最长时间内不再被访问的页面，以便保证获得最低的缺页率。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGjbE4.png" alt="pPGjbE4.png"></li>
</ul>
</li>
<li>特点<ul>
<li>最佳置换算法可以保证最低的缺页率</li>
<li><strong>但实际上，操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。但可利用该算法去评价其他算法</strong></li>
</ul>
</li>
</ul>
</li>
<li>先进先出页面置换算法（FIFO）<ul>
<li>概述<ul>
<li><strong>每次选择淘汰的页面是最早进入内存的页面</strong></li>
<li><strong>把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。</strong><br><strong>队列的最大长度取决于系统为进程分配了多少个内存块</strong>。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGjXCR.png" alt="pPGjXCR.png"></li>
</ul>
</li>
<li>特点<ul>
<li>Belady异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<strong>只有FIFO算法会产生Belady异常</strong>。</li>
<li>FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。<br><strong>算法性能差</strong></li>
</ul>
</li>
</ul>
</li>
<li>最近最久未使用置换算法（LRU）<ul>
<li>概述<ul>
<li><strong>每次淘汰的页面是最近最久未使用的页面</strong></li>
<li>赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的<strong>时间t</strong></li>
<li><strong>当需要淘汰一个页面时，选择现有页面中访问值最大的，即最近最久未使用的页面（进行排序）。</strong></li>
<li>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGjvgx.png" alt="pPGjvgx.png"></li>
</ul>
</li>
<li>特点<ul>
<li>该算法的实现需要专门的硬件支持，虽然<strong>算法性能好，但是实现困难，开销大（需要对所有页进程排序）</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>时钟置换算法（CLOCK）</p>
<ul>
<li>简单CLOCK置换算法（又称最近未用算法_NRU）<ul>
<li>概述<ul>
<li>为每个页面设置一个访问位，将内存中的所有页面视为一个链式循环队列，并有一个替换指针与之相关联。<br><strong>访问位为1，表示最近访问过，访问位为0，表示最近没访问过</strong></li>
<li><strong>当某页首次被装入或被访问时，其访问位置为1，访问时在内存中存在页面则指针不动</strong></li>
<li><strong>在选择一页淘汰时，只需检查页的访问位</strong>。<ul>
<li><strong>若为0，就选择该页换出</strong></li>
<li><strong>若为1，则将它置为0，暂不换出，给予该页第二次驻留内存的机会，再依次顺序检查下一个页面。</strong></li>
<li><strong>当检查到队列中的最后一个页面时，若其访问位仍为1，则返回到队首去循环检查。</strong></li>
</ul>
</li>
<li><strong>当某一页被替换时，该指针被设置指向被替换页面的下一页。</strong></li>
</ul>
</li>
<li>图片<ul>
<li>访问序列：7、0、1、2、0、3、0、4<br><img src="https://s1.ax1x.com/2023/08/22/pPGvZxP.png" alt="pPGvZxP.png"></li>
</ul>
</li>
<li>特点<ul>
<li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描</li>
<li><strong>第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>改进的时钟置换算法</p>
<ul>
<li>改进位与修改位<ul>
<li><strong>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存</strong>。</li>
<li>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。</li>
<li>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。</li>
<li>用(访问位，修改位)的形式表示各页面状态。如(1,1)表示一个页面近期被访问过，且被修改过。</li>
</ul>
</li>
<li><p>规则</p>
<ul>
<li>将所有可能被置换的页面排成一个循环队列</li>
<li><p>第一轮：从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位</p>
<ul>
<li>第一优先级：最近没访问且没修改的页面</li>
</ul>
</li>
<li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0<ul>
<li>第二优先级：最近没访问但修改过的页面</li>
</ul>
</li>
<li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位<ul>
<li>第三优先级：最近访问过但没修改的页面</li>
</ul>
</li>
<li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。<ul>
<li>第四优先级：最近访问过且修改过的页面</li>
</ul>
</li>
<li>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，<strong>因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</strong></li>
</ul>
</li>
</ul>
</li>
<li>例<ul>
<li>首先处理这个16进程数，后缀为H，1个数字为4位，此时前后12位为偏移量（页面大小4KB），此时页号为02，在表中存在位为0需要从外存调入，此时内存大小不够采用置换算法优先置换页号为3的（1,0），此时选C<br><img src="https://s1.ax1x.com/2023/08/22/pPJFMZt.png" alt="pPJFMZt.png"></li>
</ul>
</li>
</ul>
</li>
<li>四种算法的比较<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGvgsK.jpg" alt="pPGvgsK.jpg"></li>
</ul>
</li>
</ul>
<h4 id="6-抖动与工作集"><a href="#6-抖动与工作集" class="headerlink" title="6.抖动与工作集"></a>6.抖动与工作集</h4><ul>
<li>抖动（颠簸，高缺页率）<ul>
<li>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。</li>
<li>频繁的置换页面导致大部分时间都花在页面置换之上，导致系统性能下降</li>
<li><strong>产生抖动的主要原因是<u>页面置换算法不合理</u>，进程频繁访问的页面数目高于可用的物理块数</strong></li>
<li>撤销部分进程可以防止产生抖动</li>
</ul>
</li>
<li>驻留集与工作集<ul>
<li><strong>驻留集：指请求分页存储管理中给进程分配的内存块的集合。</strong></li>
<li><strong>工作集：指在某段时间间隔里，进程<u>实际访问</u>页面的集合。</strong></li>
<li><strong>驻留集大小需要大于工作集大小，否则进程运行过程中将频繁缺页</strong></li>
</ul>
</li>
<li>工作集的特点<ul>
<li>在进程运行时，若其工作集页面都在主存储器内，则能够使该进程有效地运行，否则会出现频繁的页面调入调出现象</li>
<li>操作系统会根据“窗口尺寸”来算出工作集，工作集大小可能小于窗口尺寸<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGXwOU.png" alt="pPGXwOU.png"></li>
</ul>
</li>
<li>实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。<ul>
<li>如窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，</li>
<li>那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。</li>
</ul>
</li>
<li>基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。<br>因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法一一选择一个不在工作集中的页面进行淘汰。</li>
</ul>
</li>
</ul>
<h4 id="7-内存映射文件"><a href="#7-内存映射文件" class="headerlink" title="7.内存映射文件"></a>7.内存映射文件</h4><ul>
<li><p>概述</p>
<ul>
<li>将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，<br>而不必执行文件I/O操作，也无须对文件内容进行缓存处理。这种特性非常适合用来管理大尺寸文件。</li>
<li><strong>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间，以访问内存的方式读写文件</strong></li>
<li><strong>进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射</strong></li>
<li><strong>多个进程可以映射同一个文件，方便共享</strong></li>
</ul>
</li>
<li><p>传统的文件文件访问方式</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGxEo4.png" alt="pPGxEo4.png"></li>
</ul>
</li>
<li><p>内存映射文件访问方式</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGxuS1.png" alt="pPGxuS1.png"></li>
</ul>
</li>
<li><p>多个进程允许并发地内存映射同一个文件，实现数据共享</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/22/pPGxQOK.png" alt="pPGxQOK.png"></li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li>
<li>文件数据的读入/写出完全由操作系统负责，I/O效率可以由操作系统负责优化</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第二章-进程与线程</title>
    <url>/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="操作系统第二章-进程与线程"><a href="#操作系统第二章-进程与线程" class="headerlink" title="操作系统第二章 进程与线程"></a>操作系统第二章 进程与线程</h2><blockquote>
<p>计算机学科基础：操作系统第二章进程与线程的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-进程与线程（✪）"><a href="#一-进程与线程（✪）" class="headerlink" title="一.进程与线程（✪）"></a>一.进程与线程（✪）</h3><h4 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1.进程的概念"></a>1.进程的概念</h4><ul>
<li>进程与程序<ul>
<li>程序：是静态的，一组有序的指令集合，是存放在磁盘里的可执行文件，如：QQ.exe</li>
<li>进程：是动态的，是程序的一次执行过程，如：可同时启动多次QQ程序<br>同一个程序多次执行会对应多个进程</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
<li>进程实体<ul>
<li>进程实体又称进程映像，由程序段、相关数据段和PCB三部分构成<br>PCB是给操作系统用的。程序段、数据段是给进程自己用的。</li>
<li><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong><br>进程实体是静态的，而进程则是动态的</li>
<li>PCB（进程控制块）<ul>
<li>为了使参与并发执行的每个程序（含数据）都能独立地运行，必须为之配置一个专门的<u>数据结构</u>，称为进程控制块 PCB</li>
<li><strong>PCB是进程存在的唯一标志</strong>，系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程<br>当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB</li>
</ul>
</li>
<li>程序段：程序的代码（指令序列）</li>
<li>数据段：运行过程中产生的各种数据  (如程序中定义的变量)</li>
</ul>
</li>
</ul>
<h4 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2.进程的组成"></a>2.进程的组成</h4><ul>
<li>由PCB，程序段，数据段组成</li>
<li>PCB的组成<ul>
<li>进程描述信息<ul>
<li>进程标识符（PID）：标志各个进程，每个进程都有一个唯一的标识号</li>
<li>用户标识符（UID）：进程归属的用户，用户标识符主要为共享和保护服务</li>
</ul>
</li>
<li>进程控制和管理信息<ul>
<li>进程当前状态：描述进程的状态信息，作为处理机分配调度的依据</li>
<li>进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机</li>
</ul>
</li>
<li>资源分配清单<ul>
<li>用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入输出设备信息</li>
</ul>
</li>
<li>处理机相关信息<ul>
<li>也称处理机的上下文，主要指处理机中各寄存器的值。当进程处于执行态时，处理机的许多信息都在寄存器中。</li>
<li>当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-进程的特征"><a href="#3-进程的特征" class="headerlink" title="3.进程的特征"></a>3.进程的特征</h4><ul>
<li>动态性：是进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
<h4 id="4-进程的状态与转换（♚）"><a href="#4-进程的状态与转换（♚）" class="headerlink" title="4.进程的状态与转换（♚）"></a>4.进程的状态与转换（♚）</h4><ul>
<li>进程的五状态（就绪态、运行态、阻塞态是进程的三种基本状态）<ul>
<li>创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>就绪态：进程已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</li>
<li>运行态：进程占有CPU，并在CPU上运行</li>
<li>阻塞态（等待态）：在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）<br>在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”</li>
<li>终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
</li>
<li>进程状态之间的转换<ul>
<li>就绪态一&gt;运行态：进程被调度</li>
<li>运行态一&gt;就绪态：时间片到，或CPU被其他高优先级的进程抢占</li>
<li>运行态一&gt;阻塞态：等待系统资源分配，或等待某事件发生（主动行为）</li>
<li>阻塞态一&gt;就绪态：资源分配到位，等待的事件发生（被动行为）</li>
<li>创建态一&gt;就绪态：系统完成创建进程相关的工作</li>
<li>运行态一&gt;终止态：进程运行结束，或运行过程中遇到不可修复的错误、</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKTpGR.png" alt="pPKTpGR.png"></li>
</ul>
</li>
</ul>
</li>
<li>进程的组织<ul>
<li>进程PCB中，会有一个变量state来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态。<br>为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</li>
<li>链接方式<ul>
<li>链接方式将同一状态的PCB链接成一个队列，不同状态对应不同的队列；<br>也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKHFED.png" alt="pPKHFED.png"></li>
</ul>
</li>
</ul>
</li>
<li>索引方式<ul>
<li>索引方式将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，<br>不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKHmvt.png" alt="pPKHmvt.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-进程控制（♚）"><a href="#5-进程控制（♚）" class="headerlink" title="5.进程控制（♚）"></a>5.进程控制（♚）</h4><ul>
<li>进程控制就是要实现进程状态转换，用原语实现<br>原语是一种特殊的程序，它的执行具有原子性也就是说，这段程序的运行必须一气呵成，不可中断</li>
<li>原语的实现（使用关中断指令与开中断指令这两个特权指令实现原语）<ul>
<li>正常情况下，CPU每执行完一条指令都会例行检查是否有中断信号需要处理，<br>如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPK7E60.png" alt="pPK7E60.png"></li>
</ul>
</li>
<li>CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。<br>此时关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPK7m0U.png" alt="pPK7m0U.png"></li>
</ul>
</li>
</ul>
</li>
<li>进程控制相关的原语（♚）<ul>
<li>进程的创建<ul>
<li>创建原语的过程<ul>
<li>为新进程分配一个唯一的PID，并申请空白PCB</li>
<li>为新进程分配所需资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现）<ul>
<li>这些资源或从操作系统获得，或仅从其父进程获得。</li>
<li>如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li>
</ul>
</li>
<li>初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li>
<li>将PCB插入就绪队列，此时创建态→就绪态，等待被调度运行</li>
</ul>
</li>
<li>引起进程创立的事件<ul>
<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
<li>启动程序执行</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止<ul>
<li>可以使进程由就绪态/阻塞态/运行态→终止态→无</li>
<li>终止原语的过程<ul>
<li>根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程</li>
<li>若该进程还有子孙进程，则应将其所有子孙进程终止。<br>进程间的关系是树形结构</li>
<li>将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</li>
<li>将该PCB从所在队列（链表）中删除。</li>
</ul>
</li>
<li>引起进程终止的过程<ul>
<li>正常结束：进程自己请求终止（exit系统调用）</li>
<li>异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉</li>
<li>外界干预：Ctrl+AIt+delete，用户选择杀掉进程</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞与唤醒<ul>
<li>阻塞原语和唤醒原语必须成对使用</li>
<li>进程的阻塞<ul>
<li>阻塞是进程自身的一种主动行为，使用阻塞原语可以将运行态→阻塞态</li>
<li>阻塞原语的过程<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件<ul>
<li>需要等待系统分配某种资源（如申请临界资源，执行P(wait)操作）</li>
<li>需要等待相互合作的其他进程完成工作：等待I/O操作（如从磁盘读数据）</li>
</ul>
</li>
</ul>
</li>
<li>进程的唤醒<ul>
<li>将阻塞态转变为就绪态，因何事阻塞，就应由何事唤醒<ul>
<li>如退出临界区，I/O结束</li>
</ul>
</li>
<li>唤醒原语的过程<ul>
<li>在该事件等待队列中找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程的切换<ul>
<li>进程的切换可以将运行态→就绪态，就绪态→运行态</li>
<li>切换原语的过程<ul>
<li>将运行环境信息（进程上下文）存入PCB</li>
<li>将PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-进程的通信"><a href="#6-进程的通信" class="headerlink" title="6.进程的通信"></a>6.进程的通信</h4><ul>
<li>进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式</li>
<li>共享存储<ul>
<li>共享存储的概述<ul>
<li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。<br>为了保证安全，一个进程不能直接访问另一个进程的地址空间，因此需要采用共享存储</li>
<li>设置一块可直接访问的共享空间，并映射到进程的虚拟地址空间<br>可通过对这片共享空间进行写/读操作实现进程之间的信息交换</li>
</ul>
</li>
<li>共享存储的特点<ul>
<li>为避免出错，各个进程对共享空间的访问应该是互斥的，各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作)</li>
<li>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</li>
<li>进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，<br>想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的</li>
</ul>
</li>
<li>基于数据结构的共享（低级）<ul>
<li>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKbTTU.png" alt="pPKbTTU.png"></li>
</ul>
</li>
</ul>
</li>
<li>基于存储区的共享（高级）<ul>
<li>操作系统在内存中划出块共享存储区。数据的形式和存放位置都由通信进程控制，而不是操作系统。<br>这种共享方式速度很快，是一种高级通信方式。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKbfln.png" alt="pPKbfln.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>消息传递<ul>
<li>进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换</li>
<li>消息包括消息头与消息体，消息头包括：发送进程ID、接受进程ID、消息长度等格式化的信息</li>
<li>直接通信方式<ul>
<li>消息发送进程要指明接收进程的ID，发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，<br>接收进程从消息缓冲队列中取得消息</li>
<li>图片：随后msg会移动到进程Q的地址空间上<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKq1pj.png" alt="pPKq1pj.png"></li>
</ul>
</li>
</ul>
</li>
<li>间接通信方式<ul>
<li>发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息<br>以“信箱”作为中间实体进行消息传递，广泛运用在计算机网络中</li>
<li>可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息</li>
<li>图片：随后msg会移动到进程Q的地址空间上<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKqB9J.png" alt="pPKqB9J.png"></li>
</ul>
</li>
</ul>
</li>
<li>在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。<br>由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。</li>
</ul>
</li>
<li>管道通信<ul>
<li>“管道”是一个特殊的<strong>共享文件</strong>，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区</li>
<li>写进程向管道的一端写，读进程从管道的另一端读。数据在管道中是先进先出的。</li>
<li>各进程要互斥地访问管道（由操作系统实现）</li>
<li>管道的特征<ul>
<li>从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。<br>普通管道只允许半双工通信，若要实现全双工通信，则需要定义两个管道。</li>
<li>只要管道非空，读进程就能从管道中读出数据，若数据被读空，则读进程阻塞，<br>直到写进程往管道中写入新的数据，再将读进程唤醒</li>
<li>只要管道不满，写进程就能往管道中写入数据，若管道写满，则写进程阻塞，<br>直到读进程读出数据，再将写进程唤醒</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。<br>对此，通常有两种解决方案<ul>
<li><strong>①一个管道允许多个写进程，一个读进程</strong></li>
<li>②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据</li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKLMb6.png" alt="pPKLMb6.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-线程与多线程模型（♚）"><a href="#7-线程与多线程模型（♚）" class="headerlink" title="7.线程与多线程模型（♚）"></a>7.线程与多线程模型（♚）</h4><ul>
<li><p>线程的概念</p>
<ul>
<li><p>线程的基本概念</p>
<ul>
<li><strong>线程可以理解为“轻量级进程”，在引入线程后，线程是一个基本的CPU执行单元，也是程序执行流的最小单位</strong></li>
<li><strong>引入线程后，进程的内涵发生了改变，进程只作为除CPU外的系统资源的分配单元，而线程则作为处理机的分配单元。</strong><br>由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要很少的时空开销。</li>
</ul>
</li>
<li><p>引入线程的目的</p>
<ul>
<li><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量<br><strong>而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p>
</li>
<li><p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，<br>使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPKOUW4.png" alt="pPKOUW4.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程与进程的比较（♚）</p>
<ul>
<li>调度<ul>
<li><strong>在传统的进程机制中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。</strong></li>
<li><strong>在引入线程后，线程是独立调度的基本单位，而线程切换的代价远低于进程。</strong><ul>
<li><strong>此时进程仍然是资源分配的基本单位，而线程不是</strong></li>
</ul>
</li>
<li>在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
</ul>
</li>
<li>并发性<ul>
<li>在传统的进程机制中，只能进程间并发</li>
<li>在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间亦可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统的吞吐量。</li>
</ul>
</li>
<li>拥有资源<ul>
<li><strong>进程是系统中拥有资源的基本单位，而线程不拥有系统资源（仅有一点必不可少、能保证独立运行的资源）</strong><ul>
<li>若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。</li>
</ul>
</li>
<li><strong>线程可以与同属一个进程的其他线程共享进程所拥有的全部资源（可以访问其隶属进程的系统资源），</strong><br><strong>这主要表现在属于同一进程的所有线程都具有相同的地址空间</strong></li>
<li><strong>线程不能共享其他线程的资源</strong></li>
</ul>
</li>
<li>独立性<ul>
<li><strong>每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问</strong>。</li>
<li>某进程中的线程对其他进程不可见。同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。</li>
</ul>
</li>
<li>系统开销<ul>
<li>在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源，如内存空间、I/O设备等<br>而创建线程和撤销线程时所用的开销则较小</li>
<li>传统的进程间实现并发时，需要切换进程的运行环境，涉及进程上下文的切换，系统开销很大，<br>而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。</li>
</ul>
</li>
<li>支持多处理机系统<ul>
<li>对于传统单线程进程，不管有多少处理机，进程只能运行在一个处理机上</li>
<li>对于多线程进程，可以将进程中的多个线程分配到多个处理机上执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>线程的属性</p>
<ul>
<li>线程是处理机的独立调度单位，多个线程是可以并发执行的。<ul>
<li>在单CPU的计算机系统中，各线程可交替地占用CPU</li>
<li>在多CPU的计算机系统中，各线程可同时占用不同的CPU</li>
</ul>
</li>
<li>线程是一个轻型实体，它不拥有系统资源，同一进程中的各个线程共享该进程所拥有的资源<br>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>每个线程都应有一个唯一的标识符和一个线程控制块（TCB），线程控制块记录了线程执行的寄存器和栈等现场状态。</li>
<li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。<ul>
<li>同一进程中的线程切换，不会引起进程切换，不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小，切换进程，系统开销较大</li>
</ul>
</li>
<li>一个线程被创建后，便开始了它的生命周期，直至终止。<br>线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化</li>
</ul>
</li>
</ul>
<h4 id="8-线程的实现方式"><a href="#8-线程的实现方式" class="headerlink" title="8.线程的实现方式"></a>8.线程的实现方式</h4><ul>
<li>用户级线程（ULT）<ul>
<li>用户级线程的特点<ul>
<li><strong>用户级线程由应用程序通过线程库实现</strong>，所有的线程管理工作都由应用程序负责并在用户空间中完成（包括线程切换)<br>应用层序可以通过线程库设计成多线程程序</li>
<li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在</li>
<li><strong>对于设置了用户级线程的系统，其调度仍是以进程为单位进行的，各个进程轮流执行一个时间片</strong></li>
</ul>
</li>
<li>用户级线程的优点（节省开销）<ul>
<li>线程切换在用户空间就可完成，不需要转换到内核空间，节省了模式切换的开销</li>
<li>调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。</li>
<li>用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分</li>
</ul>
</li>
<li>用户级线程的缺点（并发度不高）<ul>
<li>系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞</li>
<li>不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU,因此进程中仅有一个线程能执行。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPMCEeH.png" alt="pPMCEeH.png"></li>
</ul>
</li>
</ul>
</li>
<li>内核级线程（KLT）<ul>
<li>内核级线程的特点<ul>
<li><strong>内核级线程的管理工作由操作系统内核完成。</strong><br><strong>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</strong></li>
<li>操作系统会为每个内核级线程建立相应的TCB(线程控制块)通过TCB对线程进行管理。</li>
<li>“内核级线程”就是“从操作系统内核视角看能看到的线程</li>
</ul>
</li>
<li>内核级线程的优点<ul>
<li>多线程可在多核处理机上并行执行，内核能同时调度同一进程中的多个线程并行执行，</li>
<li>如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线程，并发能力强</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小</li>
<li>内核本身也可采用多线程技术，可以提高系统的执行速度和效率。</li>
</ul>
</li>
<li>内核级线程的缺点<ul>
<li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPMCEeH.png" alt="pPMCEeH.png"></li>
</ul>
</li>
</ul>
</li>
<li>组合方式（多线程模型）<ul>
<li>一对一模型<ul>
<li>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
</li>
<li>多对一模型<ul>
<li>多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程</li>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
<li>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPMPKE9.png" alt="pPMPKE9.png"></li>
</ul>
</li>
</ul>
</li>
<li>多对多模型<ul>
<li>n个用户及线程映射到m个内核级线程(n&gt;=m)。每个用户进程对应m个内核级线程</li>
<li>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）</li>
<li>又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPMPREj.png" alt="pPMPREj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二-处理机调度（✪）"><a href="#二-处理机调度（✪）" class="headerlink" title="二.处理机调度（✪）"></a>二.处理机调度（✪）</h3><h4 id="1-调度的概念"><a href="#1-调度的概念" class="headerlink" title="1.调度的概念"></a>1.调度的概念</h4><ul>
<li>处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法(公平、高效的原则)选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</li>
<li>调度的层次（三级调度）<ul>
<li>高级调度（作业调度）<ul>
<li>内存空间有限，有时无法将用户提交的作业全部由外存放入内存<br>此时按一定的原则<strong>从外存的作业后备队列</strong>中挑选一个作业<strong>调入内存</strong>，分配相关资源并创建进程。</li>
<li>为外存与内存之间的调度，每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</li>
<li>注：作业=一个具体的任务，用户向系统提交一个作业≈用户让操作系统启动一个程序（来处理一个具体的任务）</li>
</ul>
</li>
<li>中级调度（内存调度）<ul>
<li>挂起状态的概念<ul>
<li>内存不够时，可将某些进程调出外存。等内存空闲或者进程需要运行时再重新调入内存。</li>
<li>暂时调到外存等待的进程状态为<strong>挂起态</strong>。被挂起的进程PCB会被组织成挂起队列</li>
</ul>
</li>
<li>按照某种策略决定将哪个处于<strong>挂起状态的进程重新调入内存，此时修改其状态为就绪态，送入就绪队列</strong>。</li>
<li>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li>
<li>中级调度可以提高内存利用率和系统吞吐量</li>
</ul>
</li>
<li>低级调度（进程、处理机调度）<ul>
<li>按照某种策略从就绪队列中选取一个进程，将处理机分配给它</li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
<li>进程调度的频率很高，一般几十毫秒一次。</li>
</ul>
</li>
<li>区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMhyqg.png" alt="pPMhyqg.png"></li>
</ul>
</li>
</ul>
</li>
<li>阻塞挂起与就绪挂起以及七状态模型：<strong>挂起是在外存中等待的状态</strong><ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMhwGt.png" alt="pPMhwGt.png"></li>
</ul>
</li>
</ul>
<h4 id="2-调度的目标"><a href="#2-调度的目标" class="headerlink" title="2.调度的目标"></a>2.调度的目标</h4><ul>
<li>CPU利用率：指CPU“忙碌”的时间占总时间的比例。</li>
<li>系统吞吐量：单位时间内完成作业的数量</li>
<li>周转时间：<strong>是指从作业被提交给系统开始，到作业完成为止的这段时间间隔</strong>。<ul>
<li>包括四个部分（后三项在一个作业的整个处理过程中，可能发生多次<ul>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待I/O操作完成的时间</li>
</ul>
</li>
<li><strong>周转时间=作业完成时间一作业提交时间</strong></li>
<li>平均周转时间=$\large\frac{各作业周转时间之和}{作业数}$</li>
<li><strong>带权周转时间=$\large \frac{作业周转时间}{作业实际运行时间}=\frac{作业完成时间一作业提交时间}{作业实际运行时间}$（一定大于1，越小越好）</strong></li>
<li>平均带权周转时间=$\large \frac{各作业带权周转时间之和}{作业数}$（越小越好）</li>
<li>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高</li>
<li>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</li>
</ul>
</li>
<li>等待时间：指进程/作业处于<strong>等待处理机状态</strong>时间之和，等待时间越长，用户满意度越低。<ul>
<li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，<strong>在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</strong>（<strong>等待时间=周转时间-运行时间-等待I/O操作的时间</strong>）</li>
<li>对于作业来说，不仅要考虑建立进程后的等待时间，<strong>还要加上作业在外存后备队列中等待的时间</strong>。</li>
<li>处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。<br>因此，衡量一个调度算法的优劣，常常只需简单地考察等待时间</li>
</ul>
</li>
<li>响应时间：指从用户提交请求到系统首次产生响应所用的时间。<ul>
<li>在交互式系统中，周转时间不是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一</li>
</ul>
</li>
</ul>
<h4 id="3-调度的实现"><a href="#3-调度的实现" class="headerlink" title="3.调度的实现"></a>3.调度的实现</h4><ul>
<li>进程调度的时机<ul>
<li>需要进行进程调度与切换的情况<ul>
<li>当前运行的进程主动放弃处理机<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞(如等待I/O)</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理(如I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>不能进行进程调度与切换的情况<ul>
<li>在处理中断的过程中：中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li>
<li>进程在操作系统内核程序临界区中（普通的临界区可以进行进程调度）</li>
<li>在原子操作过程中（原语），原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ul>
</li>
</ul>
</li>
<li>进程调度的方式<ul>
<li>非剥夺调度方式，又称非抢占方式<ul>
<li>即只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
<li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
</li>
<li>剥夺调度方式，又称抢占方式。<ul>
<li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。</li>
<li>适合于分时操作系统、实时操作系统</li>
</ul>
</li>
</ul>
</li>
<li>进程的切换与过程<ul>
<li>狭义的进程调度”与“广义的进程调度”的区别<ul>
<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。<br>这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换</li>
<li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</li>
<li>广义的进程调度包含了选择一个进程和进程切换两个步骤</li>
</ul>
</li>
<li>进程切换的过程<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复<br>如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块</li>
</ul>
</li>
<li>进程切换是有代价的，因此如果过于频繁的进行进程调度与切换，必然会使整个系统的效率降低使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</li>
</ul>
</li>
</ul>
<h4 id="4-典型的调度算法（♚）"><a href="#4-典型的调度算法（♚）" class="headerlink" title="4.典型的调度算法（♚）"></a>4.典型的调度算法（♚）</h4><ul>
<li>前三种算法适用于批处理系统，后三种算法适用于交互式系统</li>
<li>先来先服务(FCFS，First Come First Serve)<ul>
<li>算法思想：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子），<strong>考虑的是等待时间</strong></li>
<li>算法规则：<strong>按照作业/进程到达的先后顺序进行服务</strong></li>
<li>可用于作业调度与进程调度<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后备队列</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
</ul>
</li>
<li>是非抢占式的算法</li>
<li>优缺点<ul>
<li>优点：公平、算法实现简单</li>
<li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。<br>FCFS算法对长作业有利，对短作业不利</li>
</ul>
</li>
<li>是否会导致饥饿：不会<br>饥饿：某进程/作业长期得不到服务</li>
<li>有利于CPU繁忙型作业，不利于I/O繁忙型作业</li>
</ul>
</li>
<li>短作业优先(SJF，Shortest Job First)<ul>
<li>算法思想：<strong>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</strong></li>
<li>算法规则<ul>
<li>短作业/进程优先调度算法：<strong>每次调度时选择当前已到达且运行时间最短的作业/进程</strong>。（非抢占式）</li>
<li>最短剩余时间优先算法<ul>
<li><strong>每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，</strong><br><strong>则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</strong>（抢占式）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMHpOP.png" alt="pPMHpOP.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可用于作业和进程调度，用于进程调度时称为短进程优先(SPF，Shortest Process First)算法</li>
<li>SJF和SPF是非抢占式的算法，但也有适用于可抢占式的算法：短剩余时间优先算法(SRTN，Shortest Remaining Time Next)</li>
<li>优点：“最短的”平均等待时间、平均周转时间</li>
<li>缺点：不公平。对短作业有利，对长作业不利。</li>
<li>会产生饥饿现象。</li>
<li><strong>SJF调度算法的平均等待时间、平均周转时间最少</strong></li>
</ul>
</li>
<li>高响应比优先(HRRN，Highest Response Ratio Next)<ul>
<li>算法思想：<strong>要综合考虑作业/进程的等待时间和要求服务的时间</strong><br><strong>满足短作业优先且不会导致饥饿</strong></li>
<li>算法规则<ul>
<li><strong>只有当前运行的程主动放弃CPU时(正常/异常完成，或主动阻塞)，才需要行调度，</strong><br><strong>调度时计算所有就绪进程的响应比，选响应比最高进程上处理机。</strong></li>
<li>响应比=$\large \frac{等待时间+要求服务时间}{要求服务时间}$   (响应比≥1)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMb0uq.png" alt="pPMb0uq.png"></li>
</ul>
</li>
</ul>
</li>
<li>可用于作业调度与进程调度</li>
<li>是非抢占式的算法。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
<li>优点<ul>
<li>综合考虑了等待时间和运行时间（要求服务时间）</li>
<li>等待时间相同时，要求服务时间短的优先(SJF的优点)</li>
<li>要求服务时间相同时，等待时间长的优先(FCFS的优点)</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
<li>不会导致饥饿</li>
</ul>
</li>
<li>时间片轮转调度算法(RR)<ul>
<li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应<br><strong>更注重响应时间，不计算周转时间，适用于分时系统，多个用户能及时干预系统</strong></li>
<li>算法规则<ul>
<li><strong>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，</strong><br><strong>若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMq8MR.png" alt="pPMq8MR.png"></li>
</ul>
</li>
</ul>
</li>
<li>只用于进程调度：只有作业放入内存建立了相应的进程后，才能被分配处理机时间片</li>
<li>属于抢占式的算法：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，回到就绪队列<br><strong>由时钟装置发出时钟中断来通知CPU时间片已到</strong></li>
<li>优点：公平；响应快，适用于分时操作系统</li>
<li>缺点：由于高频率的进程切换，因此有一定开销且不区分任务的紧急程度</li>
<li>不会导致饥饿</li>
<li>时间片的选择<ul>
<li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，<br>则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li>
<li>如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，<br>从而导致实际用于进程执行的时间比例减少。进程调度、切换是有时间代价的(保存、恢复运行环境)</li>
</ul>
</li>
</ul>
</li>
<li>优先级调度算法<ul>
<li>算法思想：随着计算机的发展，特别是<strong>实时操作系统</strong>的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
<li>算法规则<ul>
<li>对于非抢占式的算法：每次调度时选择当前已到达且优先级最高的进程，当前进程主动放弃处理机时发生调度。</li>
<li>对于抢占式的算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。<br>另外，当就绪队列发生改变时也需要检查是会发生抢占。<ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMqxSJ.png" alt="pPMqxSJ.png"></li>
</ul>
</li>
</ul>
</li>
<li>既可用于作业调度，也可用于进程调度，还可用于I/O调度</li>
<li>抢占式、非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可，<br>而抢占式还需在就绪队列变化时，检查是否会发生抢占。</li>
<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
<li>会导致饥饿</li>
<li>关于优先级<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种<ul>
<li>静态优先级：创建进程时确定，之后一直不变</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级</li>
</ul>
</li>
<li>优先级的设置<ul>
<li>系统进程优先级高于用户进程</li>
<li>前台进程优先级高于后台进程（交互型进程&gt;非交互型进程）</li>
<li>I/O型进程(或称I/O繁忙型进程)优先级高于计算型进程(或称CPU繁忙型进程)<ul>
<li>操作系统更偏好I/O型进程，I/O设备（如打印机）的处理速度要比CPU慢得多，<br>因此若将I/O型进程的优先级设置得更高，就更有可能让I/O设备尽早开始工作，</li>
<li>I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程运行则越有可能让I/O设备尽早地投入工作，<br>则资源利用率、系统吞吐量都会得到提升，进而提升系统的整体效率。</li>
</ul>
</li>
</ul>
</li>
<li>采用动态优先级时，何时调整（可以从追求公平、提升资源利用率等角度考虑）<ul>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多级反馈队列调度算法<ul>
<li>算法思想：对其它调度算法的折中权衡，不必事先估计进程的执行时间</li>
<li>算法规则<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
</ul>
</li>
<li>用于进程调度</li>
<li>是抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</li>
<li>优点<ul>
<li>对各类型进程相对公平(FCFS的优点)</li>
<li>每个新到达的进程都可以很快就得到响应(RR的优点)</li>
<li>短进程只用较少的时间就可完成(SPF的优点)</li>
<li>不必实现估计进程的运行时间（避免用户作假）</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程<br>可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级</li>
</ul>
</li>
<li>会导致饥饿</li>
</ul>
</li>
<li>几种进程调度算法的区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/15/pPMv7IP.png" alt="pPMv7IP.png"></li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p>例1，通过画甘特图来求解</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPQ2yiq.png" alt="pPQ2yiq.png"></li>
</ul>
</li>
<li><p>例2，在操作系统中CPU计算和I/O操作可以同时进行</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPQ24eJ.png" alt="pPQ24eJ.png"></li>
</ul>
</li>
<li><p>例3，如果单独说输入设备和输出设备的话，那么这三种设备是可以并行进行的</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPQ2xwd.png" alt="pPQ2xwd.png"></li>
</ul>
</li>
<li><p>例4，关于多级队列的题目</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPQReTs.png" alt="pPQReTs.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三-同步与互斥（✪）"><a href="#三-同步与互斥（✪）" class="headerlink" title="三.同步与互斥（✪）"></a>三.同步与互斥（✪）</h3><h4 id="1-同步与互斥的基本概念"><a href="#1-同步与互斥的基本概念" class="headerlink" title="1.同步与互斥的基本概念"></a>1.同步与互斥的基本概念</h4><ul>
<li><p>进程同步：进程具有异步性的特征。异步性：各并发执行的进程以各自独立的、不可预知的速度向前推进。<br>操作系统要提供“进程同步机制”来解决异步问题</p>
</li>
<li><p>临界资源</p>
<ul>
<li><p>临界资源的概念</p>
<ul>
<li>共享是操作系统的基本特征之一，资源共享的方式分为了同时共享方式和互斥共享方式<br>互斥共享方式指：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li>
<li><strong>临界资源：一个时间段内只允许一个进程使用的资源，属于互斥共享资源</strong></li>
<li>许多物理设备(比如摄像头、打印机)都属于临界资源。共享变量、公用队列、内存缓冲区等都属于临界资源。<br>非共享数据不属于临界资源（私有的），在一段时间内能被并发使用的资源不属于临界资源，如可重入的程序代码</li>
<li>对临界资源的访问，必须互斥地进行。<ul>
<li>互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。</li>
<li>当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li>
<li>例题：此时两个进程内部的线程同享变量x；对于A/B选项，两段代码执行顺序的先后不影响最终的结果，D跨越进程不是；因此选C（执行顺序先后会影响结果）<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPlJvKf.png" alt="pPlJvKf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>临界资源的访问过程</p>
<ul>
<li><p>进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志<br>可理解为“上锁”，以阻止其他进程同时进入临界区</p>
</li>
<li><p><strong>临界区：也可称为临界段，临界区是进程中访问临界资源的代码段</strong></p>
</li>
<li><p>退出区：负责解除正在访问临界资源的标志(可理解为“解锁”)</p>
</li>
<li><p>剩余区：代码中的其它部分</p>
</li>
<li><p><strong>进入区和退出区是负责实现互斥的代码段</strong></p>
</li>
<li><p>代码</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  entry section; <span class="comment">//进入区（上锁）</span></span><br><span class="line">  critical section; <span class="comment">//临界区（访问临界资源）</span></span><br><span class="line">  exit section; <span class="comment">//退出区 （解锁）</span></span><br><span class="line">  remainder section; <span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>同步机制的规则</p>
<ul>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理机，<strong>防止进程忙等待</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2-实现临界区互斥的基本方法"><a href="#2-实现临界区互斥的基本方法" class="headerlink" title="2.实现临界区互斥的基本方法"></a>2.实现临界区互斥的基本方法</h4><ul>
<li><p>软件实现方法</p>
<ul>
<li><p>单标志法（谦让）</p>
<ul>
<li><p>算法思想</p>
<ul>
<li>该算法设置一个公用整型变量，用于指示被允许进入临界区的进程编号，若为0则允许P0进程进入临界区。该算法可确保每次只允许一个进程进入临界区。</li>
<li>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</li>
<li>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</li>
</ul>
</li>
<li><p>代码与运行逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> turn=<span class="number">0</span>; <span class="comment">//turn 表示当前允许进入临界区的进程号，初始值设为0，允许P0进程访问</span></span><br><span class="line"><span class="comment">//P0进程：               //P1进程：     </span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);			<span class="keyword">while</span>(turn!=<span class="number">1</span>);	<span class="comment">//检查，如果不能由自己使用则一直循环等待（只检查，不上锁）	</span></span><br><span class="line">critical section;		critical section;	</span><br><span class="line"><span class="comment">//退出区，此时将使用权转交给另一个进程（相当于在退出区既给另一进程“解锁”，又给自己“上锁”）</span></span><br><span class="line">turn=<span class="number">1</span>;					turn=<span class="number">0</span>;	</span><br><span class="line">remainder section;		remainder section;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法的特点：该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区。<br>若某个进程不再进入临界区，则另一个进程也将无法进入临界区(<strong>违背“空闲让进”</strong>)。这样很容易造成资源利用不充分。</p>
</li>
</ul>
</li>
<li><p>双标志先检查法（表达访问意愿）</p>
<ul>
<li><p>算法思想</p>
<ul>
<li>在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；<br>否则，进程才进入自己的临界区。</li>
<li>为此，设置一个布尔型数组flag，如第i个元素flag[i]为FALSE，表示Pi进程未进入临界区，<br>如为TRUE，表示Pi进程进入临界区</li>
</ul>
</li>
<li><p>代码与运行逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];       <span class="comment">//创建表达意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;		<span class="comment">//刚开始两个进程都没有意愿进入临界区</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">Pi进程：				Pj进程：	</span><br><span class="line"><span class="comment">//在进入区先&quot;检查&quot;后&quot;上锁”</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);		  <span class="keyword">while</span>(flag[i]);<span class="comment">//检查对方是否在访问临界资源,如果在则一直循环等待,</span></span><br><span class="line">flag[i]=TRUE;         flag[j]=TRUE;	<span class="comment">//如果临界资源没有被访问则上锁，表达访问意愿</span></span><br><span class="line">critical section;	  critical section;</span><br><span class="line">flag[i]=FALSE;		  flag[j]=FALSE;   <span class="comment">//访问结束之后开锁</span></span><br><span class="line">remainder section;	  remainder section;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：不用交替进入，可连续使用</p>
</li>
<li><p>缺点：<strong>可能将将会同时访问临界区。违反“忙则等待”原则</strong>。<br>原因在于，进入区的“检查”和“上锁”两个处理<strong>不是一气呵成</strong>的。“检查”后，“上锁”前可能发生进程切换。</p>
</li>
</ul>
</li>
<li><p>双标志后检查法（先斩后奏）</p>
<ul>
<li><p>算法思想：<strong>在前一个算法的基础上实现先上锁再检查，可以确保同一时间内最多只有一个进程访问临界资源</strong></p>
</li>
<li><p>代码与运行逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">P进程：</span><br><span class="line"><span class="comment">//在进入区先“加锁&quot;后“检查”</span></span><br><span class="line">flag[i]=TRUE;   <span class="comment">//要访问临界区时先上锁，表达访问意愿</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);   <span class="comment">//此时再来检查是否临界区被人使用</span></span><br><span class="line">critical section;</span><br><span class="line">flag[i]=FALSE;		<span class="comment">//访问结束之后，开锁</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法的缺点</p>
<ul>
<li>两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态<br>执行while语句，发现对方也要进入临界区时，此时谁也进不了临界区</li>
<li><strong>双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，</strong><br><strong>会因各进程都长期无法访问临界资源而产生“饥饿”现象</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>Peterson算法（结合以上算法的特点）</p>
<ul>
<li><p>算法思想</p>
<ul>
<li>结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）<br>做一个有礼貌的进程</li>
<li>此时最后表示谦让的一方失去主动权，则另外一方将执行</li>
</ul>
</li>
<li><p>代码与运行逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];   <span class="comment">//表示进入临界区意愿的数组，初始值都是false</span></span><br><span class="line"><span class="type">int</span> turn <span class="number">0</span>;    <span class="comment">//turn表示优先让哪个进程进入临界区（表达谦让）</span></span><br><span class="line"><span class="comment">//P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;     <span class="comment">//表示自己想进入临界区</span></span><br><span class="line">turn=<span class="number">1</span>;			 <span class="comment">//主动谦让，给对方优先信号</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>); <span class="comment">//检查对方是否也想使用，如果对方不想使用则自己使用；如果对方想使用且表达了其谦让意愿（最后一次）则自己使用；</span></span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;   <span class="comment">//访问完临界区之后表达自己不想使用了</span></span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程：e</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>); <span class="comment">//只有同时满足对方想要使用且自己是最后的谦让方时，此时才开始等待</span></span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>算法的特点：Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待的原则，</strong><br><strong>但是依然未遵循让权等待的原则（不能进入临界区时还在还在处理机上，造成忙等待）。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬件实现方法</p>
<ul>
<li><p>中断屏蔽方法</p>
<ul>
<li>利用“开/关中断指令”实现，与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，<br>也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况</li>
<li>优点：简单、高效</li>
<li>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程，<br>开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险</li>
</ul>
</li>
<li><p>硬件指令方法</p>
<ul>
<li><p>TestAndSet指令（TSL指令)</p>
<ul>
<li><p>指令思想</p>
<ul>
<li>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</li>
<li>若刚开始Iock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。</li>
<li>若刚开始Iock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，<br>直到当前访问临界区的进程在退出区进行“解锁”。</li>
</ul>
</li>
<li><p>代码逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//布尔型共享变量lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">//true表示已加锁，false表示末加锁</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> old;</span><br><span class="line">oLd=*Lock;     <span class="comment">//old用来存放Lock原来的值</span></span><br><span class="line">*Lock=<span class="literal">true</span>;    <span class="comment">//无论之前是否已加锁，都将Lock设为true</span></span><br><span class="line"><span class="keyword">return</span> old;    <span class="comment">//返回Lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;lock);<span class="comment">// 实现&quot;上锁并&quot;检查&quot;</span></span><br><span class="line">临界区代码段</span><br><span class="line">lock <span class="literal">false</span>;   <span class="comment">//解锁</span></span><br><span class="line">剩余区代码段</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；<strong>适用于多处理机环境</strong></p>
</li>
<li><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，<strong>从而导致“忙等”。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SWAP指令</p>
<ul>
<li><p>指令思想</p>
<ul>
<li>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</li>
<li>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old上），<br>再将上锁标记Iock设置为true，最后检查old</li>
<li>如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</li>
</ul>
</li>
<li><p>代码逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Swap指令的作用是交换两个变量的值</span></span><br><span class="line"><span class="built_in">Swap</span> (<span class="type">bool</span> *a,<span class="type">bool</span> *b)&#123;</span><br><span class="line"><span class="type">bool</span> temp;</span><br><span class="line">temp =*a;</span><br><span class="line">*a=*b;</span><br><span class="line">*b temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">//1ock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old==<span class="literal">true</span>)</span><br><span class="line">	<span class="built_in">Swap</span> (&amp;lock,&amp;old);</span><br><span class="line">临界区代码段，，，</span><br><span class="line">lock <span class="literal">false</span>;</span><br><span class="line">剩余区代码段，，，</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；<strong>适用于多处理机环境</strong></p>
</li>
<li><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，<strong>从而导致“忙等”。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-信号量（♚）"><a href="#3-信号量（♚）" class="headerlink" title="3.信号量（♚）"></a>3.信号量（♚）</h4><ul>
<li><p>信号量的概念</p>
<ul>
<li>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，<br><strong>可以用一个信号量来表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</li>
<li>信号量的分类<ul>
<li>信号量是一个特殊的整型变量，只有初始化和PV操作才能改变其值。通常，信号量分为互斥量和资源量</li>
<li>互斥量的<ul>
<li>初值一般为1，表示临界区只允许一个进程进入，从而实现互斥。</li>
<li>当互斥量等于0时，表示临界区已有一个进程进入，临界区外尚无进程等待</li>
<li><strong>当互斥量小于0时，表示临界区中有一个进程，互斥量的绝对值表示在临界区外等待进入的进程数</strong>。</li>
</ul>
</li>
<li>资源信号量<ul>
<li>初值可以是任意整数，表示可用的资源数</li>
<li><strong>当资源量小于0时，表示所有资源已全部用完，而且还有进程正在等待使用该资源，等待的进程数就是资源量的绝对值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>PV操作的概念<ul>
<li>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，可以满足在进入区，退出区的操作一气呵成，<br>从而很方便的实现了进程互斥、进程同步。</li>
<li>wait(S)原语和signal(S)原语，wait、signal原语常简称为P、V操作，可以分别写为P(S)、V(S)</li>
<li><strong>PV操作是一种低级进程通信原语，由两个不可被中断的过程组成，但不是系统调用命令</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>整型信号量（非重点）</p>
<ul>
<li><p>代码逻辑</p>
<ul>
<li><p>整型信号量被定义为一个用于表示资源数目的整型量S</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;	<span class="comment">//wait原语，相当于“进入区”</span></span><br><span class="line">	<span class="keyword">while</span>(S&lt;=<span class="number">0</span>);  <span class="comment">//如果资源数不够，就一直循环等待</span></span><br><span class="line">	S=S<span class="number">-1</span>;   <span class="comment">//如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)&#123;  <span class="comment">//signal原语，相当于“退出区”</span></span><br><span class="line">	S=S<span class="number">+1</span>;	<span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优点：检查”和“上锁”一气呵成避免了并发、异步导致的问题</p>
</li>
<li><p>存在的问题：不满足<strong>让权等待</strong>原则，会发生“忙等”</p>
</li>
</ul>
</li>
<li><p>记录型信号量（♛）</p>
<ul>
<li><p>记录型信号量的定义以及申请资源和释放资源</p>
</li>
<li><p><strong>P操作中，一定是先S.value—，之后可能需要执行block原语</strong><br><strong>V操作中，一定是先S.value++，之后可能需要执行wakeup原语</strong></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">//剩余资源数，S.value的初值表示系统中某种资源的数目</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;  <span class="comment">//定义等待队列</span></span><br><span class="line">&#125;semaphore;   <span class="comment">//记录型信号量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P操作：wait(s):某进程需要使用资源时 用wait原语申请资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;  </span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">block</span>(S.L); <span class="comment">//如果剩余资源数不够，则使用block原语使进程从运行态进入阻塞态，并把其挂到信号量S的等待队列中（阻塞队列）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//V操作：进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(S.L);  <span class="comment">//释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中一个进程,该进程从阻塞态变为就绪态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>该机制遵循了“让权等待”原则，不会出现“忙等”现象</strong></li>
</ul>
</li>
<li><p>利用信号量实现进程互斥</p>
<ul>
<li><p>过程</p>
<ul>
<li>分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)</li>
<li><strong>设置互斥信号量mutex，初值为1</strong>，（<strong>信号量表示进入临界区的名额</strong>）对不同的临界资源需要设置不同的互斥信号量。</li>
<li><strong>在临界区之前对信号量实行P操作，在临界区之后对信号量实行V操作，P、V操作必须成对出现</strong></li>
</ul>
</li>
<li><p>代码逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//初始化信号量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line"><span class="built_in">P</span>(mutex); <span class="comment">//使用临界资源前需要加锁，信号量减一表示占用了一个名额</span></span><br><span class="line">临界区代码段,,,</span><br><span class="line"><span class="built_in">V</span>(mutex);<span class="comment">//使用临界资源后需要解锁，信号量加一表示归还了一个名额，若此时信号量小于等于零，则将阻塞队列中的进程唤醒进入就绪队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line"><span class="built_in">P</span>(mutex);<span class="comment">//在没有访问临界区的名额时，此时将进入阻塞态（信号量减一后小于0则会触发阻塞）</span></span><br><span class="line">临界区代码段,,,</span><br><span class="line"><span class="built_in">V</span>(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>利用信号量实现同步</p>
<ul>
<li><p>过程</p>
<ul>
<li>进程同步问题是让本来异步并发的进程互相配合，有序推进。<br>需要分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作</li>
<li><strong>设置同步信号量S，初始为0</strong>，信号量S代表“某种资源”，刚开始是没有这种资源的。<br>P2需要使用这种资源，而又只能由P1产生这种资源</li>
<li><strong>在“前操作”之后执行V(S)，在“后操作”之前执行P(S)，前V后P</strong></li>
</ul>
</li>
<li><p>代码逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">semaphore S=<span class="number">0</span>;<span class="comment">//初始化同步信号量，初始值为0</span></span><br><span class="line"><span class="comment">//此时可以保证代码4一定在代码2之后执行</span></span><br><span class="line"><span class="built_in">P1</span>()&#123; 			<span class="built_in">P2</span>()&#123;		</span><br><span class="line">代码<span class="number">1</span>;		   <span class="built_in">P</span>(S);<span class="comment">//如果不按照顺序来执行的话，此时信号量减一后将会由于信号量小于等于0而被阻塞</span></span><br><span class="line">代码<span class="number">2</span>;		   代码<span class="number">4</span>;</span><br><span class="line"><span class="built_in">V</span>(S);			&#125;</span><br><span class="line"><span class="comment">//执行完V操作之后，信号量才能由0变为1</span></span><br><span class="line"><span class="comment">//如果执行完V操作之后，发现信号量小于等于0，说明已经有进程尝试先发运行，则通过唤醒原语将被阻塞的进程变为就绪态</span></span><br><span class="line">代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>利用信号量实现前驱关系</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPlpR5n.png" alt="pPlpR5n.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-管程"><a href="#4-管程" class="headerlink" title="4.管程"></a>4.管程</h4><ul>
<li>引入管程的目的：解决信号量机制编程麻烦，易出错的问题</li>
<li>管程是由编程语言支持的进程同步机制</li>
<li>管程的组成<ul>
<li>局部于管程的<strong>共享数据结构</strong>说明</li>
<li>对该数据结构进行操作的<strong>一组过程（函数）</strong></li>
<li>对局部于管程的共享数据<strong>设置初始值</strong>的语句</li>
</ul>
</li>
<li>基本特征<ul>
<li><strong>局部于管程的数据只能被局部于管程的过程所访问</strong></li>
<li><strong>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</strong></li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li>
</ul>
</li>
<li>补充<ul>
<li>管程是被进程调用的，管程是语法范围，无法创建和撤销</li>
<li><strong>各进程必须互斥访问管程的特性是由编译器实现的</strong></li>
<li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题</li>
</ul>
</li>
</ul>
<h4 id="5-经典同步问题（♚）"><a href="#5-经典同步问题（♚）" class="headerlink" title="5.经典同步问题（♚）"></a>5.经典同步问题（♚）</h4><ul>
<li><p>生产者-消费者问题</p>
<ul>
<li><p>问题分析</p>
<ul>
<li>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，<br>消费者进程每次从缓冲区中取出一个产品并使用。(注：这里的“产品”理解为某种数据)</li>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区。<br>缓冲区是临界资源，各进程必须互斥地访问</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</li>
</ul>
</li>
<li><p>代码逻辑</p>
<ul>
<li><p>实现互斥是在同一进程中进行PV操作</p>
</li>
<li><p>实现两进程的同步关系，是在其中一个进程中执行P，另外一个进程中执行V（一前一后，前V后P）</p>
</li>
<li><p>相关信号量设置</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">semaphore mutex <span class="number">1</span>;</span><br><span class="line"><span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty n;</span><br><span class="line"><span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full <span class="number">0</span>;</span><br><span class="line"><span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        <span class="built_in">P</span>(empty); <span class="comment">//消耗一个空闲缓冲区</span></span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(pull);   <span class="comment">//增加一个产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">consumer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(full); <span class="comment">//消耗一个产品</span></span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(empty);   <span class="comment">//增加一个空闲缓冲区</span></span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>相关的注意事项</p>
<ul>
<li>实现互斥的P操作一定要在实现同步的P操作之后，如果互换位置，出现“死锁”。</li>
<li>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</li>
</ul>
</li>
<li><p>PV操作题目的解题思路</p>
<ul>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li>
<li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。<br>互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少</li>
</ul>
</li>
</ul>
</li>
<li><p>多生产者-多消费者问题</p>
<ul>
<li><p>问题描述</p>
<ul>
<li>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，<br>儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。</li>
<li>只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。</li>
<li>仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</li>
</ul>
</li>
<li><p>问题分析</p>
<ul>
<li>互斥关系(mutex=1)：对缓冲区（盘子）的访问要互斥地进行</li>
<li>同步关系（一前一后）<ul>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果<br>“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPlZ0oT.png" alt="pPlZ0oT.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码逻辑</p>
<ul>
<li><p>信号量设置</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;	<span class="comment">//实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple=<span class="number">0</span>;	<span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange=<span class="number">0</span>;	<span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate=<span class="number">1</span>;  <span class="comment">//盘子中还可以放多少个水果（缓冲区最多一个）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dad</span>()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	准备一个苹果；</span><br><span class="line">	<span class="built_in">P</span>(plate);  <span class="comment">//消耗盘子的一个空位</span></span><br><span class="line">	<span class="built_in">P</span>(mutex);</span><br><span class="line">	把苹果放入盘子；</span><br><span class="line">	<span class="built_in">V</span>(mutex);</span><br><span class="line">	<span class="built_in">V</span>(apple);	<span class="comment">//生产一个苹果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mom</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    准备一个橘子；</span><br><span class="line">	<span class="built_in">P</span>(plate); <span class="comment">//消耗盘子的一个空位</span></span><br><span class="line">	<span class="built_in">P</span>(mutex);</span><br><span class="line">	把橘子放入盘子；</span><br><span class="line">	<span class="built_in">V</span>(mutex);</span><br><span class="line">	<span class="built_in">V</span>(orange);  <span class="comment">//生产一个橘子</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 消费者逻辑

  <figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">daughter</span>()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">P</span>(apple);  <span class="comment">//消耗一个苹果</span></span><br><span class="line">	<span class="built_in">P</span>(mutex);</span><br><span class="line">	从盘中取出苹果；</span><br><span class="line">	<span class="built_in">V</span>(mutex);</span><br><span class="line">	<span class="built_in">V</span>(plate);   <span class="comment">//释放一个空位</span></span><br><span class="line">	吃掉苹果；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">P</span>(orange);  <span class="comment">//消耗一个橘子</span></span><br><span class="line">  <span class="built_in">P</span>(mutex);</span><br><span class="line">  从盘中取出橘子;</span><br><span class="line">  <span class="built_in">V</span>(mutex);</span><br><span class="line">  <span class="built_in">V</span>(plate);	 <span class="comment">//释放一个空位</span></span><br><span class="line">  吃掉橘子;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>相关的注意事项</p>
<ul>
<li>即使不设置专门的互斥变量mutex,也不会出现多个进程同时访问盘子的现象</li>
<li>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能</li>
</ul>
</li>
</ul>
<ul>
<li><p>吸烟者问题</p>
<ul>
<li><p>问题描述</p>
<ul>
<li>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。<br>三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。</li>
<li>供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（<strong>让三个吸烟者轮流吸烟</strong>）</li>
</ul>
</li>
<li><p>问题分析</p>
<ul>
<li>属于可生产多种产品的单生产者-多消费者问题</li>
<li>互斥关系：互斥的访问桌子（容量为1的缓冲空间）</li>
<li>同步关系<ul>
<li>桌上有组合一→第一个抽烟者取走东西</li>
<li>桌上有组合二→第二个抽烟者取走东西</li>
<li>桌上有组合三→第三个抽烟者取走东西</li>
<li>发出完成信号→供应者将下一个组合放到桌上</li>
</ul>
</li>
<li>由于缓冲区大小为1，同一时刻四个同步信号量中至多有一个的值为1<br>因此不需要设置互斥的信号量</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/16/pPle1n1.png" alt="pPle1n1.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码逻辑</p>
<ul>
<li><p>信号量设置</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">semaphore offerl=<span class="number">0</span>  <span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2=<span class="number">0</span>; <span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3=<span class="number">0</span>  <span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish=<span class="number">0</span>; <span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>; <span class="comment">//用于实现三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">provider</span>()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">  	  将组合一放桌上;</span><br><span class="line">	  <span class="built_in">V</span>(offer1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">	  将组合二放桌上;</span><br><span class="line">	  <span class="built_in">V</span>(offer2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">	  将组合三放桌上;</span><br><span class="line">	  <span class="built_in">V</span>(offer3);</span><br><span class="line">    &#125;</span><br><span class="line">    i=(i<span class="number">+1</span>)%<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">P</span>(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">smoker1</span>()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">P</span>(offer1);</span><br><span class="line">	从桌上拿走组合一;卷烟抽掉;</span><br><span class="line">	<span class="built_in">V</span>(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>读者-写者问题</p>
<ul>
<li><p>问题描述</p>
<ul>
<li>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，<br>但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</li>
<li>①允许多个读者可以同时对文件执行读操作</li>
<li>②只允许一个写者往文件中写信息</li>
<li>③任一写者在完成写操作之前不允许其他读者或写者工作</li>
<li>④写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
</li>
<li><p>问题分析</p>
<ul>
<li>两类进程：写进程、读进程</li>
<li>互斥关系：写进程一写进程、写进程一读进程。<br>读进程与读进程不存在互斥问题。</li>
</ul>
</li>
<li><p>代码逻辑</p>
<ul>
<li><p>信号量设置</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;  <span class="comment">//用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;   <span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex=l;<span class="comment">//用于保证对count变量的互斥访问</span></span><br><span class="line"><span class="comment">//count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对count的访问是互斥的</span></span><br><span class="line">semaphore w=<span class="number">1</span>;<span class="comment">//用于实现“写优先”,可以避免由于读者连续访问而导致的写者的饥饿</span></span><br><span class="line"><span class="comment">//读者1→写者1→读者2,出现此类访问时，可以将文件访问权转移给写者</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">writer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">p</span>(w);   <span class="comment">//实现写优先</span></span><br><span class="line">        <span class="built_in">p</span>(rw);   <span class="comment">//写之前加锁</span></span><br><span class="line">        写文件;</span><br><span class="line">        <span class="built_in">V</span>(rw);	<span class="comment">//写之后解锁</span></span><br><span class="line">        <span class="built_in">V</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读者逻辑</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reader</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">p</span>(w);        <span class="comment">//实现写优先</span></span><br><span class="line">        <span class="built_in">p</span>(mutex);    <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">//由第一个读进程负责控制与写进程的互斥访问的加锁工作</span></span><br><span class="line">            <span class="built_in">p</span>(rw);	 <span class="comment">//读之前加锁</span></span><br><span class="line">        count++;	 <span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);  </span><br><span class="line">        <span class="built_in">V</span>(w);</span><br><span class="line">        读文件;</span><br><span class="line">        <span class="built_in">P</span>(mutex);   <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">        count--;	<span class="comment">//访问文件的读进程数-1</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="comment">//由最后一个读进程负责控制与与写进程的互斥访问的解锁工作</span></span><br><span class="line">            <span class="built_in">V</span>(rw);   <span class="comment">//当前没有读文件访问文件后才解锁</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。<br>可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理，从而实现写者与读者互斥访问，但是读者间不互斥访问</li>
<li>对count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量</li>
<li>最后，还要认真体会如何解决“写进程饥饿”问题的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四-死锁（✪）"><a href="#四-死锁（✪）" class="headerlink" title="四.死锁（✪）"></a>四.死锁（✪）</h3><h4 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1.死锁的概念"></a>1.死锁的概念</h4><ul>
<li>死锁、饥饿与死循环<ul>
<li>死锁：<strong>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong><br><strong>发生死锁后若无外力干涉，这些进程都将无法向前推进</strong></li>
<li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。<br>比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</li>
<li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</li>
<li>三者的区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pPlyeLd.png" alt="pPlyeLd.png"></li>
</ul>
</li>
</ul>
</li>
<li>死锁产生的必要条件<ul>
<li><strong>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生</strong>。</li>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁 (如哲学家的筷子、打印机设备)<br>像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：<strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，</strong><br><strong>此时请求进程被阻塞，但又对自己己有的资源保持不放。只需要一个资源的进程不会进入死锁</strong></li>
<li>循环等待条件：<strong>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</strong><br><strong>死锁发生至少有两个进程</strong><ul>
<li><strong>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong></li>
<li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁</li>
<li>但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</li>
</ul>
</li>
</ul>
</li>
<li>死锁产生的原因（对不可剥夺资源的不合理分配，可能导致死锁）<ul>
<li>对系统资源的竞争<ul>
<li>各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li>
</ul>
</li>
<li>进程推进顺序非法，请求和释放资源的顺序不当，也同样会导致死锁。<ul>
<li>如并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1<br>两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
</ul>
</li>
<li>信号量的使用不当也会造成死锁。<ul>
<li>如生产者消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。<br>可以把互斥信号量、同步信号量也看做是一种抽象的系统资源</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁的处理策略</p>
<ul>
<li><p>不允许死锁发生</p>
<ul>
<li>静态策略：预防死锁，破坏死锁产生的四个必要条件中的一个或几个。</li>
<li>动态策略：避免死锁，用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
</ul>
</li>
<li><p>允许死锁发生</p>
<ul>
<li>死锁的检测和解除，允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ul>
</li>
<li><p>预防死锁和避免死锁都属于事先预防策略，预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低，<br>避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p>
</li>
</ul>
</li>
<li><p>例题（✪）</p>
<ul>
<li><p><strong>重要定则：n个进程，每个进程需要k个资源，则当总资源数至少为$n(k-1)+1$时，不会发生死锁</strong></p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pP1FwsP.png" alt="pP1FwsP.png"></li>
</ul>
</li>
<li><p>例2，本题即为各自需要的资源数-1之和再加一：2+3+4+1=10</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pP1F5ZT.png" alt="pP1F5ZT.png"></li>
</ul>
</li>
<li><p>例3，此时结合题目来看，算出至少得资源数为3*(2-1)+1=4，此时所拥有的资源数刚好满足，不会发生死锁</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pP1kAyt.png" alt="pP1kAyt.png"></li>
</ul>
</li>
<li><p>例4，本题选C，此时为循环等待的经典例子</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pP1A89H.png" alt="pP1A89H.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-死锁的预防"><a href="#2-死锁的预防" class="headerlink" title="2.死锁的预防"></a>2.死锁的预防</h4><ul>
<li>破坏互斥条件（无法破坏）<ul>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。<br>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</li>
<li>操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备</li>
<li>缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。</li>
</ul>
</li>
<li>破坏不剥夺条件<ul>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>方案一：<strong>当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。</strong><br>即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li>
<li>方案二：<strong>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。</strong><br>这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li>
<li>策略的缺点<ul>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU.</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li>
<li><strong>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。</strong><br><strong>如果一直发生这样的情况，就会导致进程饥饿。</strong></li>
</ul>
</li>
</ul>
</li>
<li>破坏请求和保持条件<ul>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，<br>此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>可以采用静态分配方法，<strong>即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行</strong>。<br>一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</li>
<li>该策略的缺点<ul>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。</li>
<li>该策略也有可能导致某些进程饥饿</li>
</ul>
</li>
</ul>
</li>
<li><p>破坏循环等待条件</p>
<ul>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
<li>可采用顺序资源分配法。首先<strong>给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完，<strong>限制用户申请资源的顺序</strong></li>
<li><p>原理分析</p>
<ul>
<li>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。<br>按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</li>
<li>在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。<br>不可能出现所有进程都阻塞的死锁现象</li>
</ul>
</li>
<li><p>该策略的缺点</p>
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户编程麻烦。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-死锁避免（♚）"><a href="#3-死锁避免（♚）" class="headerlink" title="3.死锁避免（♚）"></a>3.死锁避免（♚）</h4><ul>
<li>安全序列与安全状态<ul>
<li><strong>安全序列是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，安全序列可能有多个</strong>。</li>
<li><strong>只要能找出一个安全序列，系统就是安全状态。如果分配了资源之后，系统中找不出任何一个安全序列，</strong><br><strong>系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。</strong></li>
<li>当如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过在分配资源之前总是要考虑到最坏的情况。</li>
</ul>
</li>
<li>安全状态与死锁的联系<ul>
<li><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁</strong><br><strong>处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态</strong></li>
<li>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。<br>这也是“银行家算法”的核心思想。</li>
</ul>
</li>
<li>银行家算法<ul>
<li>核心思想（避免系统进入不安全状态）<ul>
<li>在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，若有则先进行试分配，并对分配后的新状态进行安全性检查。</li>
<li><strong>在试分配时，利用安全性算法判断此次分配是否会导致系统进入不安全状态。<br>若新状态安全，则正式分配上述资源，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</strong></li>
<li><strong>银行家算法只能避免系统进入死锁，不能用于判断系统是否处于死锁</strong></li>
</ul>
</li>
<li>银行家算法手算规则（核心是找到安全序列）<ul>
<li>首先可以找到P1,P3满足当前剩余分配的资源，可以顺利分配并回收资源，此时将P1/P3加入安全序列<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pPlolY4.png" alt="pPlolY4.png"></li>
</ul>
</li>
<li>回收之后，即可以满足所有的需求，此时得出安全序列，说明处于安全状态，不会发生死锁<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pPlo4hQ.png" alt="pPlo4hQ.png"></li>
</ul>
</li>
</ul>
</li>
<li>银行家算法的数据结构描述（系统中有n个进程,m种资源）<ul>
<li>可利用资源向量Available<ul>
<li>含有m个元素的数组，其中每个元素代表一类可用的资源数目。$Available[j]=K$表示系统中现有$R_j$类资源$K$个</li>
</ul>
</li>
<li>最大需求矩阵Max<ul>
<li>n×m矩阵，定义系统中n个进程中的每个进程对m类资源的最大需求。</li>
<li>一行代表一个进程，一列代表一类资源，$Max[i,j]=K$表示进程$i$需要$R_j$类资源的最大数目为K.</li>
</ul>
</li>
<li>分配矩阵Allocation<ul>
<li>n×m矩阵，定义系统中每类资源当前已分配给每个进程的资源数。</li>
<li>$Allocation[i,j]=K$表示进程$i$当前已分得$R_j$类资源的数目为K。</li>
</ul>
</li>
<li>需求矩阵Need<ul>
<li>n×m矩阵，表示每个进程接下来最多还需要多少资源。</li>
<li>$Need[i,j]=K$表示进程$i$还需要$R_j$类资源的数目为K.</li>
</ul>
</li>
<li>上述三个矩阵间存在下述关系：$Need=Max-Allocation$</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pPl7dRH.png" alt="pPl7dRH.png"></li>
</ul>
</li>
</ul>
</li>
<li>银行家算法步骤（给出一个请求：Request）<ul>
<li>检查此次申请是否超过了之前声明的最大需求数（Need）</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求（Available）</li>
<li>试探着分配，更改各数据结构<ul>
<li>Available=Available-Request</li>
<li>Allocation=Allocation+Request</li>
<li>Need=Need-Request</li>
</ul>
</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态，若安全，才正式分配<br>否则，恢复相应数据，让进程阻塞等待。</li>
</ul>
</li>
<li>安全性算法步骤<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，<br>并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-死锁检测与解除"><a href="#4-死锁检测与解除" class="headerlink" title="4.死锁检测与解除"></a>4.死锁检测与解除</h4><ul>
<li><p><strong>在死锁的检测和解除中，系统为进程分配资源时不采取任何措施，但提供死锁的检测和解除手段</strong></p>
</li>
<li><p>死锁检测</p>
<ul>
<li>检测死锁的方法<ul>
<li>用某种数据结构来保存资源的请求和分配信息</li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li>
</ul>
</li>
<li>资源分配图<ul>
<li>用圆圈代表一个进程，用框代表一类资源</li>
<li>由于一种类型的资源可能有多个，因此用框中的一个圆代表一类资源中的一个资源。</li>
<li>从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源；</li>
<li>从资源到进程的边称为分配边，表示该类资源已有一个资源分配给了该进程</li>
<li>图片<ul>
<li>进程P1已经分得了两个R1资源，并又请求一个R2资源；<br>进程P2分得了一个R1资源和一个R2资源，并又请求一个R1资源</li>
<li><img src="https://s1.ax1x.com/2023/08/17/pPlqedP.png" alt="pPlqedP.png"></li>
</ul>
</li>
</ul>
</li>
<li>死锁检测算法<ul>
<li>在资源分配图中，找出既不阻塞又不是孤点的进程P<br>即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有空闲资源数量（资源数量-出度）</li>
<li>若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源<br>消去它所有的请求边和分配边，使之称为孤立的结点。</li>
<li>进程P所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。<br>进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li>
<li><strong>如果最终不能消除所有边，那么此时就是发生了死锁，最终还连着边的那些进程就是处于死锁状态的进程</strong><br><strong>资源分配图是不可完全简化的，称为死锁定理</strong></li>
<li><strong>死锁的充分必要条件是每种资源只有一个，并出现环路</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/17/pPlqqFf.png" alt="pPlqqFf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>死锁解除<ul>
<li>资源剥夺法：挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。<br>但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）<ul>
<li>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大<br>因为有些进程可能己经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
</ul>
</li>
<li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第一章-计算机系统概述</title>
    <url>/2024/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="操作系统第一章-计算机系统概述"><a href="#操作系统第一章-计算机系统概述" class="headerlink" title="操作系统第一章 计算机系统概述"></a>操作系统第一章 计算机系统概述</h2><blockquote>
<p>计算机学科基础：操作系统第一章计算机系统概述的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-操作系统的基本概念（✠）"><a href="#一-操作系统的基本概念（✠）" class="headerlink" title="一.操作系统的基本概念（✠）"></a>一.操作系统的基本概念（✠）</h3><h4 id="1-操作系统的基本概念"><a href="#1-操作系统的基本概念" class="headerlink" title="1.操作系统的基本概念"></a>1.操作系统的基本概念</h4><ul>
<li>操作系统是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，<br>进而为用户和其他软件提供方便接口与环境的程序集合。</li>
<li>操作系统是计算机系统中最基本的系统软件。</li>
</ul>
<h4 id="2-操作系统的特征（✪）"><a href="#2-操作系统的特征（✪）" class="headerlink" title="2.操作系统的特征（✪）"></a>2.操作系统的特征（✪）</h4><ul>
<li>1.并发<ul>
<li>并发是指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的</li>
<li>并行：指两个或多个事件在同一时刻同时发生。</li>
<li>操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。<br>在操作系统中，引入进程的目的是使程序能并发执行。</li>
<li>多道技术需要进程间能够并发，并发性的实现需要中断功能的支持</li>
<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行<br>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>
</ul>
</li>
<li>2.共享<ul>
<li>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</li>
<li>资源共享的两种方式<ul>
<li>互斥共享方式<ul>
<li>规定在一段时间内只允许一个进程访问该资源。</li>
<li>在一段时间内只允许一个进程访问的资源称为临界资源</li>
<li>访问资源过程（互斥式共享）<ul>
<li>进程A访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程A使用，</li>
<li>此后有其他进程也要访问该资源时(只要A未用完)就必须等待。</li>
<li>仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。</li>
</ul>
</li>
</ul>
</li>
<li>同时访问方式<ul>
<li>这类资源允许在一段时间内由多个进程“同时”访问，如磁盘设备。</li>
<li>“同时”通常是宏观上的，<br>而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。</li>
</ul>
</li>
</ul>
</li>
<li><strong>并发和共享是操作系统的两个最基本的特征，两者之间互为存在的条件</strong></li>
</ul>
</li>
<li>3.虚拟<ul>
<li>虚拟是指把一个物理上的实体变为若干逻辑上的对应物，<br>物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</li>
<li>虚拟技术<ul>
<li>时分复用技术（虚拟处理器）<ul>
<li>通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器</li>
<li>虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器在专门为它服务。</li>
<li>利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</li>
</ul>
</li>
<li>空分复用技术（虚拟存储器）<ul>
<li>将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>4.异步<ul>
<li>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，<br>它以不可预知的速度向前推进，这就是进程的异步性。</li>
<li>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误<br>但是只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</li>
</ul>
</li>
</ul>
<h4 id="3-操作系统的目标与功能"><a href="#3-操作系统的目标与功能" class="headerlink" title="3.操作系统的目标与功能"></a>3.操作系统的目标与功能</h4><ul>
<li>操作系统作为计算机系统资源的管理者<ul>
<li>处理机管理<ul>
<li>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，<br>因而对处理机的管理可归结为对进程的管理。</li>
<li>并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。</li>
<li>进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</li>
</ul>
</li>
<li>存储器管理<ul>
<li>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率</li>
<li>主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</li>
</ul>
</li>
<li>文件管理<ul>
<li>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。</li>
<li>文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</li>
</ul>
</li>
<li>设备管理<ul>
<li>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，</li>
<li>主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</li>
</ul>
</li>
</ul>
</li>
<li>操作系统提供给用户和其他软件方便的接口和环境<br>向上层提供方便易用的服务<ul>
<li>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统提供了用户接口，分为两类。</li>
<li>命令接口（直接给用户使用）<ul>
<li>用户利用这些操作命令来组织和控制作业的执行</li>
<li>联机命令接口（强调交换性，说一句做一句）<ul>
<li><strong>又称交互式命令接口</strong>，适用于分时或实时系统的接口，由一组键盘操作命令组成。</li>
<li>用户通过控制台或终端输入操作命令，向系统提出各种服务要求。</li>
<li>用户每输入一条命令，控制权就转给操作系统的命令解释程序，<br>然后由命令解释程序解释并执行输入的命令，完成指定的功能</li>
<li>之后，控制权转回控制台或终端，此时用户又可输入下一条命令</li>
</ul>
</li>
<li>脱机命令接口（说一堆做一堆）<ul>
<li><strong>又称批处理命令接口</strong>，适用于批处理系统，它由一组作业控制命令组成。</li>
<li>脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，<br>连同作业一起提交给系统。</li>
<li>系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行</li>
</ul>
</li>
</ul>
</li>
<li><strong>程序接口（也称系统调用，给软件和程序员使用）</strong><ul>
<li><strong>程序接口由一组系统调用（也称广义指令）组成</strong>。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务<br>如使用各种外部设备、申请分配和回收内存及其他各种要求。</li>
<li>当前最为流行的是图形用户界面(GUI)，即图形接口。GUI最终是通过调用程序接口实现的<br>严格来说，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。</li>
</ul>
</li>
</ul>
</li>
<li>操作系统实现了对计算机资源的扩充<ul>
<li>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，<br>而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。</li>
<li>操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器</li>
<li>因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机</li>
</ul>
</li>
</ul>
<h3 id="二-操作系统的发展历程"><a href="#二-操作系统的发展历程" class="headerlink" title="二.操作系统的发展历程"></a>二.操作系统的发展历程</h3><h4 id="1-批处理阶段（操作系统开始出现：多道）"><a href="#1-批处理阶段（操作系统开始出现：多道）" class="headerlink" title="1.批处理阶段（操作系统开始出现：多道）"></a>1.批处理阶段（操作系统开始出现：多道）</h4><ul>
<li>单道批处理系统<ul>
<li>每次主机内存中仅存放一道作业，每当它在运行期间发出输入/输出请求后<br>高速的CPU便处于等待低速的I/O完成的状态。</li>
<li>资源的利用率和系统的吞吐量太低</li>
</ul>
</li>
<li>多道批处理系统（具有并发和并行的特点）<ul>
<li>多道程序设计技术（多道，宏观上并行，微观上串行）<ul>
<li><strong>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行（并发）</strong><br><strong>这些程序共享系统中的各种硬/软件资源，需要实现对共享资源的保护</strong></li>
<li>当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序</li>
</ul>
</li>
<li><strong>中断技术使得I/O设备可以与CPU并行工作，I/O设备利用率高</strong></li>
<li>优点：资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用<br>系统吞吐量大，CPU和其他资源保持“忙碌”状态</li>
<li>缺点：<strong>用户响应的时间较长，不提供人机交互能力</strong><br>用户既不能了解自己的程序的运行情况，又不能控制计算机。</li>
</ul>
</li>
</ul>
<h4 id="2-分时操作系统"><a href="#2-分时操作系统" class="headerlink" title="2.分时操作系统"></a>2.分时操作系统</h4><ul>
<li>分时操作系统的概述<ul>
<li>分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</li>
<li>若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行<br>把处理器让给其他作业使用，等待下一轮再继续运行。</li>
<li>由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。<br>可以及时响应用户</li>
</ul>
</li>
<li>分时操作系统的特点<ul>
<li>分时系统也是支持多道程序设计的系统，用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。</li>
<li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li>
<li>缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，<br>循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</li>
</ul>
</li>
</ul>
<h4 id="3-实时操作系统"><a href="#3-实时操作系统" class="headerlink" title="3.实时操作系统"></a>3.实时操作系统</h4><ul>
<li><p>实时操作系统的特点</p>
<ul>
<li><p>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。</p>
</li>
<li><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，<br>并在严格的时限内处理完接收的事件</p>
</li>
<li><p><strong>实时操作系统的主要特点是及时性和可靠性</strong>。</p>
</li>
</ul>
</li>
<li><p>实时操作系统的分类</p>
<ul>
<li><p>硬实时系统</p>
<ul>
<li>某个动作必须绝对地在规定的时刻（或规定的时间范围）发生的系统<br>自动控制系统，导弹发射系统</li>
</ul>
</li>
<li><p>软实时系统</p>
<ul>
<li>若能够接受偶尔违反时间规定且不会引起任何永久性的损害<br>如飞机订票系统、银行管理系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三-操作系统运行环境（✪）"><a href="#三-操作系统运行环境（✪）" class="headerlink" title="三.操作系统运行环境（✪）"></a>三.操作系统运行环境（✪）</h3><h4 id="1-操作系统运行的机制（✠）"><a href="#1-操作系统运行的机制（✠）" class="headerlink" title="1.操作系统运行的机制（✠）"></a>1.操作系统运行的机制（✠）</h4><ul>
<li><p>内核程序与应用程序</p>
<ul>
<li>通常CPU执行两种不同性质的程序，一种是操作系统内核程序，另一种是用户自编程序(即应用程序)</li>
<li>对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此内核程序要执行一些特权指令<br>而应用程序出于安全考虑不能执行这些指令。</li>
<li>由很多内核程序组成操作系统内核（Kernel）</li>
</ul>
</li>
<li><p>特权指令与非特权指令</p>
<ul>
<li><p>指令是指CPU能识别、执行的最基本指令，指二进制机器指令</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP39jFH.png" alt="pP39jFH.png"></li>
</ul>
</li>
<li><p>特权指令</p>
<ul>
<li>是指不允许用户直接使用的指令，只能由操作系统内核来使用</li>
<li>如I/O指令、置中断指令，内存清零等指令</li>
<li>核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令</li>
</ul>
</li>
<li><p>非特权指令</p>
<ul>
<li>是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，<br>这也是为了防止用户程序对系统造成破坏。如加减法指令</li>
</ul>
</li>
</ul>
</li>
<li><p>用户态与核心态</p>
<ul>
<li>用户态与内核态的概念<ul>
<li>将CPU的运行模式划分为用户态（目态）和核心态  (又称管态、内核态)</li>
<li>用户态上运行应用程序，只能执行非特权指令<br>操作系统内核程序运行在核心态，可以执行特权指令，也可以执行非特权指令</li>
<li>CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态”</li>
</ul>
</li>
<li>用户态与核心态之间的转换<ul>
<li>用户态→核心态：<strong>由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</strong><br><strong>但凡需要操作系统介入的地方，都会引发中断</strong>（此前在用户态中可能发生了系统调用，使用了访管指令）</li>
<li>核心态→用户态：<strong>执行一条特权指令（一般是中断返回指令），修改PSW的标志位为“用户态”，</strong><br><strong>这个动作意味着操作系统将主动让出CPU使用权</strong></li>
<li>操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</li>
</ul>
</li>
<li>在操作系统中由用户态转变为核心态的例子<ul>
<li>用户程序要求操作系统的服务，即系统调用。</li>
<li>发生$1$次中断。</li>
<li>用户程序中产生了一个错误状态。</li>
<li>用户程序中企图执行一条特权指令。</li>
</ul>
</li>
<li><strong>只能在核心态下运行的指令是：置时钟指令、广义指令（系统调用）、输入输出、中断指令</strong></li>
<li><strong>可以在用户态下运行的指令是：读时钟、取数、寄存器清零</strong></li>
</ul>
</li>
<li><p>操作系统的内核（✪）</p>
<ul>
<li><p>内核的定义</p>
<ul>
<li>内核是计算机上配置的底层<strong>软件</strong>，它管理着系统的各种资源，可以看作是连接应用程序和硬件的一座桥梁<br>是操作系统最基本最核心的部分</li>
</ul>
</li>
<li><p>内核的构成（内核中的指令操作工作在核心态）</p>
<ul>
<li><p>与硬件关系紧密的模块</p>
<ul>
<li><p>时钟管理：实现计时功能</p>
</li>
<li><p>中断机制：通过时钟与中断的管理，可以实现进程的切换<br><strong>现代操作系统是靠中断驱动的软件</strong></p>
</li>
<li><p>原语（一种特殊的程序）</p>
<ul>
<li><p>原语的概述</p>
<ul>
<li>处于操作系统的最底层，是最接近硬件的部分。</li>
<li><strong>这些程序的运行具有原子性，其操作只能一气呵成（出于系统安全性和便于管理考虑）</strong></li>
<li>这些程序的运行时间都较短，而且调用频繁。</li>
</ul>
</li>
<li><p>原语的定义</p>
<ul>
<li>定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</li>
<li>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对系统资源进行管理的功能：<br>这些管理工作更多的是对数据结构的操作，不会直接涉及硬件</p>
<ul>
<li>进程管理：进程状态管理、进程调度和分派、创建与撒销进程控制块等。</li>
<li>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li>
<li>设备管理：缓冲区管理、设备分配和回收等。</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统的体系结构</p>
<ul>
<li>大(宏、单)内核<ul>
<li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
</ul>
</li>
<li>微内核<ul>
<li>只把最基本的功能保留在内核</li>
<li>优点：内核功能少，结构清晰，方便维护</li>
<li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP3AawV.png" alt="pP3AawV.png"></li>
</ul>
</li>
<li>注：Ubuntu、CentOS的开发团队，其主要工作是实现非内核功能，而内核都是用了Linux内核</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-中断和异常的概念（✪）"><a href="#2-中断和异常的概念（✪）" class="headerlink" title="2.中断和异常的概念（✪）"></a>2.中断和异常的概念（✪）</h4><ul>
<li><p>中断的作用</p>
<ul>
<li>实现核心态与用户态的切换<ul>
<li>发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过硬件自动实现的</li>
<li>用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态<br>若要进入核心态，则只需将该位置0即可</li>
</ul>
</li>
<li>释放程序对资源的占有（实现并发）</li>
</ul>
</li>
<li><p>中断在广义上的分类</p>
<ul>
<li><p>内中断（异常）</p>
<ul>
<li><p>内中断也称为异常，<strong>与当前执行的指令有关，中断信号来源于CPU内部</strong><br>异常不能被屏蔽，一旦出现，就应立即处理。</p>
</li>
<li><p>异常的分类</p>
<ul>
<li><p>软件中断</p>
<ul>
<li><p>故障(Fault)：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，<br>让它继续执行下去。如：缺页故障</p>
</li>
<li><p><strong>陷入(Trap)</strong>：由<strong>陷入指令</strong>引发，是应用程序故意引发的，用于在<u>用户态</u>下调用操作系统内核程序，<br><strong>注：陷入指令（访管指令）在用户态中使用，属于非特权指令</strong></p>
</li>
</ul>
</li>
<li><p>硬件中断</p>
<ul>
<li>终止(Abort)：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，<br>而是直接终止该应用程序。如：整数除0、非法使用特权指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外中断（狭义上的中断，属于硬件中断）</p>
<ul>
<li><strong>与当前执行的命令无关，中断信号来自CPU外部</strong></li>
<li>I/O中断：通常用于信息输入/输出<br>如设备发出的I/O结束中断，表示设备输入/输出处理已经完成。</li>
<li>时钟中断：表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。</li>
</ul>
</li>
</ul>
</li>
<li><p>中断机制的基本实现原理</p>
<ul>
<li><p>步骤</p>
<ul>
<li>检查中断信号<ul>
<li>内中断：CPU在执行指令时会检查是否有异常发生</li>
<li>外中断：每个指令周期末尾CPU都会检查是否有外中断信号需要处理</li>
</ul>
</li>
<li>找到相应的中断处理程序：根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</li>
</ul>
</li>
<li>在中断机制中CPU和操作系统的作用<ul>
<li><strong>进入中断的程序属于操作系统程序</strong></li>
<li><strong>中断操作中由操作系统完成的是：提供中断服务、初始化中断向量表、保存中断屏蔽字、保存通用寄存器的内容、执行系统调用服务例程</strong></li>
<li><strong>中断操作中由CPU完成的是：保存被中断程序的中断点和程序状态字，将CPU模式改为内核态</strong></li>
</ul>
</li>
<li><strong>中断处理需要保存程序断点/程序计数器（PC）、程序状态字寄存器（PSW），而子程序只需要保存断点/程序计数器（PC）</strong></li>
<li>定时器产生时钟中断后，由时钟中断服务程序更新的内容是<ul>
<li>内核中时钟变量的值</li>
<li>当前进程占用CPU的时间</li>
<li>当前进程在时间片内的剩余执行时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-系统调用（✪）"><a href="#3-系统调用（✪）" class="headerlink" title="3.系统调用（✪）"></a>3.系统调用（✪）</h4><ul>
<li>系统调用的定义<ul>
<li>操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，<br>由用户进程发起，应用程序可以通过系统调用来请求获得操作系统内核的服务</li>
<li>应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，<br>因此凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求</li>
<li>系统调用由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</li>
<li><strong>完全由操作系统自动完成的和不涉及请求操作系统服务的不属于系统调用</strong><ul>
<li>如进程调度，页置换由操作系统自动完成</li>
<li>生成随机整数，只需要普通的函数调用，不涉及请求操作系统的服务</li>
</ul>
</li>
</ul>
</li>
<li>系统调用与库函数的区别<ul>
<li><strong>普通应用程序可直接进行系统调用，也可使用库函数用程序，有的库函数涉及系统调用，有的不涉及</strong></li>
<li>编程语言向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP3FhB6.png" alt="pP3FhB6.png"></li>
</ul>
</li>
</ul>
</li>
<li>系统调用的功能<ul>
<li><strong>设备管理：完成设备的请求/释放/启动等功能</strong></li>
<li><strong>文件管理：完成文件的读/写/创建/删除等功能</strong></li>
<li><strong>进程控制：完成进程的创建/撤销/阻塞/唤醒等功能</strong></li>
<li><strong>进程通信：完成进程之间的消息传递/信号传递等功能</strong></li>
<li><strong>内存管理：完成内存的分配/回收等功能</strong></li>
</ul>
</li>
<li>系统调用的过程（<strong>在用户态发生，在内核态执行</strong>）<ul>
<li>在用户态中使用传参指令：将系统调用需要的参数放到某些通用寄存器中</li>
<li>用户程序可以执行<strong>陷入指令(又称访管指令或trap指令)</strong>来发起系统调用，请求操作系统提供服务。</li>
<li>当需要管理程序服务时，系统则通过<strong>硬件中断</strong>机制进入核心态，运行管理程序<br>此时相当于应用程序把CPU的使用权主动交给操作系统内核程序(CPU状态会从用户态进入核心态)</li>
<li>在核心态中，操作系统内核程序再对系统调用请求做出相应处理。</li>
<li>处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序(即CPU状态会从核心态回到用户态)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPklj2V.png" alt="pPklj2V.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>系统调用的注意事项</p>
<ul>
<li>由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，<br>但这个系统堆栈也是属于该进程的。</li>
<li><strong>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</strong></li>
<li><strong>系统调用中由操作系统完成的是：保存通用寄存器的内容、执行系统调用服务例程</strong></li>
<li><strong>系统调用中由CPU完成的是：保存断点和程序状态字、将CPU模式改为内核态</strong></li>
</ul>
</li>
</ul>
<h3 id="四-操作系统结构（✠）"><a href="#四-操作系统结构（✠）" class="headerlink" title="四.操作系统结构（✠）"></a>四.操作系统结构（✠）</h3><h4 id="1-分层结构"><a href="#1-分层结构" class="headerlink" title="1.分层结构"></a>1.分层结构</h4><ul>
<li>分层法的概述<ul>
<li>将操作系统分为若干层，最底层(层0)为硬件，最高层(层N)为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）</li>
</ul>
</li>
<li>分层法的优点<ul>
<li>便于系统的调试和验证，简化了系统的设计和实现</li>
<li>易扩充和易维护：各层之间调用接口清晰固定</li>
</ul>
</li>
<li>分层法的缺点<ul>
<li>仅可调用相邻低层，难以合理定义各层的边界</li>
<li>效率低，不可跨层调用，系统调用执行时间长<ul>
<li>操作系统每执行一个功能，通常要自上而下地穿越多层，<br>各层之间都有相应的层间通信机制，这无疑增加了额外的开销，导致系统效率降低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2.模块化"></a>2.模块化</h4><ul>
<li>模块化的概述<ul>
<li>模块-接口法：将操作系统按功能划分为若干具有一定独立性的模块。</li>
<li>每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信</li>
</ul>
</li>
<li>模块化的优点<ul>
<li>模块间逻辑清晰易于维护，确定模块间接口后，即可多模块同时开发</li>
<li>支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强OS适应性</li>
<li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高</li>
</ul>
</li>
<li>模块化的缺点<ul>
<li>模块间的接口定义未必合理、实用</li>
<li>模块间相互依赖，更难调试和验证</li>
</ul>
</li>
</ul>
<h4 id="3-宏内核与微内核"><a href="#3-宏内核与微内核" class="headerlink" title="3.宏内核与微内核"></a>3.宏内核与微内核</h4><ul>
<li><p>宏内核</p>
<ul>
<li>宏内核也称单内核或大内核，将所有的系统功能都放在内核里，通常也采用了“模块化“的设计思想</li>
<li>优点：<strong>性能高</strong>，内核内部各种功能都可以直接相互调用</li>
<li><p>缺点：内核庞大功能复杂，难以维护；大内核中某个功能模块出错，就可能导致整个系统崩溃</p>
</li>
<li><p>目前的主流操作系统均使用的宏内核的架构：Linux、UNIX</p>
</li>
</ul>
</li>
<li><p>微内核（机制与策略分离）</p>
<ul>
<li>只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</li>
<li><p>优点</p>
<ul>
<li>内核小功能少、易于维护，内核可靠性高</li>
<li>内核外的某个功能模块出错不会导致整个系统崩溃（<strong>可靠性与安全性</strong>）</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><strong>性能低，需要频繁的切换用户态/核心态</strong>。</li>
<li>用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递”来间接通信</li>
</ul>
</li>
<li><p>微内核的特点</p>
<ul>
<li><p>扩展性和灵活性</p>
<ul>
<li>许多功能从内核中分离出来，当要修改某些功能或增加新功能时，<br>只需在相应的服务器中修改或新增功能，或再增加一个专用的服务器，而无须改动内核代码。</li>
</ul>
</li>
<li><p>可靠性和安全性</p>
<ul>
<li>内核外的某个功能模块出错不会导致整个系统崩溃</li>
</ul>
</li>
<li><p>可移植性</p>
<ul>
<li>与CPU和I/O硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，<br>因而将操作系统移植到另一个平台上所需做的修改是比较小的。</li>
</ul>
</li>
<li><p>分布式计算</p>
<ul>
<li>客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，<br>这就使得微内核系统能很好地支持分布式系统和网络系统。</li>
</ul>
</li>
</ul>
</li>
<li><p>虽然宏内核在桌面操作系统中取得了绝对的胜利，但是微内核在实时、工业、航空及军事应用中特别流行，<br>这些领域都是关键任务，需要有高度的可靠性。</p>
</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP3EqgJ.png" alt="pP3EqgJ.png"></li>
</ul>
</li>
</ul>
<h3 id="五-操作系统引导（boot-✠）"><a href="#五-操作系统引导（boot-✠）" class="headerlink" title="五.操作系统引导（boot ✠）"></a>五.操作系统引导（boot ✠）</h3><ul>
<li><strong>操作系统引导程序(boot)位于磁盘，操作系统在初始化过程中需要创建中断向量表</strong></li>
<li><strong>活动分区又称主分区，即安装了操作系统的分区，通常在C盘，MBR(主引导记录可以确定活动分区)</strong></li>
<li><p>操作系统引导过程</p>
<ul>
<li>①<strong>激活CPU</strong>。激活的CPU读取ROM中的boot程序，开始执行BIOS的指令（自举程序）</li>
<li>②<strong>硬件自检</strong>。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止;如无故障，屏幕会显示CPU、内存、硬盘等信息。</li>
<li>③<strong>加载带有操作系统的硬盘。将磁盘读入内存</strong></li>
<li>④<strong>加载主引导记录MBR</strong>。<strong>主引导记录MBR告诉CPU去硬盘的哪个主分区去找操作系统</strong>。</li>
<li>⑤<strong>扫描硬盘分区表，并加载硬盘活动分区</strong>。</li>
<li><strong>⑥加载分区引导记录PBR。其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。</strong></li>
<li>⑦加载启动管理器</li>
<li>⑧加载操作系统</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP3eSpD.png" alt="pP3eSpD.png"></li>
</ul>
</li>
</ul>
<h3 id="六-虚拟机"><a href="#六-虚拟机" class="headerlink" title="六.虚拟机"></a>六.虚拟机</h3><ul>
<li>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(Virtual Machine,VM)<br>每个虚拟机器都可以独立运行一个操作系统</li>
<li>也可称为虚拟机管理程序/虚拟机监控程序Virtual Machine Monitor/Hypervisor</li>
<li><p>运行在两类虚拟机管理程序上的操作系统都称为客户操作系统，Guest OS<br>对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为宿主操作系统，Host OS</p>
</li>
<li><p>1.第一类VMM（裸金属架构）</p>
<ul>
<li>直接运行在硬件之上，能直接控制和分配物理资源</li>
<li>运行在最高特权级(Ring 0)，可以执行最高特权的指令是唯一一个运行在最高特权级的程序</li>
<li>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</li>
<li>性能更好；虚拟机的可迁移性更差</li>
<li>可支持的虚拟机数量更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</li>
</ul>
</li>
<li><p>2.第二类VMM（寄宿架构）</p>
<ul>
<li>它是一个依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个普通的进程<br>运行在Host OS之上，依赖于Host OS为其分配物理资源</li>
<li>第二类VMM分运行在用户态、部分运行在内核态。<br>GuestOS发出的系统调用会被VMM截获，并转化为VMM对HostOS的系统调用</li>
<li>GuestOS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。GuestOS分配到的内存是虚拟内存。<ul>
<li>首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。<br>然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）</li>
</ul>
</li>
<li>性能更差，需要HostOS作为”中介”；可迁移性更好，只需导出虚拟机镜像文件即可迁移到另一台HostOS上，商业化应用更广泛</li>
<li>可支持的虚拟机数量更少，Host OS本身需要使用物理资源，HostOS上运行的其他进程也需要物理资源</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/18/pP3mrrj.png" alt="pP3mrrj.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第六章-应用层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="计算机网络第六章-应用层"><a href="#计算机网络第六章-应用层" class="headerlink" title="计算机网络第六章 应用层"></a>计算机网络第六章 应用层</h2><blockquote>
<p>计算机学科基础：计算机网络第六章应用层的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-网络应用模型"><a href="#一-网络应用模型" class="headerlink" title="一.网络应用模型"></a>一.网络应用模型</h3><h4 id="1-客户-服务器模型（C-S）"><a href="#1-客户-服务器模型（C-S）" class="headerlink" title="1.客户/服务器模型（C/S）"></a>1.客户/服务器模型（C/S）</h4><ul>
<li>在客户/服务器(Client/Server,C/S)模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求<ul>
<li>服务器的工作流程<ul>
<li>服务器处于接收请求的状态</li>
<li>客户机发出服务请求，并等待接收结果</li>
<li>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机</li>
</ul>
</li>
</ul>
</li>
<li>客户程序必须知道服务器程序的地址，客户机上一般不需要特殊的硬件和复杂的操作系统。</li>
<li>而服务器上运行的软件则是专门用来提供某种服务的程序，可同时处理多个远程或本地客户的要求。<br>系统启动后即自动调用并一直不断地运行着，被动地等待并接收来自各地客户的请求。因此，服务器程序不需要知道客户程序的地址</li>
<li>客户/服务器模型的主要的特征<ul>
<li>客户是服务请求方，服务器是服务提供方<br>常见的使用客户/服务器模型的应用包括Web、文件传输协议(FTP)、远程登录和电子邮件等</li>
<li>网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储/删除数据，<br>或进行其他受限的网络活动。整个网络的管理工作由少数服务器担当，因此网络的管理非常集中和方便</li>
<li>客户机相互之间不直接通信。例如，在Web应用中两个浏览器并不直接通信</li>
<li>可扩展性不佳。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限</li>
</ul>
</li>
</ul>
<h4 id="2-P2P模型"><a href="#2-P2P模型" class="headerlink" title="2.P2P模型"></a>2.P2P模型</h4><ul>
<li><p>P2P模型的思想是整个网络中的传输内容不再被保存在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。</p>
</li>
<li><p>在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一对计算机一一称为对等方(Per)，直接相互通信<br>P2P模型从本质上来看仍然使用客户/服务器模式，每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。</p>
</li>
<li>P2P模型的优点<ul>
<li>减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率<br>例如，播放流媒体时对服务器的压力过大，而通过P2P模型，可以利用大量的客户机来提供服务</li>
<li>多个客户机之间可以直接共享文档</li>
<li>可扩展性好，传统服务器有响应和带宽的限制，因此只能接受一定数量的请求</li>
<li>网络健壮性强，单个结点的失效不会影响其他部分的结点。</li>
</ul>
</li>
<li>P2P模型的缺点<ul>
<li>在获取服务的同时，还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。<br>例如，经常进行P2P下载还会对硬盘造成较大的损伤。</li>
<li>据某互联网调研机构统计，当前P2P程序已占互联网50%~90%的流量，使网络变得非常拥塞，<br>因此各大ISP(互联网服务提供商，如电信、网通等）通常都对P2P应用持反对态度。</li>
</ul>
</li>
</ul>
<h4 id="3-常见应用层协议端口号"><a href="#3-常见应用层协议端口号" class="headerlink" title="3.常见应用层协议端口号"></a>3.常见应用层协议端口号</h4><ul>
<li><img src="https://s1.ax1x.com/2023/08/12/pPuSIX9.png" alt="pPuSIX9.png"></li>
</ul>
<h3 id="二-域名系统（DNS✪）"><a href="#二-域名系统（DNS✪）" class="headerlink" title="二.域名系统（DNS✪）"></a>二.域名系统（DNS✪）</h3><h4 id="1-DNS的概述"><a href="#1-DNS的概述" class="headerlink" title="1.DNS的概述"></a>1.DNS的概述</h4><ul>
<li>域名系统(DNS)是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名转换为便于机器处理的IP地址。<br>互联网上提供的主机一定要有IP地址，不一定要有域名</li>
<li>DNS系统采用客户/服务器模型，<strong>其协议运行在UDP之上，使用53号端口</strong></li>
<li>从概念上可将DNS分为3部分：层次域名空间、域名服务器和解析器。</li>
<li>一个域名可以对应多个主机或IP地址，一个主机或IP地址也可以对应多个域名</li>
<li>主机需要知道自己的本地域名服务器的IP地址，本地域名服务器需要知道根服务器的IP地址</li>
</ul>
<h4 id="2-层次域名空间"><a href="#2-层次域名空间" class="headerlink" title="2.层次域名空间"></a>2.层次域名空间</h4><ul>
<li>因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名(Domain Name)。</li>
<li>域(Domain)是名字空间中一个可被管理的划分。域还可以划分为子域，而子域还可以继续划分为子域的子域，<br>这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，而各标号之间用点(“.”)隔开<img src="https://s1.ax1x.com/2023/08/11/pPn9vu9.png" alt="pPn9vu9.png"></li>
<li>关于域名中的标号有以下几点需要注意<ul>
<li>标号中的英文不区分大小写</li>
<li>标号中除连字符(-)外不能使用其他的标点符号</li>
<li>每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符</li>
<li>级别最低的域名写在最左边，级别最高的顶级域名写在最右边</li>
</ul>
</li>
<li>项级域名的分类(TLD)<ul>
<li>国家（地区）顶级域名：国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，“.uk”表示英国</li>
<li>通用顶级域名：常见的有“.com”（公司）、“.net”（网络服务机构）、“.org”（非营利性组织）和“.gov”（国家或政府部门）等</li>
<li>基础结构域名。这种顶级域名只有一个，即arpa，用于反向域名解析，因此又称反向域名</li>
</ul>
</li>
<li>在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理</li>
</ul>
<h4 id="3-域名服务器"><a href="#3-域名服务器" class="headerlink" title="3.域名服务器"></a>3.域名服务器</h4><ul>
<li><p>域名服务器的概述</p>
<ul>
<li>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型。</li>
<li>域名到IP地址的解析是由运行在域名服务器上的程序完成的，一个服务器所负责管辖的范围称为区(不以“域”为单位)<br>各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，<br>每个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。</li>
<li>每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息<br>当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器</li>
<li>DNS使用了大量的域名服务器，它们以层次方式组织，采用分布式设计的DNS<br>没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的DNS上。</li>
</ul>
</li>
<li><p>域名服务器的分类</p>
<ul>
<li>根域名服务器<ul>
<li>根域名服务器是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的IP地址</li>
<li><strong>根域名服务器也是最重要的域名服务器，不管是哪个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就<u>首先</u>要求助于根域名服务器</strong></li>
<li>因特网上有13个根域名服务器，尽管我们将这13个根域名服务器中的每个都视为单个服务器，但每个“服务器”实际上是冗余服务器的集群，以提供安全性和可靠性</li>
<li>根域名服务器用来管辖顶级域(如.com)，通常它并不直接把待查询的域名直接转换成IP地址，<br>而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询</li>
</ul>
</li>
<li>顶级域名服务器<ul>
<li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。</li>
<li>收到DNS查询请求时，就给出相应的回答(可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址)</li>
</ul>
</li>
<li>授权域名服务器（权限域名服务器）<ul>
<li>每台主机都必须在授权域名服务器处登记。为了更可靠工作，一台主机最好至少有两个授权域名服务器。</li>
<li>许多域名服务器都同时充当本地域名服务器和授权域名服务器。<strong>授权域名服务器总能将其管辖的主机名转换为该主机的IP地址</strong></li>
</ul>
</li>
<li>本地域名服务器<ul>
<li>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</li>
<li>在Windows系统中配置“本地连接”时，就需要填写DNS地址，这个地址就是本地DNS（域名服务器）的地址</li>
</ul>
</li>
<li>层次图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnPJzD.png" alt="pPnPJzD.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-域名解析过程-♚"><a href="#4-域名解析过程-♚" class="headerlink" title="4.域名解析过程(♚)"></a>4.域名解析过程(♚)</h4><ul>
<li><p>两种查询方式</p>
<ul>
<li>递归查询（主机向本地域名服务器的查询）<ul>
<li>如果本地主机所询问的本地域名服务器不知道被查询域名的IP地址，<br>那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文</li>
</ul>
</li>
<li>迭代查询（本地域名服务器向根域名服务器的查询）<ul>
<li>当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，<br>要么告诉本地域名服务器：“你下一步应当向哪个顶级域名服务器进行查询”，然后让本地域名服务器向这个顶级域名服务器进行后续的查询</li>
<li>顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应向哪个权限域名服务器查询。最后，知道所要解析的域名的IP地址后，把这个结果返回给发起查询的主机。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnF08f.png" alt="pPnF08f.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>高速缓存</p>
<ul>
<li>为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。</li>
<li>当一个DNS服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速缓存中。</li>
<li>当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问。</li>
<li>因为主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息。</li>
</ul>
</li>
<li>例题<ul>
<li>例1：最少情况：当本地域名服务器中有该域名的DNS信息时，不需要查询任何其他域名服务器，最少发出0次DNS查询<br>最多情况：因为均采用迭代查询方式，在最坏情况下，本地域名服务器需要依次迭代地向根域名服务器、顶级域名服务器(.com)、权限域名服务器(xyz.com)、权限域名服务器(abc.xyz.com)发出DNS查询请求，因此最多发出4次DNS查询。<ul>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnAmfx.png" alt="pPnAmfx.png"></li>
</ul>
</li>
<li>例2：最短本地域名服务器已有缓存，只需访问其即可（10），此时再进行浏览（10）总共20；最长需要本地服务器依次访问根服务器、顶级域名服务器、域名服务器（30），加上之前访问本地服务器的时间以及主机向网站进行浏览的时间，共50<ul>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnAK1K.png" alt="pPnAK1K.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三-文件传输系统（FTP）"><a href="#三-文件传输系统（FTP）" class="headerlink" title="三.文件传输系统（FTP）"></a>三.文件传输系统（FTP）</h3><h4 id="1-FTP的工作原理"><a href="#1-FTP的工作原理" class="headerlink" title="1.FTP的工作原理"></a>1.FTP的工作原理</h4><ul>
<li>FTP提供交互式的访问，<strong>允许客户指明文件的类型与格式，并允许文件具有存取权限</strong>。<br>它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件</li>
<li>FTP采用客户/服务器的工作方式，它使用TCP可靠的传输服务。一个FTP服务器进程可同时为多个客户进程提供服务。</li>
<li>FTP的服务器进程由两大部分组成：一个主进程，负责接收新的请求，另外有若干从属进程，负责处理单个请求。</li>
<li>FTP的功能<ul>
<li>提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力</li>
<li>以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力</li>
<li>以匿名FTP的方式提供公用文件共享的能力</li>
</ul>
</li>
<li>FTP服务器的工作步骤<ul>
<li>打开熟知端口21（控制端口），使客户进程能够连接上</li>
<li>等待客户进程发连接请求</li>
<li>启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止</li>
<li>回到等待状态，继续接收其他客户进程的请求。</li>
<li>FTP服务器必须在整个会话期间保留用户的状态信息。特别是服务器必须把指定的用户账户与控制连接联系起来，<br>服务器必须追踪用户在远程目录树上的当前位置</li>
</ul>
</li>
</ul>
<h4 id="2-控制连接与数据连接"><a href="#2-控制连接与数据连接" class="headerlink" title="2.控制连接与数据连接"></a>2.控制连接与数据连接</h4><ul>
<li><p>FTP在工作时使用两个并行的TCP连接：一个是控制连接(服务器端口号21)，<br>一个是数据连接(服务器端口号20)。使用两个不同的端口号可以使协议更容易实现。</p>
</li>
<li><p>控制连接（端口号21）</p>
<ul>
<li>服务器监听21号端口，等待客户连接，建立在这个端口上的连接称为控制连接</li>
<li>控制连接用来传输控制信息(如连接请求、传送请求等)，并且控制信息都以7位ASCII格式传送，<br>FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程</li>
<li>控制连接并不用来传送文件，但在传输文件时也可以使用控制连接（如客户在传输中途发一个中止传输的命令），<br><strong>因此控制连接在整个会话期间一直保持打开状态</strong>。</li>
</ul>
</li>
<li>数据连接（端口号20）<ul>
<li>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。</li>
<li>数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，<br><strong>在传送完毕后关闭“数据传送连接”并结束运行</strong>。</li>
<li>数据连接的两种传输模式<ul>
<li>主动模式PORT<ul>
<li>客户端连接到服务器的21端口，登录成功后要读取数据时，客户端随机开放一个端口，并发送命令告知服务器</li>
<li>服务器收到PORT命令和端口号后，通过20端口和客户端开放的端口连接，发送数据。</li>
</ul>
</li>
<li>被动模式PASV模式<ul>
<li>客户端要读取数据时，发送PASV命令到服务器，服务器在本地随机开放一个端口，并告知客户端，<br>客户端再连接到服务器开放的端口进行数据传输。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>无论是用PORT模式还是PASV模式，选择权在客户端</strong></li>
<li><strong>主动模式传送数据是“服务器”连接到“客户端”的端口，被动模式传送数据是“客户端”连接到“服务器”的端口。</strong></li>
<li><strong>TCP的20和21端口均为<u>服务器</u>的端口，客户进程的端口是客户进程自己提供的</strong></li>
<li>带外传送与NFS<ul>
<li>因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外(Out-of-band)传送的。</li>
<li>使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器，来回传送耗费很多时间。</li>
<li>网络文件系统(NFS)采用另一种思路，它允许进程打开一个远程文件，并能在该文件的某个特定位置开始读写数据。<br>此时NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件</li>
</ul>
</li>
</ul>
<h3 id="四-电子邮件"><a href="#四-电子邮件" class="headerlink" title="四.电子邮件"></a>四.电子邮件</h3><h4 id="1-电子邮件系统的组成结构"><a href="#1-电子邮件系统的组成结构" class="headerlink" title="1.电子邮件系统的组成结构"></a>1.电子邮件系统的组成结构</h4><ul>
<li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，<br>并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。</li>
<li>电子邮件系统的主要的组成构件<ul>
<li>用户代理(User Agent)<ul>
<li>用户与电子邮件系统的接口。用户代理向用户提供一个很友好的接口来发送和接收邮件，<br>用户代理至少应当具有撰写、显示和邮件处理的功能。</li>
<li>通常情况下，用户代理就是一个运行在PC上的程序（电子邮件客户端软件），常见的有Outlook和Foxmail等。</li>
</ul>
</li>
<li>邮件服务器<ul>
<li>它的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</li>
<li>邮件服务器采用客户/服务器方式工作，但它必须能够同时充当客户和服务器。<ul>
<li>例如，当邮件服务器A向邮件服务器B发送邮件时，A就作为SMTP客户，而B是SMTP服务器</li>
<li>反之，当B向A发送邮件时，B就是SMTP客户，而A就是SMTP服务器</li>
</ul>
</li>
</ul>
</li>
<li>邮件发送协议和读取协议<ul>
<li>SMTP（邮箱发送协议）<ul>
<li><strong>用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件</strong></li>
<li>SMTP用的是“推”(Push)的通信方式，即用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，<br>SMTP客户将邮件“推”送到SMTP服务器</li>
</ul>
</li>
<li>POP3（邮件读取协议）<ul>
<li>用于用户代理从邮件服务器读取邮件</li>
<li>POP3用的是“拉”(Pull)的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</li>
</ul>
</li>
<li>在浏览器中时，HTTP协议也可以发送或接收邮件</li>
</ul>
</li>
</ul>
</li>
<li>电子邮件的收发过程<ul>
<li>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送端邮件服务器</li>
<li>发送端邮件服务器将邮件放入邮件缓存队列中，等待发送</li>
<li>运行在发送端邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，<br>就向运行在接收端邮件服务器的SMTP服务器进程发起建立TCP连接</li>
<li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。<br>当所有待发送邮件发完后，SMTP就关闭所建立的TCP连接</li>
<li>运行在接收端邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取</li>
<li>收信人打算收信时，调用用户代理，使用POP3(或IMAP)协议将自己的邮件从接收端邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）</li>
</ul>
</li>
</ul>
<h4 id="2-电子邮件格式与MIME"><a href="#2-电子邮件格式与MIME" class="headerlink" title="2.电子邮件格式与MIME"></a>2.电子邮件格式与MIME</h4><ul>
<li>电子邮件格式<ul>
<li>一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分</li>
<li>邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。<br>最重要的关键字是To和Subject.</li>
<li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。电子邮件地址的规定格式为：收件人邮箱名@邮箱所在主机的域名，如abc@cskaoyan.com，其中收信人邮箱名即用户名，在邮件服务器上唯一</li>
<li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容</li>
<li>还有一个必填的关键字是From，但它通常由邮件系统自动填入</li>
</ul>
</li>
<li>多用途网际邮件扩充（MIME）<ul>
<li>由于SMTP只能传送<strong>7位的ASCI码</strong>邮件，许多其他非英语国家的文字就无法传送，<br>且无法传送可执行文件及其他二进制对象，因此提出了MIME</li>
<li>MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则，可以转换格式</li>
<li>MIME主要包括以下三部分内容<ul>
<li>5个新的邮件首部字段，包括MME版本、内容描述、内容标识、传送编码和内容类型</li>
<li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li>
<li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-SMTP和POP3"><a href="#3-SMTP和POP3" class="headerlink" title="3.SMTP和POP3"></a>3.SMTP和POP3</h4><ul>
<li>简单邮件传输协议 (SMTP)<ul>
<li>SMTP用的是TCP连接，<strong>端口号为25</strong>，是一种提供可靠且有效的电子邮件传输的协议，<br>它控制两个相互通信的SMTP进程交换信息。</li>
<li>由于SMTP使用客户/服务器方式，因此负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务<br>器。</li>
</ul>
</li>
<li>邮局协议(POP)<ul>
<li>在传输层使用TCP，<strong>端口号为110</strong>，使用客户/服务器的工作方式，是一个非常简单但切能有限的邮件读取协议，<br>现任使用的是它的第3个版本POP3.</li>
<li>POP3采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。<br>接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序。</li>
<li>POP有两种工作方式：“下载并保留”和“下载并删除”。<ul>
<li>在“下载并保留”方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件</li>
<li>而使用“下载并删除”方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五-万维网（www✪）"><a href="#五-万维网（www✪）" class="headerlink" title="五.万维网（www✪）"></a>五.万维网（www✪）</h3><h4 id="1-www的概念与组成结构"><a href="#1-www的概念与组成结构" class="headerlink" title="1.www的概念与组成结构"></a>1.www的概念与组成结构</h4><ul>
<li><p>万维网是无数个网络站点和网页的集合，它们在一起构成了因特网最主要的部分<br>（因特网也包括电子邮件、Usenet和新闻组）。</p>
</li>
<li><p>万维网是一个分布式、联机式的信息存储空间，资源由一个全域“统一资源定位符”(URL)标识</p>
</li>
<li>这些资源通过超文本传输协议(HTTP)传送给使用者，而后者通过单击链接来获取资源。</li>
<li><strong>万维网以客户/服务器方式工作。浏览器是在用户主机上的万维网客户程序，而万维网文档所驻留的主机则运行服务器程序，这台主机称为万维网服务器。</strong><br><strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong></li>
<li>万维网的内核部分<ul>
<li>统一资源定位符(URL)<ul>
<li>负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL</li>
<li>URL的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li>
<li>&lt;协议&gt;指用什么协议来获取万维网文档，常见的协议有http、fp等</li>
<li>&lt;主机&gt;是存放资源的主机在因特网中的域名或IP地址</li>
<li>&lt;端口&gt;和&lt;路径&gt;有时可省略。在URL中不区分大小写。</li>
</ul>
</li>
<li>超文本传输协议(HTTP)<ul>
<li>一个应用层协议，它使用TCP连接进行可靠的传输</li>
<li>HTTP是万维网客户程序和服务器程序之间交互所必须严格遵守的协议</li>
</ul>
</li>
<li>超文本标记语言(HTML)<ul>
<li>一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息(包括文字、声音、图像、视频等)、格式进行描述</li>
<li>万维网页面的设计者可以很方便地用一个超链接从本页面的某处链接到因特网上的任何一个万维网页面，<br>并能够在自己的计算机屏幕上显示这些页面。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-超文本传输协议（HTTP）"><a href="#2-超文本传输协议（HTTP）" class="headerlink" title="2.超文本传输协议（HTTP）"></a>2.超文本传输协议（HTTP）</h4><ul>
<li>HTTP的操作过程<ul>
<li>用户点击超链接或输网址后的过程<ul>
<li>1.浏览器分析URL</li>
<li>2.浏览器向DNS请求解析URL的IP地址</li>
<li>3.DNS解析出IP地址</li>
<li>4.浏览器与服务器建立TCP连接<ul>
<li>每个万维网站点都有一个服务器进程，它不断地监听TCP的端口80（默认），<br>当监听到连接请求后便与浏览器建立TCP连接</li>
</ul>
</li>
<li>5.浏览器发出HTTP请求</li>
<li>6.服务器响应HTTP请求并发送相关文件给浏览器</li>
<li>7.释放TCP连接</li>
<li>8.浏览器解释文件并将web页显示给用户</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnG99U.png" alt="pPnG99U.png"></li>
</ul>
</li>
</ul>
</li>
<li>HTTP的特点<ul>
<li>HTTP使用TCP作为传输层协议，保证了数据的可靠传输。但HTTP本身是无连接的，通信的双方在交换HTTP报文之前不需要先建立HTTP连接。</li>
<li>HTTP是无状态的，可使用Cookie（存储在用户主机中的文本文件），通过识别码记录一段时间内某用户的访问记录</li>
<li>HTTP的两种连接方式<ul>
<li>非持久连接（HTTP/1.0只能使用非持续连接）<ul>
<li>对于非持久连接，每个网页元素对象 (如JPEG图形、Flash等) 的传输都需要单独建立一个TCP连接<br><strong>第三次握手的报文段中捎带了客户对万维网文档的请求</strong></li>
<li>请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间RTT</li>
<li>每个对象引用都导致2×RTT的开销，此外每次建立新的TCP连接都要分配缓存和变量，使万维网服务器的负担很重。</li>
<li>打开一个包含100张图片的web界面，需要打开和关闭101次TCP连接</li>
</ul>
</li>
<li>持久连接（持续连接为HTTP/1.1的默认方式）<ul>
<li>万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求和响应报文</li>
<li>分为了非流水线方式和流水线方式<ul>
<li>非流水线方式<ul>
<li>对于非流水线方式，客户在收到前一个响应后才能发出下一个请求（相当于浏览器要接收确认）<br>服务器发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源</li>
</ul>
</li>
<li>流水线方式<ul>
<li><strong>HTTP/1.1的默认方式是使用流水线的持久连接</strong>，客户每遇到一个对象引用就立即发出一个请求，<br>因而客户可以逐个地连续发出对各个引用对象的请求。</li>
<li>如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历1个RTT延迟，<br>而不是像非流水线方式那样，每个引用都必须有1个RTT延迟</li>
<li>这种方式减少了TCP连接中的空闲时间，提高了效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnJiPf.png" alt="pPnJiPf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTTP的报文结构<ul>
<li>HTTP是面向文本的，因此报文中的每个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</li>
<li>分为请求报文（从客户向服务器发送的请求报文）和响应报文（从服务器到客户的回答）</li>
<li><img src="https://s1.ax1x.com/2023/08/11/pPnh6XQ.png" alt="pPnh6XQ.png"></li>
</ul>
</li>
<li>例题<ul>
<li><img src="https://s1.ax1x.com/2023/08/12/pPuSZe1.png" alt="pPuSZe1.png"><ul>
<li>答案：本题还要考虑慢开始的拥塞控制算法<img src="https://s1.ax1x.com/2023/08/12/pPuSdfS.png" alt="pPuSdfS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第五章-传输层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="计算机网络第五章-传输层"><a href="#计算机网络第五章-传输层" class="headerlink" title="计算机网络第五章 传输层"></a>计算机网络第五章 传输层</h2><blockquote>
<p>计算机学科基础：计算机网络第五章的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-传输层提供的服务（✠）"><a href="#一-传输层提供的服务（✠）" class="headerlink" title="一.传输层提供的服务（✠）"></a>一.传输层提供的服务（✠）</h3><h4 id="1-传输层的功能（✠）"><a href="#1-传输层的功能（✠）" class="headerlink" title="1.传输层的功能（✠）"></a>1.传输层的功能（✠）</h4><ul>
<li><p>传输层的概述</p>
<ul>
<li>从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，<br><strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong></li>
<li><strong>在通信子网中没有传输层，传输层只存在于通信子网以外的主机中</strong></li>
<li>传输层向高层用户屏蔽了低层网络核心的细节(如网络拓扑、路由协议等)，<br>它使应用进程看见的是在两个传输层实体之间好像有一条端到端的逻辑通信信道，这条逻辑通信信道对上层的表现却因传输层协议不同而有很大的差别。</li>
<li>当传输层采用面向连接的TCP时，尽管下面的网络是不可靠的（只提供尽最大努力的服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。<br>但当传输层采用无连接的UDP时，这种逻辑通信信道仍然是一条不可靠信道。</li>
</ul>
</li>
<li><p>传输层的功能</p>
<ul>
<li>传输层位于网络层之上，它为运行在<strong>不同主机上的进程之间</strong>提供了逻辑通信，而网络层提供<strong>主机之间</strong>的逻辑通信。<ul>
<li>逻辑通信”的意思是：传输层之间的通信好像是沿水平方向传送数据，<br>但事实上这两个传输层之间并没有一条水平方向的物理连接</li>
</ul>
</li>
<li>复用和分用<ul>
<li>复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据</li>
<li>分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</li>
<li>注意：网络层也有复用分用的功能，但网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，<br>分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。</li>
</ul>
</li>
<li>传输层还要对收到的报文进行差错检测（<strong>首部和数据部分</strong>）<ul>
<li>而网络层只检查IP数据报的首部，不检验数据部分是否出错</li>
</ul>
</li>
<li>提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。<ul>
<li>而网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如虚电路，要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-传输层的寻址与端口（✪）"><a href="#2-传输层的寻址与端口（✪）" class="headerlink" title="2.传输层的寻址与端口（✪）"></a>2.传输层的寻址与端口（✪）</h4><ul>
<li>端口的作用<ul>
<li>端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，<br>以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li>
<li>端口是传输层服务访问点(TSAP)，它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，<br>只不过IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程。<ul>
<li>数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口。</li>
</ul>
</li>
<li>在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。<ul>
<li>硬件端口是不同硬件设备进行交互的接口，</li>
<li>而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。</li>
</ul>
</li>
</ul>
</li>
<li>端口号<ul>
<li>应用进程通过端口号进行标识，端口号长度为16bit，能够表示65536($2^{16}$)个不同的端口号。</li>
<li>端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，<br>在因特网中不同计算机的相同端口号是没有联系的。</li>
<li>端口号的分类（根据范围）<ul>
<li>服务器端使用的端口号（0~49151）<ul>
<li>熟知端口号，数值为0~1023<ul>
<li>IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道</li>
<li><img src="https://s1.ax1x.com/2023/08/08/pPV2lCj.png" alt="pPV2lCj.png"></li>
</ul>
</li>
<li>登记端口号，数值为1024~49151<ul>
<li>它是供没有熟知端口号的应用程序使用的，使用这类端口号必须在IANA登记，以防止重复。</li>
</ul>
</li>
</ul>
</li>
<li>客户端使用的端口号，数值为49152~65535<ul>
<li>由于这类端口号仅在客户进程运行时才动态地选择，因此又称短暂端口号（也称临时端口）</li>
<li>通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程以后使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>套接字<ul>
<li>在网络中通过IP地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程，<br>端口号拼接到IP地址即构成套接字Socket。</li>
<li>在网络中采用发送方和接收方的套接字来识别端点。套接字实际上是一个通信端点，<strong>套接字Socket=(IP地址：端口号)</strong><br><strong>它唯一地标识网络中的一台主机和其上的一个应用（进程）</strong></li>
</ul>
</li>
</ul>
<h4 id="3-无连接服务与面向连接服务（✪）"><a href="#3-无连接服务与面向连接服务（✪）" class="headerlink" title="3.无连接服务与面向连接服务（✪）"></a>3.无连接服务与面向连接服务（✪）</h4><ul>
<li>面向连接服务与无连接服务<ul>
<li>面向连接服务就是在通信双方进行通信之前，必须先建立连接，<br>在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接</li>
<li>无连接服务是指两个实体之间的通信不需要先建立好连接，<br>需要通信时，直接将信息发送到“网络”中，让该信息的传递在网上尽力而为地往目的地传送。</li>
</ul>
</li>
<li>TCP协议与UDP协议<ul>
<li>面向连接的传输控制协议(TCP)<ul>
<li>TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接</li>
<li>采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道</li>
<li>TCP不提供广播或组播服务</li>
<li>TCP增加了许多开销，如确认（可靠传输）、流量控制、计时器及连接管理等。<br>这不仅使协议数据单元的头部增大很多，还要占用许多的处理机资源。</li>
<li>TCP主要适用于可靠性更重要的场合，如文件传输协议(FTP)、超文本传输协议(HTTP)、远程登录(TELNET)等。</li>
</ul>
</li>
<li>无连接的用户数据报协议(UDP)<ul>
<li>UDP是一个无连接的非可靠传输层协议，采用UDP时，传输层向上提供的是一条不可靠的逻辑信道</li>
<li>UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认。</li>
<li>它在IP之上仅提供两个附加服务：多路复用和对数据的错误检查</li>
<li>如果用户应用程序使用UDP进行数据传输，那么必须在传输层的上层即应用层提供可靠性方面的全部工作。</li>
<li>由于UDP比较简单，因此执行速度比较快、实时性好。<br>使用UDP的应用主要包括小文件传送协议(TFTP)、DNS、SNMP和实时传输协议(RTP)</li>
</ul>
</li>
<li>例题<ul>
<li>注：<strong>UDP首部有8B，TCP首部最少20B</strong>，此时选D<ul>
<li><img src="https://s1.ax1x.com/2023/08/10/pPeY1wq.png" alt="pPeY1wq.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>IP数据报和UDP数据报的区别<ul>
<li>IP数据报在网络层要经过路由的存储转发</li>
<li>而UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时，<br>UDP数据报的信息对路由是不可见的</li>
</ul>
</li>
<li>TCP和网络层虚电路的区别<ul>
<li>TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见</li>
<li>虚电路所经过的交换结点都必须保存虚电路状态信息。在网络层若采用虚电路方式，则无法提供无连接服务<br>而传输层采用TCP不影响网络层提供无连接服务。</li>
</ul>
</li>
</ul>
<h3 id="二-UDP协议"><a href="#二-UDP协议" class="headerlink" title="二.UDP协议"></a>二.UDP协议</h3><h4 id="1-UDP数据报"><a href="#1-UDP数据报" class="headerlink" title="1.UDP数据报"></a>1.UDP数据报</h4><ul>
<li>UDP概述<ul>
<li>UDP仅在IP的数据报服务之上增加了两个最基本的服务：复用和分用以及差错检测</li>
<li>UDP不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，所有维护可靠性的工作可由用户在应用层来完成<br>应用开发者可根据应用的需求来灵活设计自己的可靠性机制</li>
<li>UDP是面向报文的。发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，一次发送一个报文，<br>既不合并，也不拆分，而是保留这些报文的边界</li>
<li>接收方UDP对IP层交上来UDP数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。</li>
<li>报文不可分割，是UDP数据报处理的最小单位<ul>
<li>因此，应用程序必须选择合适大小的报文，若报文太长，UDP把它交给IP层后，可能会导致分片</li>
<li>若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，两者都会降低IP层的效率。</li>
</ul>
</li>
</ul>
</li>
<li>UDP的优点<ul>
<li>无须建立连接：因此UDP不会引入建立连接的时延</li>
<li>无连接状态：UDP不维护连接状态，也不跟踪这些参数。<br>因此，某些专用应用服务器使用UDP时，一般都能支持更多的活动客户机</li>
<li>分组首部开销小：TCP有20B的首部开销，而UDP仅有8B的开销。</li>
<li>应用层能更好地控制要发送的数据和发送时间：UDP没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率<br>某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而UDP正好满足这些应用的需</li>
<li>UDP支持一对一、一对多、多对一和多对多的交互通信</li>
</ul>
</li>
<li>UDP的应用场景<ul>
<li>UDP常用于一次性传输较少数据的网络应用，如DNS、SNMP等，<br>因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。</li>
<li>UDP也常用于多媒体应用（如IP电话、实时视频会议、流媒体等），显然，可靠数据传输对这些应用来说并不是最重要的；<br>但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。</li>
<li>适用于客户机/服务器领域，不适用于远程登录</li>
</ul>
</li>
<li>UDP数据报（UDP首部和用户数据）<ul>
<li>UDP首部（<strong>有8B，由4个字段组成，每个字段的长度都是2B</strong>）<ul>
<li>源端口：源端口号。<strong>在需要对方回信时选用，不需要时可用全0</strong></li>
<li>目的端口：目的端口号。<strong>这在终点交付报文时必须使用到，是实现分用服务的依据</strong></li>
<li>长度：UDP数据报的长度（包括首部和数据），其最小值是8（仅有首部）</li>
<li>校验和：检测UDP数据报在传输中是否有错。有错就丢弃。<br><strong>该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0</strong></li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/08/pPV4mtO.png" alt="pPV4mtO.png"></li>
</ul>
</li>
<li>UDP数据报传输的流程（分用服务）<ul>
<li>当传输层从IP层收到UDP数据报时，<strong>就根据首部中的目的端口</strong>，把UDP数据报通过相应的端口上交给应用进程</li>
<li>如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于端口号的应用进程）<br>那么就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/08/pPV43nI.png" alt="pPV43nI.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-UDP校验"><a href="#2-UDP校验" class="headerlink" title="2.UDP校验"></a>2.UDP校验</h4><ul>
<li><p><strong>UDP的校验和功能不是必需的，可以不使用，若源主机不想计算校验和，则该校验和字段应为全0</strong></p>
</li>
<li><p>伪首部的概念</p>
<ul>
<li><p>在计算校验和时，要在UDP数据报之前增加12B的伪首部</p>
</li>
<li><p>伪首部并不是UDP的真正首部。只是在计算校验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。<br>校验和就是按照这个临时的UDP数据报来计算的</p>
</li>
<li><p>伪首部既不向下传送又不向上递交，而只是为了计算校验和</p>
</li>
<li>UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，<br><strong>但不同的是，IP数据报的校验和只检验IP数据报的首部，但UDP的校验和则检查首部和数据部分</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/08/pPV4O8e.png" alt="pPV4O8e.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>UDP校验和的过程（<strong>UDP校验和的计算方法是二进制反码运算求和再取反</strong>）</p>
<ul>
<li>发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字串接起来。</li>
<li>若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节（但此字节不发送）<ul>
<li>如UDP数据报的长度是15B(不含伪首部），因此需要添加一个全0字节</li>
</ul>
</li>
<li><strong>然后按二进制反码计算出这些16位字的和，将此和的二进制反码写入校验和字段，去掉伪首部之后发送</strong><ul>
<li>例如：如果校验和的计算结果恰好为0，那么将校验和字段置为全1。</li>
</ul>
</li>
<li>接收方把收到的UDP数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，<br>按二进制反码求这些16位字的和。</li>
<li>当无差错时其结果应为全1，否则就表明有差错出现，接收方就应该丢弃这个UDP数据报，<br>或向上交给应用层附上出差错的报告</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/08/pPVILXd.png" alt="pPVILXd.png"></li>
</ul>
</li>
</ul>
</li>
<li>注意事项<ul>
<li>校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节，但是此字节和伪首部一样，是不发送的</li>
<li>如果UDP校验和校验出UDP数据报是错误的，那么可以丢弃，<br>也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报</li>
<li>通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，<br>还可以检查IP数据报的源IP地址和目的地址。</li>
</ul>
</li>
</ul>
<h3 id="三-TCP协议（✪）"><a href="#三-TCP协议（✪）" class="headerlink" title="三.TCP协议（✪）"></a>三.TCP协议（✪）</h3><h4 id="1-TCP协议的特点"><a href="#1-TCP协议的特点" class="headerlink" title="1.TCP协议的特点"></a>1.TCP协议的特点</h4><ul>
<li>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题</li>
<li>TCP协议的特点<ul>
<li>TCP是面向连接的传输层协议，TCP连接是一条逻辑连接（虚连接）</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点到点的（一对一）</li>
<li>TCP提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序</li>
<li>TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，<br>为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据<ul>
<li>发送缓存暂存的数据<ul>
<li>发送应用程序传送给发送方TCP准备发送的数据</li>
<li>TCP已发送但尚未收到确认的数据</li>
</ul>
</li>
<li>接收缓存暂存的数据<ul>
<li>按序到达但尚未被接收应用程序读取的数据</li>
<li>不按序到达的数据</li>
</ul>
</li>
</ul>
</li>
<li>TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流。</li>
</ul>
</li>
<li>TCP和UDP在发送报文时所采用的方式完全不同<ul>
<li>UDP报文的长度由发送应用进程决定</li>
<li>TCP报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。</li>
<li>如果应用进程传送到TCP缓存的数据块太长，TCP就把它划分得短一些再传送</li>
<li>如果太短，TCP也可以等到积累足够多的字节后再构成报文段发送出去</li>
</ul>
</li>
</ul>
<h4 id="2-TCP报文段"><a href="#2-TCP报文段" class="headerlink" title="2.TCP报文段"></a>2.TCP报文段</h4><ul>
<li>TCP传送的数据单元称为报文段。TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答</li>
<li>一个TCP报文段分为首部和数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中</li>
<li>首部的前20B是固定的。TCP首部最短为20B，后面有4N字节是根据需要而增加的选项，长度为4B的整数倍；<br>加上可选字段后，TCP首部最大为60B</li>
<li>TCP报文字段<ul>
<li>源端口和目的端口：各占2B<ul>
<li>端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口实现<ul>
<li>注：IP/UDP数据报和TCP报文都是源在前目的在后<br>只有MAC帧是目的在前源在后</li>
</ul>
</li>
</ul>
</li>
<li>序号：占4B，范围为$0\sim 2^{32}-1$，共$2^{32}$个序号<ul>
<li><strong>TCP是面向字节流的（即TCP传送时是逐个字节传送的），所以TCP连接传送的字节流中的每个字节都按顺序编号</strong></li>
<li>序号字段的值指的是本报文段所发送的数据的<strong>第一个字节的序号</strong></li>
<li>如：一报文段的序号字段值是301，而携带的数据共有100B，表明本报文段的数据的最后一个字节的序号是400<br>因此下一个报文段的数据序号应从401开始。</li>
</ul>
</li>
<li>确认号：占4B<ul>
<li><strong>期望收到对方下一个报文段的第一个数据字节的序号</strong></li>
<li><strong>若确认号为N，则表明到序号N-1为止的所有数据都已正确收到</strong></li>
<li>例：B正确收到了A发送过来的一个报文段，其序号字段是501，而数据长度是200B(序号501~700)，<br>这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701</li>
</ul>
</li>
<li>数据偏移（即首部长度）：占4位（bit）<ul>
<li>指出TCP报文段的数据起始处距离TCP报文段的起始处有多远（因为TCP首部有可选选项）</li>
<li>“数据偏移”的单位是4B，由于4位二进制数能表示的最大值为15，因此TCP首部的最大长度为60B</li>
</ul>
</li>
<li>保留。占6位，保留为今后使用，但目前应置为0</li>
<li>6个控制位（每个一位，共占6位）<ul>
<li>紧急位URG。当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，<br>应尽快传送（相当于高优先级的数据）。但URG需要和首部中紧急指针字段配合使用，<br>即数据从第一个字节到紧急指针所指字节就是紧急数据。（在发送缓存中可以插队）</li>
<li>确认位ACK。仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。<br>TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.</li>
<li>推送位PSH(Push)。接收方TCP收到PSH=1的报文段，就尽快地交付给接收应用进程，<br>而不再等到整个缓存都填满了后再向上交付。</li>
<li>复位位RST(Reset)。当RST=1时，表明TCP连接中出现严重差错（如主机崩溃或其他原因），<br>必须释放连接，然后再重新建立运输连接。</li>
<li>同步位SYN。当SYN=1时表示这是一个连接请求或连接接受报文。<br>当SYN=1，ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使用SYN=1,ACK=1.</li>
<li>终止位FIN(Finish)。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li>
</ul>
</li>
<li>窗口。占2B，范围为$0\sim2^{16}-1$<ul>
<li><strong>现在允许对方发送的数据量，是接收方让发送方设置其发送窗口的依据</strong></li>
<li><strong>若以发送方的窗口值来看，则表示发送端收到一个确认之前可以发送的字节数</strong></li>
<li>例如，设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的一方还要接收1000字节数据(字节序号为701~1700)的接收缓存空间</li>
<li>例<ul>
<li><strong>常常使接收方没有接收到之前某个报文段的数据就发送了确认（接收窗口）来考察，此题还能发送的数据为接收窗口减已发送未收到数据=300</strong>，选C<ul>
<li><img src="https://s1.ax1x.com/2023/08/10/pPe0MCt.png" alt="pPe0MCt.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>校验和。占2B。<ul>
<li>校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部（<strong>只需将UDP伪首部的协议字段的17改成6,UDP长度字段改成TCP长度，其他的和UDP一样</strong>）。</li>
</ul>
</li>
<li>紧急指针。占2B。</li>
<li>紧急指针仅在URG=1时才有意义，它指出在本报文段中紧急数据共有多少字节（紧急数据在报文段数据的最前面）</li>
<li>选项。长度可变。<ul>
<li>TCP最初只规定了一种选项，即最大报文段长度（Maximum Segment Size,MSS).MSS是TCP报文段中的数据字段的最大长度（注意仅仅是数据字段）。</li>
</ul>
</li>
<li>填充。这是为了使整个首部长度是4B的整数倍。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPZgNGj.png" alt="pPZgNGj.png"></li>
</ul>
</li>
</ul>
<h4 id="3-TCP连接管理（♚）"><a href="#3-TCP连接管理（♚）" class="headerlink" title="3.TCP连接管理（♚）"></a>3.TCP连接管理（♚）</h4><ul>
<li>TCP连接的端口即为套接字(Socket)或插口，每条TCP连接唯一地被通信的两个端点（即两个套接字）确定</li>
<li>TCP连接的建立采用客户/服务器模式。主动发起连接建立的应用进程称为客户(Client)<br>而被动等待连接建立的应用进程称为服务器(Server)。</li>
<li>TCP连接的建立（三次握手）<ul>
<li>客户端发送请求连接报文段，此时无应用层数据<br>SYN=1，seq=x</li>
<li>服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接，无应用层数据<br>SYN=1，ACK=1，seq=y，ack=x+1</li>
<li>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。<br>ACK=1，seq=x+1，ack=y+1</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPZWZIU.png" alt="pPZWZIU.png"></li>
</ul>
</li>
</ul>
</li>
<li>TCP连接的释放（四次挥手）<ul>
<li>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。<br>FIN=1，seq=u</li>
<li>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了，此时为半关闭状态。<br>ACK=1，seq=v，ack=u+1</li>
<li>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接<br>FIN=1，ACK=1，seq=w，ack=u+1</li>
<li>客户端回送一个确认报文段，<strong>再等到时间等待计时器设置的2MSL（最长报文段寿命）后</strong>，连接彻底关闭<br>ACK=1，seq=u+1，ack=w+1（此时客户机的状态为TIME-WAIT）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPZWBLt.png" alt="pPZWBLt.png"></li>
</ul>
</li>
</ul>
</li>
<li>例题<ul>
<li>例1：<strong>总结：回复字段中的序号为上一个字段的ack；回复字段的ack为上一个字段的序号+数据载荷</strong>，如本题选B<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPeJfoV.png" alt="pPeJfoV.png"></li>
</ul>
</li>
<li>例2：至少的时间时，此时服务器端的两次发送可以合并为一次，由图像可知，客户端时间为：RTT+2MSL；<br>服务器端时间为：1.5RTT。此题选D<ul>
<li><img src="https://s1.ax1x.com/2023/08/10/pPeN3GT.png" alt="pPeN3GT.png"></li>
</ul>
</li>
<li>例3：甲与乙建立TCP连接时发送的SYN段中的序号为1000，则在数据传输阶段所用起始序号为1001，在断开连接时，甲发送给乙的FIN段中的序号为5001，在无任何重传的情况下，甲向乙已经发送的应用层数据的字节数为5001-1001=4000。<ul>
<li><img src="https://s1.ax1x.com/2023/08/10/pPeNgLd.png" alt="pPeNgLd.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-TCP可靠传输"><a href="#4-TCP可靠传输" class="headerlink" title="4.TCP可靠传输"></a>4.TCP可靠传输</h4><ul>
<li>TCP提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样<br>TCP使用了校验、序号、确认和重传等机制来达到这一目的。<strong>其中，TCP的校验机制与UDP校验一样，只需要将17改为6</strong></li>
<li>序号<ul>
<li>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，<br>序号建立在传送的字节流之上，而不建立在报文段之上</li>
<li>TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。</li>
</ul>
</li>
<li>确认<ul>
<li>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传</li>
<li><strong>TCP采用了对报文段确定的机制</strong></li>
<li>TCP默认使用累积确认，即TCP只确认数据流中至第一个丢失字节为止的字节。</li>
</ul>
</li>
<li>重传<ul>
<li>超时重传<ul>
<li>TCP每发送一个报文段，就对这个报文段设置一次计时器。<br>计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段</li>
<li>TCP采用一种自适应算法，TCP保留了RTT的一个加权平均往返时间RTTs<br>它会随新测量RTT样本值的变化而变化</li>
<li>超时计时器设置的超时重传时间(RTO)应略大于RTTs,但也不能大太多，否则当报文段丢失时，TCP不能很快重传，导致数据传输时延大。</li>
</ul>
</li>
<li>快速重传<ul>
<li>每当比期望序号大的<u>失序报文</u>段到达时接收方时，发送一个冗余ACK给发送方（丢失报文之前正确接收到的报文的ACK）</li>
<li>当发送方收到三个这样的ACK后，立即重传之前丢失的报文，即为快速重传</li>
<li>例<ul>
<li>本题选C<img src="https://s1.ax1x.com/2023/08/09/pPeJxJO.png" alt="pPeJxJO.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-TCP流量控制（♚）"><a href="#5-TCP流量控制（♚）" class="headerlink" title="5.TCP流量控制（♚）"></a>5.TCP流量控制（♚）</h4><ul>
<li><p>TCP提供流量控制服务来消除发送方由于发送速率太快使接收方缓存区溢出的可能性<br>TCP提供一种基于滑动窗口协议的流量控制机制，发送方发送数据的量由接收方决定</p>
</li>
<li><p>在流量控制中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口rwnd<br>即调整TCP报文段首部中的“窗口”字段值，来限制发送方向网络注入报文的速率</p>
<ul>
<li>发送方根据其对当前网络拥塞程度的估计而确定的窗口值，这称为拥塞窗口cwnd，其大小与网络的带宽和时延密切相关</li>
</ul>
</li>
<li><p>TCP流量控制的过程</p>
<ul>
<li>接收方设置确认报文段首部的窗口字段来将rwnd通知给发送方，rwnd即接收方允许连续接收的最大能力，单位是字节。</li>
<li>发送方总是根据最新收到的rwmd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内<br>保证不会使接收方的接收缓存溢出。</li>
<li>发送方的发送窗口的实际大小取rwnd和cwmd中的最小值</li>
<li>示例<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPZ5x3D.png" alt="pPZ5x3D.png"></li>
</ul>
</li>
</ul>
</li>
<li>传输层和数据链路层的流量控制的区别<ul>
<li>传输层定义端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制</li>
<li>数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化</li>
</ul>
</li>
</ul>
<h4 id="6-TCP拥塞控制（♚）"><a href="#6-TCP拥塞控制（♚）" class="headerlink" title="6.TCP拥塞控制（♚）"></a>6.TCP拥塞控制（♚）</h4><ul>
<li><p>拥塞控制的概念</p>
<ul>
<li>拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</li>
<li>在拥塞控制中，由发送方自己通过检测网络状况来决定发送数据的量</li>
<li>发送方的发送窗口的实际大小取rwnd和cwmd中的最小值</li>
<li>拥塞的定义<ul>
<li>当对资源需求的总和&gt;可用资源时，会出现拥塞</li>
<li>出现拥塞时，端点并不了解拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。</li>
<li>此时网络中有许多资源同时呈现供应不足→网络性能变坏→网络吞吐量将随输入负荷增大而下降</li>
</ul>
</li>
<li>拥塞控制与流量控制的区别<ul>
<li>拥塞控制是让网络能够承受现有的网络负荷，是一个<strong>全局性</strong>的过程，<br>涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制往往是指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），<br>它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li>拥塞控制和流量控制都通过控制发送方发送数据的速率来达到控制效果</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP协议的窗口</p>
<ul>
<li>接收窗口：接收方根据接受缓存设置的窗口值，并告知给发送方，反映接收方容量</li>
<li>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量</li>
<li>发送窗口的<strong>上限</strong>取决于接收窗口和拥塞窗口中最小的那个</li>
<li>注意区分接收缓存与接收窗口（接收缓存&gt;=接收窗口，接收窗口=接收缓存-在缓存中的数据）<ul>
<li>例：发送窗口的上限值=min{接收窗口，拥塞窗口}。4个RTT后，乙收到的数据全部存入缓存，不被取走，<br>此时接收窗口只剩下1KB(16-1-2-4-8=1)的空间，虽然拥塞窗口此时为16，但是发送窗口是取其中较小的值（接收窗口1KB）选A<ul>
<li><img src="https://s1.ax1x.com/2023/08/10/pPeUgpT.png" alt="pPeUgpT.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>拥塞控制的4种算法（计算某时刻的拥塞窗口大小）</p>
<ul>
<li><p>慢开始和拥塞避免算法</p>
<ul>
<li>慢开始和拥塞避免算法的概念<ul>
<li>慢开始算法<ul>
<li>在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段，<br>目的是试探一下网络的拥塞情况（初始值由最大段长MSS决定）</li>
<li>之后每经过一个传输轮次(即往返时延RTT)，cwnd就会加倍，即cwnd的值随传输轮次指数规律增长。</li>
<li>慢开始一直把cwnd增大到一个规定的慢开始门限ssthresh（阈值），然后改用拥塞避免算法</li>
</ul>
</li>
<li>拥塞避免算法<ul>
<li>拥塞避免算法的思路是让拥塞窗口cwmd缓慢增大，每经过一个往返时延RTT就把发送方的拥塞窗口cwmd加1，<br>而不是加倍，使拥塞窗口cwmd按线性规律缓慢增长（即加法增大）</li>
<li>根据cwnd的大小执行不同的算法，可归纳如下<ul>
<li>当cwnd&lt;ssthresh时，使用慢开始算法</li>
<li>当cwmd&gt;ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当cwnd=ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法</li>
</ul>
</li>
</ul>
</li>
<li>乘法减少和加法增加<ul>
<li>乘法减小<ul>
<li>不论是在慢开始阶段还是在拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞），<br>就把慢开始门限值ssthresh设置为当前拥塞窗口的一半（并执行慢开始算法）</li>
<li>当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入网络的分组数。</li>
</ul>
</li>
<li>加法增加<ul>
<li>执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个RTT)，就把拥塞窗口cwd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>慢开始和拥塞避免算法的执行过程<ul>
<li><strong>初始时，拥塞窗口设置为1，即cwnd=1</strong>，慢开始门限置为16，即ssthresh=16<br><strong>（初始值由最大段长MSS决定，一般为1）</strong></li>
<li>慢开始阶段，cwnd的初值为1，以后发送方每收到一个确认ACK，cwnd值加1，<br>也即经过每个传输轮次(RTT)，cwnd呈<strong>指数规律增长</strong>（第一次RTT后为2，第二次RTT后为4）</li>
<li><strong>注意区分第n次传输时与第n个RTT之后（第n个RTT内发送的都得到应答）的拥塞窗口大小的区别</strong></li>
<li>当拥塞窗口cwnd增长到<u>慢开始门限</u>ssthresh时(即当cwnd=l6时)，就改用拥塞避免算法，cwmd按<strong>线性规律增长</strong>（16,17,18……）<ul>
<li><strong>在慢开始（指数级增长）阶段，若2cwnd&gt;ssthresh，则下一个RTT后的cwmd等于ssthresh，而不等于2cwnd</strong><br><strong>即cwmd不能跃过ssthresh值。</strong></li>
<li><strong>如在第16个轮次时cwmd=8、ssthresh=12，则在第17个轮次时cwnd=12，而不等于16。</strong></li>
</ul>
</li>
<li><strong>假定cwmd=24时网络出现超时，更新ssthresh值为I2(即变为超时时cwnd值的一半)，cwnd重置为1，并执行慢开始算法，当cwmd=I2时，改为执行拥塞避免算法，待增加到超时时又重新慢开始</strong></li>
<li>图片（掌握过程）（注：MSS的值决定了初始的拥塞窗口大小的值，如果为2则为：2/4/8……）<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPZqe2V.png" alt="pPZqe2V.png"></li>
</ul>
</li>
<li>例题<ul>
<li>例1：<strong>注意：此时问的是第13次传输时拥塞窗口的大小，即为第13个次序时窗口的值，如果问的是第13次RTT后窗口的值，那么此时的值为第14个次序时窗口的值</strong>（1/2/4/8/9/10/11/12/1/2/4/6/7，选C）<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPeJMa6.png" alt="pPeJMa6.png"></li>
</ul>
</li>
<li>例2：最长的时间显然就是此时已经在门限值之上并一直做加法增加的情况，（32-8）*2=48，选D<ul>
<li><img src="https://s1.ax1x.com/2023/08/10/pPeNiIP.png" alt="pPeNiIP.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>快重传和快恢复算法</p>
<ul>
<li><p>快重传</p>
<ul>
<li>快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测<br>丢了包当然意味着网络可能出现了拥塞</li>
<li>快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段</li>
<li>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，<br>而不必等待那个报文段设置的重传计时器超时</li>
</ul>
</li>
<li><p>快恢复算法</p>
<ul>
<li>当发送方连续收到三个冗余ACK（即重复确认）时，执行“乘法减小”算法，<br>把慢开始门限ssthresh设置为此时发送方cwnd的一半。这是为了预防网络发生拥塞。</li>
<li><p><strong>此时跳过拥塞窗口cwnd从1起始的慢开始过程，把cwnd值设置为慢开始门限ssthresh改变后的数值，</strong><br>然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPZLwlV.png" alt="pPZLwlV.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两组算法的适用情况</p>
<ul>
<li><strong>在TCP连接建立和网络出现超时时，采用慢开始和拥塞避免算法（只要看到题干中有超时就用此方法）</strong><ul>
<li>例：此时使用的是慢开始与拥塞避免算法，注意题干中为：这些报文段均得到确认之后，即为1,2,4,8,16（选B）<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPeGBv9.png" alt="pPeGBv9.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>当发送方接收到冗余ACK时，采用快重传和快恢复算法</strong><ul>
<li>例：此时使用的是快重传与快恢复算法，注意题干中为：这些报文得到确认之后，即为17,18,19,20,21（选D）<ul>
<li><img src="https://s1.ax1x.com/2023/08/09/pPeGvvj.png" alt="pPeGvvj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第四章-网络层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h2 id="计算机网络第四章-网络层"><a href="#计算机网络第四章-网络层" class="headerlink" title="计算机网络第四章-网络层"></a>计算机网络第四章-网络层</h2><blockquote>
<p>计算机学科基础：计算机网络第四章网络层的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-网络层的功能（✠）"><a href="#一-网络层的功能（✠）" class="headerlink" title="一.网络层的功能（✠）"></a>一.网络层的功能（✠）</h3><h4 id="1-异构网络互联"><a href="#1-异构网络互联" class="headerlink" title="1.异构网络互联"></a>1.异构网络互联</h4><ul>
<li>定义<ul>
<li>网络互连是指将两个以上的计算机网络，通过一定的方法，用一些中间设备（又称中继系统）相互连接起来，<br>以构成更大的网络系统。</li>
<li>网络互连通常是指用路由器进行网络互连和路由选择</li>
<li>互联网在网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</li>
</ul>
</li>
<li>中继系统的分类<ul>
<li>物理层中继系统：转发器，集线器。</li>
<li>数据链路层中继系统：网桥或交换机。</li>
<li>网络层中继系统：路由器。</li>
<li>网络层以上的中继系统：网关</li>
</ul>
</li>
<li>TCP/IP体系在网络互连上采用的做法是在网络层采用标准化协议，但相互连接的网络可以是异构的<br>异构是指物理层与数据链路层均不同</li>
</ul>
<h4 id="2-路由与转发"><a href="#2-路由与转发" class="headerlink" title="2.路由与转发"></a>2.路由与转发</h4><ul>
<li>路由选择（确定哪一条路径）<ul>
<li>按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由</li>
<li>根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表</li>
</ul>
</li>
<li>分组转发（当一个分组到达时所采取的动作）<ul>
<li>路由器根据转发表将用户的IP数据报从合适的端口转发出去。</li>
<li>路由表是根据路由选择算法得出的，而转发表是从路由表得出的。<br>在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</li>
</ul>
</li>
</ul>
<h4 id="3-SDN的基本概念"><a href="#3-SDN的基本概念" class="headerlink" title="3.SDN的基本概念"></a>3.SDN的基本概念</h4><ul>
<li>软件定义网络采用集中式的控制平面和分布式的数据平面，两个平面相互分离，|<br>控制平面利用控制-数据接口对数据平面上的路由器进行集中式控制，方便软件来控制网络</li>
<li>通过Openflow协议（也可以通过其他途径）将转发表（在SDN中称为流表）下发给路由器。<br>路由器的工作很单纯，即收到分组、查找转发表、转发分组。</li>
<li>SDN提供的编程接口称为北向接口，北向接口提供了一系列丰富的API，<br>开发者可以在此基础上设计自己的应用，而不必关心底层的硬件细节。</li>
<li>SDN控制器和转发设备建立双向会话的接口称为南向接口，通过不同的南向接口协议(如Openflow)，<br>SDN控制器就可兼容不同的硬件设备，同时可以在设备中实现上层应用的逻辑。</li>
<li>SDN控制器集群内部控制器之间的通信接口称为东西向接口，用于增强整个控制平面的可靠性和可拓展性</li>
<li>SDN的优点：<ul>
<li>全局集中式控制和分布式高速转发，既利于控制平面的全局优化，又利于高性能的网络转发</li>
<li>灵活可编程与性能的平衡，控制和转发功能分离后，使得网络可以由专有的自动化工具以编程方式配置</li>
<li>降低成本，控制和数据平面分离后，尤其是在使用开放的接口协议后，就实现了网络设备的制造与功能软件的开发相分离，从而有效降低了成本。</li>
</ul>
</li>
<li>SDN的问题<ul>
<li>安全风险，集中管理容易受攻击，如果崩溃，整个网络会受到影响。</li>
<li>瓶颈问题，原本分布式的控制平面集中化后，随着网络规模扩大，控制器可能成为网络性能的瓶颈。</li>
</ul>
</li>
</ul>
<h4 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4.拥塞控制"></a>4.拥塞控制</h4><ul>
<li>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞。此时通信子网的负载增加<br>导致吞吐量降低</li>
<li>流量控制和拥塞控制的区别<ul>
<li>流量控制往往是指在发送端和接收端之间的点对点通信量的控制。<br>流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li>拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，<br>涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。</li>
</ul>
</li>
<li>拥塞控制的方法<ul>
<li>开环控制<ul>
<li>在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。这是一种静态的预防方法，<br>一旦整个系统启动并运行，中途就不再需要修改。</li>
<li>开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度策略等。<br>所有这些手段的共性是，在做决定时不考虑当前网络的状态。</li>
</ul>
</li>
<li>闭环控制<ul>
<li>事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测哪里发生了拥塞，<br>然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。</li>
<li>闭环控制是基于反馈环路的概念，是一种动态的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二-路由算法"><a href="#二-路由算法" class="headerlink" title="二.路由算法"></a>二.路由算法</h3><h4 id="1-静态路由与动态路由"><a href="#1-静态路由与动态路由" class="headerlink" title="1.静态路由与动态路由"></a>1.静态路由与动态路由</h4><ul>
<li>静态路由算法（又称非自适应路由算法）<ul>
<li>由网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，<br>网络管理员需要手工去修改路由表中相关的静态路由信息。</li>
<li>它不能及时适应网络状态的变化，对于简单的小型网络，可以采用静态路由。</li>
</ul>
</li>
<li>动态路由算法（又称自适应路由算法）<ul>
<li>路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，<br>而这些路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优的寻路效果</li>
<li>静态路由算法的特点是简便和开销较小，在拓扑变化不大的小网络中运行效果很好。<br>动态路由算法能改善网络的性能并有助于流量控制</li>
<li>但算法复杂，会增加网络的负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性</li>
<li>常用的动态路由算法可分为两类：距离-向量路由算法和链路状态路由算法。</li>
</ul>
</li>
</ul>
<h4 id="2-距离-向量路由算法"><a href="#2-距离-向量路由算法" class="headerlink" title="2.距离-向量路由算法"></a>2.距离-向量路由算法</h4><ul>
<li>在距离-向量路由算法中，<strong>所有结点</strong>都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。<br>这种路由选择表包含：每条路径的目的地（另一结点）、路径的代价（也称距离）</li>
<li>所有的结点都监听从其他结点传来的路由选择更新信息，并在下列情况下更新它们的路由选择表<ul>
<li>被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。</li>
<li>发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离（较小的代价）<br>此种情况下，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由</li>
</ul>
</li>
<li>距离-向量路由算法的实质<ul>
<li>迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短（最小代价）通路。<br>它要求每个结点在每次更新时都将它的全部路由表发送给所有相邻的结点。</li>
<li>更新报文的大小与通信子网的结点个数成正比，所有结点都将参加路由选择信息交换</li>
<li>最常见的距离-向量路由算法是RIP算法，它采用“跳数”作为距离的度量</li>
</ul>
</li>
<li>在距离-向量路由协议中，“好消息传得快，而坏消息传得慢”，<br>这就导致了当路由信息发生变化时，该变化未能及时地被所有路由器知道，而仍然可能在路由器之间进行传递，这就是“慢收敛”现象。慢收敛是导致发生路由回路的根本原因。</li>
</ul>
<h4 id="3-链路状态路由算法"><a href="#3-链路状态路由算法" class="headerlink" title="3.链路状态路由算法"></a>3.链路状态路由算法</h4><ul>
<li>链路状态路由算法的过程<ul>
<li>在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，<br>而不是仅送给那些直接相连的结点。每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息。</li>
<li>每当链路状态报文到达时，路由结点便使用这些状态信息去更新自己的网络拓扑和状态“视野图”</li>
<li>一旦链路状态发生变化，结点就对更新的网络图利用Dijkstra最短路径算法重新计算路由，从单一的源出发计算到达所有目的结点的最短路径。</li>
</ul>
</li>
<li>链路状态路由算法的特点<ul>
<li>每个参与该算法的结点都具有完全的网络拓扑信息并执行下述两项任务<ul>
<li>主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。</li>
<li>定期地将链路状态传播给所有其他结点（或称路由结点）</li>
</ul>
</li>
<li>向本自治系统中所有路由器发送信息，使用洪泛法，即路由器通过所有端口向所有相邻的路由器发送信息；<br>而每个相邻路由器又将此信息发往其所有相邻路由器（但不再发送给刚刚发来信息的那个路由器）</li>
<li>发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul>
<li>“链路状态”是指说明本路由器与哪些路由器相邻及该链路的“度量”</li>
<li>对于OSPF算法，链路状态的“度量”主要用来表示费用、距离、时延、带宽等。</li>
</ul>
</li>
<li>只有当链路状态发生变化时，路由器才向所有路由器发送此信息。由于一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。</li>
<li>典型的链路状态算法是OSPF算法。</li>
</ul>
</li>
<li><p>链路状态路由算法的优点</p>
<ul>
<li>每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算<br>链路状态报文不加改变地传播，因此采用该算法易于查找故障。</li>
<li>当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。</li>
<li>由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关，<br>因此链路状态算法比距离-向量算法有更好的规模可伸展性。</li>
</ul>
</li>
<li><p>距离-向量路由算法与链路状态路由算法的比较</p>
<ul>
<li>在距离-向量路由算法中，每个结点仅与它的直接邻居交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计。</li>
<li>在链路状态路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链路的费用。<br>相较之下，距离-向量路由算法有可能遇到路由环路等问题。</li>
</ul>
</li>
</ul>
<h4 id="4-层次路由（✠）"><a href="#4-层次路由（✠）" class="headerlink" title="4.层次路由（✠）"></a>4.层次路由（✠）</h4><ul>
<li>路由选择必须按照层次的方式进行，因特网将整个互联网划分为许多较小的自治系统（注意一个自治系统中包含很多局域网）<br>每个自治系统有权自主地决定本系统内应采用何种路由选择协议。</li>
<li>如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。</li>
<li>因特网把路由选择协议划分为两大类<ul>
<li>一个自治系统内部所使用的路由选择协议称为<strong>内部网关协议(IGP)</strong>，也称域内路由选择，具体的协议有<u>RIP和OSPF</u>等。</li>
<li>自治系统之间所使用的路由选择协议称为<strong>外部网关协议(EGP)</strong>，也称域间路由选择，<br>用在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有<u>BGP</u></li>
</ul>
</li>
<li>使用层次路由时，OSPF将一个自治系统再划分为若干区域(Area)，每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。</li>
<li>采用分层次划分区域的方法虽然会使交换信息的种类增多，也会使OSPF协议更加复杂。<br>但这样做却能使每个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模很大的自治系统中。</li>
</ul>
<h3 id="三-IPV4（✪）"><a href="#三-IPV4（✪）" class="headerlink" title="三.IPV4（✪）"></a>三.IPV4（✪）</h3><h4 id="1-IPV4分组"><a href="#1-IPV4分组" class="headerlink" title="1.IPV4分组"></a>1.IPV4分组</h4><ul>
<li>IPv4分组的格式<ul>
<li>一个IP分组由首部和数据部分组成。首部前一部分的长度固定，共20B，是所有IP分组必须具有的。</li>
<li>在首部固定部分的后面是一些可选字段，其长度可变，用来提供错误检测及安全等机制。</li>
<li>首部中的一些重要字段<ul>
<li>版本<ul>
<li>指 IP 协议的版本, 目前广泛使用的版本号为 4 </li>
</ul>
</li>
<li>首部长度<ul>
<li>占 4 位，可以表示的最大十进制数是 15 。以 32 位为单位，最大值为${60 \mathrm{B}}{(15 \times 4 \mathrm{B})}$。<br>最常用的首部长度是${20 \mathrm{B}}$, 此时不使用任何选项（即可选字段）。</li>
</ul>
</li>
<li>总长度<ul>
<li>占 16 位。指首部和数据之和的长度，单位为字节，因此数据报的最大长度为${2^{16}-1=65535 \mathrm{B}}$。</li>
<li>以太网帧的最大传送单元 (MTU) 为${1500 \mathrm{B}}$， 因此当一个 IP 数据报封装成帧时,<br>数据报的总长度 (首部加数据) 一定不能超过下面的数据链路层的 MTU 值。</li>
</ul>
</li>
<li>标识<ul>
<li>占 16 位。它是一个计数器，每产生一个数据报就加 1 , 并赋值给标识字段。但它并不是 “序号” (因为 IP 是无连接服务)</li>
<li>当一个数据报的长度超过网络的 MTU 时，必须分片，此时每个数据报片都复制一次标识号, 以便能正确重装成原来的数据报。 </li>
</ul>
</li>
<li>标志<ul>
<li>占 3 位。标志字段的最低位为${M F, M F=1}$表示后面还有分片, $MF{=0}$表示最后一个分片</li>
<li>标志字段中间的一位是 DF，只有当 DF${=0}$ 时才允许分片。</li>
</ul>
</li>
<li>片偏移<ul>
<li>占 13 位。它指出较长的分组在分片后, 某片在原分组中的相对位置。</li>
<li>片偏移以 8 个字节为偏移单位。除最后一个分片外, 每个分片的长度一定是${8 \mathrm{B}}$的整数倍。</li>
</ul>
</li>
<li>生存时间 (TTL)<ul>
<li>占 8 位。数据报在网络中可通过的路由器数的最大值, 标识分组在网络中的寿命, 以确保分组不会永远在网络中循环。<br>路由器在转发分组前, 先把 TTL 减 1 。 若 TTL 被减为 0 , 则该分组必须丢弃。（一个分组可以经过的最多的跳数）</li>
</ul>
</li>
<li>协议<ul>
<li>占 8 位。指出此分组携带的数据使用何种协议, 即分组的数据部分应上交给哪个协议进行处理, 如 TCP、UDP 等。</li>
<li>其中值为 6 表示 TCP, 值为 17 表示 UDP。</li>
</ul>
</li>
<li>首部校验和<ul>
<li>占 16 位。<u>首部校验和只校验分组的首部</u>, 而不校验数据部分。 </li>
</ul>
</li>
<li>源地址字段：占 4B, 标识发送方的 IP 地址。</li>
<li>目的地址字段：占 4B, 标识接收方的 IP 地址。</li>
</ul>
</li>
<li><strong>注意，在IP数据报首部中有三个关于长度的标记，首部长度、总长度、片偏移，</strong><br><strong>基本单位分别为4B、1B、8B（需要记住）。题目中经常会出现这几个长度之间的加减运算。</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/05/pPkv8ht.png" alt="pPkv8ht.png"></li>
</ul>
</li>
</ul>
</li>
<li>IP数据报分片<ul>
<li>分片的流程<ul>
<li>创建一个 IP 数据报时, 源主机为该数据报加上一个标识号。</li>
<li>当一个<u>中间路由器</u>需要将一个数据报分片时, 形成的每个数据报 (即片) 都具有原始数据报的标识号。</li>
<li>当 IP 数据报的总长度大于链路层 MTU 时, 就需要将 IP 数据报中的数据分装在多个较小的 IP 数据报中, 这些较小的数据报称为片。</li>
<li>片在<u>目的主机网络层</u>被重新组装。目的主机使用 IP 首部中的标识、标志和片偏移字段来完成对片的重组。</li>
<li>当目的主机收到来自同一发送主机的一批数据报时, 它可以通过检查数据报的标识号来确定哪些数据报属于同一个原始数据报的片。</li>
<li>目的主机在对片进行重组时, 使用片偏移字段来确定片应放在原始 IP 数据报的哪个位置。</li>
</ul>
</li>
<li>标志位<ul>
<li>IP 首部中的标志位占 3 位, 但只有后 2 位有意义, 分别是 MF 位 (More Fragment) 和 DF 位 (Don’t Fragment)。</li>
<li>只有当 $DF{=0}$时，该 IP 数据报才可以被分片。</li>
<li>$MF$ 则用来告知目的主机该 IP 数据报是否为原始数据报的最后一个片。<ul>
<li>当${\mathrm{MF}=1}$时, 表示相应的原始数据报还有后续的片</li>
<li>当${\mathrm{MF}=0}$时, 表示该数据报是相应原始数据报的最后一个片。</li>
</ul>
</li>
</ul>
</li>
<li>分片的例子<ul>
<li>一个长 4000B 的 IP 数据报 (首部 20B, 数据部分${3980 \mathrm{B}}$) 到达一个路由器, 需要转发到一条 MTU 为${1500 \mathrm{B}}$的链路上</li>
<li>原始数据报中的${3980 \mathrm{B}}$数据必须被分配到 3 个独立的片中 (每片也是一个 IP 数据报)。</li>
<li>由于偏移值的单位是${8 \mathrm{B}}$, 所以除最后一个片外, 其他所有片中的有效数据载荷都是 8 的倍数。</li>
<li>$片偏移=（之前分片的总数据-20<em>(分片序数-1)/8$，如第三个分片的偏移量为（3000-20</em>2）/ 8<br>第二个分片的偏移量为：（1500-20）/ 8</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/05/pPkzGy8.png" alt="pPkzGy8.png"></li>
</ul>
</li>
</ul>
</li>
<li>例题<ul>
<li>此时不仅要满足最大分片数量这个条件，还需要满足片偏移的数据量是8的倍数的条件，以第一个分片为准，其可能的数据量为：800-20=780，780中满足8的倍数的最大数为776，因此第一个分片的最大长度为779。显然779*2&lt;1580，此时第二个分片的MF标志位为1，总长度字段为796<br><img src="https://s1.ax1x.com/2023/08/06/pPAgJ0g.png" alt="pPAgJ0g.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-IPV4地址与NAT"><a href="#2-IPV4地址与NAT" class="headerlink" title="2.IPV4地址与NAT"></a>2.IPV4地址与NAT</h4><ul>
<li>IPv4地址（32位，由网络号与主机号组成）<ul>
<li>IP地址的分类，注意每一类的前几位是固定的数字<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAtTvn.png" alt="pPAtTvn.png"></li>
</ul>
</li>
<li>常见的三类IP地址的使用范围<ul>
<li><img src="https://s1.ax1x.com/2023/08/05/pPApPv6.png" alt="pPApPv6.png"></li>
<li>A类地址可用的网络数为$2^{7}-2$，减2的原因是<ul>
<li>第一，网络号字段全为0的IP地址是保留地址，意思是“本网络”</li>
<li>第二，网络号为127的IP地址是环回自检地址。</li>
</ul>
</li>
</ul>
</li>
<li>近年来, 由于广泛使用无分类 IP 地址进行路由选择, 这种传统分类的 IP 地址已成为历史。</li>
<li>特殊的IP地址<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAtOET.png" alt="pPAtOET.png"></li>
</ul>
</li>
<li>IP地址的特点<ul>
<li>每个 IP 地址都由网络号和主机号两部分组成，因此 IP 地址是一种分等级的地址结构。<br>分等级的好处是：<ul>
<li>IP 地址管理机构在分配 IP 地址时只分配网络号, 而主机号则由得到该网络的单位自行分配，方便了 IP 地址的管理</li>
<li>路由器仅根据目的主机所连接的网络号转发分组 (而不考虑目标主机号), 从而减小了路由表所占的存储空间。</li>
</ul>
</li>
<li>IP 地址是标志一台主机 (或路由器) 和一条链路的接口，路由器至少存在两个端口，因此路由器至少有两个IP地址</li>
<li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。路由器总是具有两个或两个以上的 IP 地址, 路由器的每个端口都有一个不同网络号的 IP 地址。</li>
<li>用转发器或桥接器 (网桥等) 连接的若干 LAN 仍然是同一个网络 (同一个广播域), 因此该 LAN 中所有主机的 IP 地址的网络必须相同, 但主机号必须不同。</li>
<li>在 IP 地址中, 所有分配到网络号的网络 (无论是 LAN 还是 WAN) 都是平等的。</li>
</ul>
</li>
</ul>
</li>
<li>网络地址转换(NAT)<ul>
<li>NAT的概述<ul>
<li>网络地址转换 (NAT) 是指通过将专用网络地址转换为公用地址，从而对外隐藏内部管理的 IP 地址。</li>
<li>它使得整个专用网只需要一个全球 IP 地址就可以与因特网连通，由于专用网本地 IP 地址是可重用的，所以NAT大大节省了 IP 地址的消耗。同时, 它隐藏了内部网络结构, 从而降低了内部网络受到攻击的风险。</li>
<li>在因特网中的所有路由器, 对目的地址是私有地址的数据报一律不进行转发。<br>这种采用私有 IP 地址的互联网络称为专用互联网或本地互联网。私有 IP 地址也称可重用地址。</li>
</ul>
</li>
<li><strong>私有网段</strong>（私有IP地址只用于 LAN, 不用于WAN连接）<ul>
<li>${\mathrm{A}}$类: 1 个${\mathrm{A}}$类网段，即${\mathbf{1 0} .0 .0 .0 \sim \mathbf{1 0} .255 .255 .255}$</li>
<li>${B}$类: 16 个${B}$类网段，即${172.16 .0 .0 \sim 172.31 .255 .255}$。</li>
<li>$C$ 类: 256 个${C}$类网段, 即 $192.168.0.0\sim192.168.255.255$。</li>
</ul>
</li>
<li>NAT路由器<ul>
<li>使用 NAT 时需要在专用网连接到因特网的路由器上安装 NAT 软件, NAT 路由器至少有一个有效的外部全球 IP 地址。<br>使用本地地址的主机和外界通信时, NAT 路由器使用 NAT 转换表进行本地 IP 地址和全球 IP 地址的转换。</li>
<li>NAT 转换表中存放着 \{本地 IP 地址: 端口 \} 到 \{全球 IP 地址: 端 口${\}}$的映射。<br>通过这种映射方式, 可让多个私有 IP 地址映射到一个全球 IP 地址。</li>
<li>当发送到NAT的分组的IP地址和端口同时在NAT转换表中有对应时才转发，只有没有两个同时对应的，就直接丢弃该分组。</li>
<li>普通路由器在转发IP数据报时，不改变其源IP地址和目的IP地址。<br>而NAT路由器在转发IP数据报时，一定要更换其IP地址(转换源IP地址或目的IP地址)。</li>
<li>普通路由器仅工作在网络层，而NAT路由器转发数据报时需要查看和转换传输层的端口号</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/05/pPAAI1J.png" alt="pPAAI1J.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-子网划分与子网掩码、CIDR（♚）"><a href="#3-子网划分与子网掩码、CIDR（♚）" class="headerlink" title="3.子网划分与子网掩码、CIDR（♚）"></a>3.子网划分与子网掩码、CIDR（♚）</h4><ul>
<li><p>子网划分</p>
<ul>
<li>子网划分的影响<ul>
<li>将原来较大的网络细分为几个规模较小的网络，减少广播域的大小，减少主机的数量（子网号占据了主机号位）</li>
<li><strong>提高IP地址的利用率，并不增加网络的数量</strong></li>
</ul>
</li>
<li>子网划分的基本思路如下:<ul>
<li>子网划分纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</li>
<li><strong>从主机号借用若干比特作为子网号, 当然主机号也就相应减少了相同的比特</strong>。三级IP地址的结构如下<br>IP 地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}。</li>
<li>凡是从其他网络发送给本单位某台主机的 IP 数据报, 仍然是根据 IP 数据报的目的网络号, 先找到连接到本单位网络上的路由器，然后该路由器在收到 IP 数据报后, 按目的网络号和子网号找到目的子网。最后把 IP 数据报直接交付给目的主机。</li>
</ul>
</li>
<li>例<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAftK0.png" alt="pPAftK0.png"></li>
</ul>
</li>
</ul>
</li>
<li>子网掩码（定长）<ul>
<li>网络号的位上均为1，主机号的位上均为0，子网掩码与IP地址逐位相与，就得到子网网络地址</li>
<li>现在的因特网标准规定：所有的网络都必须使用子网掩码。如果一个网络未划分子网，那么就采用默认子网掩码。<ul>
<li>A、B、C类地址的默认子网掩码分别为255.0.0.0、255.255.0.0、255.255.255.0</li>
</ul>
</li>
<li>同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码</li>
<li>路由器的路由表中，所包含信息的主要内容有目的网络地址、子网掩码、下一跳地址。</li>
<li><strong>牢记下面这些常用的二进制转换关系，首先根据子网掩码判断主机号，子网号的占位，之后通过IP地址与子网掩码作与运算，求出相应的网络地址</strong><ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAUGex.png" alt="pPAUGex.png"></li>
</ul>
</li>
</ul>
</li>
<li>无分类编址（CIDR，可变长，构成超网）<ul>
<li>CIDR的概述<ul>
<li>无分类域间路由选择${\mathrm{CIDR}}$是在变长子网掩码的基础上提出的一种消除传统${\mathrm{A}}$、${\mathrm{B}}$、${\mathrm{C}}$类网络划分,<br>并且可以在软件的支持下实现超网构造的一种 IP 地址的划分方法。</li>
<li>CIDR 使用 “网络前缀” 的概念代替子网络的概念, 与传统分类 IP 地址最大的区别就是，网络前缀的位数不是固定的，可以任意选取。CIDR 的记法是：IP::${=\{&lt;}$网络前缀${&gt;,&lt;}$主机号${&gt;\}}$</li>
<li>CIDR 还使用 “斜线记法” (或称 CIDR 记法), 即 IP 地址/网络前缀所占比特数。其中, 网络前缀所占比特数对应于网络号的部分, 等效于子网掩码中连续 1 的部分</li>
<li>CIDR 的优点在于网络前缀长度的灵活性。由于上层网络的前缀长度较短，因此相应的路由表的项目较少。<br>而内部又可采用延长网络前缀的方法来灵活地划分子网</li>
</ul>
</li>
<li>CIDR地址块<ul>
<li>将网络前缀都相同的连续 IP 地址组成 “CIDR 地址块”。一个 CIDR 地址块可以表示很多地址, 这种地址的聚合称为路由聚合, 或称构成超网。</li>
<li>CIDR 地址块中的地址数一定是 2 的整数次幂, 实际可指派的地址数通常为${2^{N}-2, N}$表示主机号的位数, 主机号全0代表网络号, 主机号全 1 为广播地址。</li>
<li>网络前缀越短, 其地址块所包含的地址数就越多。而在三级结构的 IP 地址中, 划分子网使网络前缀变长。</li>
<li>例如<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAs3dA.png" alt="pPAs3dA.png"></li>
</ul>
</li>
</ul>
</li>
<li>路由聚合<ul>
<li>将两个网络地址取交集可以构成超网，实现路由聚合</li>
<li>路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由, 有利于减少路由器之间的信息的交换, 从而提高网络性能。</li>
<li>例<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAsWyF.png" alt="pPAsWyF.png"></li>
</ul>
</li>
</ul>
</li>
<li>最长前缀匹配 (最佳匹配)<ul>
<li>使用 CIDR 时, 路由表中的每个项目由 “网络前缀” 和 “下一跳地址” 组成。</li>
<li>使用路由表中的网络地址与IP地址做与运算，如果匹配则待定</li>
<li>在查找路由表时可能会得到不止一个匹配结果。此时, 应当从匹配结果中选择具有最长网络前缀的路由, 因为网络前缀越长, 其地址块就越小, 因而路由就越具体。</li>
</ul>
</li>
</ul>
</li>
<li>网络层转发分组的过程<ul>
<li>转发表中两个特殊的路由<ul>
<li>主机路由<ul>
<li>对特定目的主机的IP地址专门指明一个路由，以方便网络管理员控制和测试网络。</li>
<li>若特定主机的IP地址是a.b.c.d,则转发表中对应项的目的网络是a.b.c.d/32<br>32表示的子网掩码没有意义，但这个特殊的前缀可以用在转发表中。</li>
</ul>
</li>
<li>默认路由<ul>
<li>用特殊前缀0.0.0.0/0表示默认路由，全0掩码和任何目的地址进行按位与运算，结果必然为全0<br>必然和转发表中的0.0.0.0/0相匹配</li>
<li>只要目的网络是其他网络（不在转发表中），就一律选择默认路由。<br>与其它表项都不匹配时</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>从收到的 IP 分组的首部提取目的主机的 IP 地址${D}$(即目的地址)。</li>
<li>若查找到特定主机路由 (目的地址为${D}$), 就按照这条路由的下一跳转发分组<br>否则从转发表中的下一条 (即按前缀长度的顺序) 开始检查</li>
<li>将这一行的子网掩码与目的地址${D}$进行按位与运算。若运算结果与本行的前缀匹配，则查找结束，按照 “下一跳” 指出的进行处理 (或者直接交付本网络上的目的主机, 或通过指定接口发送到下一跳路由器)。否则, 若转发表还有下一行, 则对下一行进行检查</li>
<li>若转发表中有一个默认路由, 则把分组传送给默认路由; 否则, 报告转发分组出错。</li>
<li>例题<ul>
<li>此时先从前缀最长的开始检查，子网掩码为22的项与分组目的地址不匹配，之后看子网掩码为11的目的网络，<br>此时可以匹配，于是从R2转发出去<br><img src="https://s1.ax1x.com/2023/08/06/pPAJ7Gj.png" alt="pPAJ7Gj.png"></li>
</ul>
</li>
</ul>
</li>
<li>注意 <ul>
<li>得到下一跳路由器的 IP 地址后, 并不是直接将该地址填入待发送的数据报, 而是将该IP地址转换成 MAC 地址 (通过 ARP)<br>将此 MAC 地址放到 MAC 帧首部中, 然后根据这个 MAC 地址找到下一跳路由器。</li>
<li>在不同网络中传送时, MAC 帧中的源地址和目的地址要发生变化, 但是网桥在转发帧时, 不改变帧的源地址, 请注意区分。<br>IP数据报头部的源地址与目的地址不发生变化（没有NAT的情况下）</li>
</ul>
</li>
</ul>
</li>
<li>相关例题<ul>
<li>例1：首先B类地址要划分子网的话，还有主机位的16位可以划分，再通过主机数目求得主机位数，之后可以求得相应的子<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPARLlt.png" alt="pPARLlt.png"></li>
</ul>
</li>
<li>例2：用填充法来划分相应的情况，划分出五种即可<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAfWVO.png" alt="pPAfWVO.png"></li>
</ul>
</li>
<li>例3：此时需要将各个网络可划分的情况列举出来，看是否满足3个子网下刚好契合<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAhCMq.png" alt="pPAhCMq.png"></li>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAhAdU.png" alt="pPAhAdU.png"></li>
</ul>
</li>
<li>例4：首先目的地址一定就是web服务器的地址，但是源地址需要将私有地址经过NAT路由器进行转换，<br>此时根据NAT路由器链路的网段信息（题干中），此时只剩下两个主机位，只有可能是01或10，于是选符合条件的D选项<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAhzTO.png" alt="pPAhzTO.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-ARP、DHCP与ICMP"><a href="#4-ARP、DHCP与ICMP" class="headerlink" title="4.ARP、DHCP与ICMP"></a>4.ARP、DHCP与ICMP</h4><ul>
<li><p>IP 地址与硬件地址</p>
<ul>
<li>IP 地址是网络层使用的地址, 它是分层次等级的。</li>
<li>硬件地址是数据链路层使用的地址 (MAC 地址), 它是平面式的。</li>
<li>在 IP 层抽象的互联网上只能看到 IP 数据报，虽然在 IP 数据报首部中有源 IP 地址，但路由器只根据目的 IP 地址进行转发。</li>
<li>在局域网的链路层, 只能看见 MAC 帧。IP 数据报被封装在 MAC 帧中, 通过路由器转发 IP 分组时, 会重新封装源硬件地址和目的硬件地址</li>
</ul>
</li>
<li><p>地址解析协议 (ARP，网络层协议)</p>
<ul>
<li>使用ARP协议来完成IP地址到MAC地址的映射</li>
<li>每台主机都设有一个 ARP 高速缓存, 用来存放本局域网上各主机和路由器的 IP 地址到 MAC 地址的映射表, 称 ARP 表。<br>使用 ARP 来动态维护此 ARP 表。</li>
<li>ARP的原理（工作在网络层）<ul>
<li>主机 A 欲向本局域网上的某台主机 B 发送 IP 数据报时, 先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。</li>
<li>如果有, 就可查出其对应的硬件地址, 再将此硬件地址写入 MAC 帧, 然后通过局域网将该 MAC 帧发往此硬件地址。</li>
<li>如果没有, 那么就通过使用目的 MAC 地址为 FFFF-FF-FF-FF-FF 的帧来封装并广播 ARP 请求分组 (广播发送), 使同一个局域网里的所有主机都收到此 ARP 请求。<strong>尽管 ARP 请求分组是广播发送的, 但 ARP 响应分组是普通的单播</strong>，即从一个源地址发送到一个目的地址。</li>
<li>主机 B 收到该 ARP 请求后, 向主机 A 发出 ARP 响应分组 (单播发送), 分组中包含主机 B 的 IP 与 MAC 地址的映射关系, 主机 A 收到 ARP 响应分组后就将此映射写入 ARP 缓存, 然后按查询到的硬件地址发送 MAC 帧。</li>
<li>如果所要找的主机和源主机不在同一个局域网上, 那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址<br>然后把分组发送给这个路由器, 让这个路由器把分组转发给下一个网络。 剩下的工作就由下一个网络来做</li>
<li>例<ul>
<li>首先主机通过ARP找到局域网内的路由器，再经过路由器之间的4次使用ARP协议到达B所造的路由器，最后此路由器再使用一次ARP协议即可找到主机B，一共进行了6次<br><img src="https://s1.ax1x.com/2023/08/06/pPAtVcn.png" alt="pPAtVcn.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>动态主机配置协议 (DHCP，应用层协议) </p>
<ul>
<li>常用于给主机动态地分配 IP 地址, 它提供了即插即用的联网机制<br>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与，<strong>DHCP 是应用层协议, 它是基于 UDP 的。</strong></li>
<li>DHCP 的工作原理如下<ul>
<li>使用客户/服务器（C/S）模式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>本地网络上所有主机都能收到此广播报文, 但只有 DHCP 服务器才回答此广播报文。</li>
<li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。</li>
<li>若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。DHCP 服务器的回答报文称为提供报文。</li>
</ul>
</li>
<li>DHCP的特点<ul>
<li>DHCP 允许网络上配置多台 DHCP 服务器, 当 DHCP 客户机发出 “DHCP 发现” 消息时, 有可能收到多个应答消息。<br>这时, DHCP 客户机只会挑选其中的一个, 通常挑选最先到达的。</li>
<li>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的, 因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址DHCP 称这段时间为租用期。租用期的数值应由 DHCP 服务器自己决定, DHCP 客户也可在自己发送的报文中提出对租用期的要求。</li>
<li><strong>DHCP 的客户端和服务器端需要通过广播方式来进行交互</strong>, 原因是在 DHCP 执行初期, 客户端不知道服务器端的 IP 地址, 而在执行中间，客户端并未被分配 IP 地址, 从而导致两者之间的通信必须采用广播的方式。</li>
<li>采用 UDP 而不采用 TCP 的原因也很明显：TCP 需要建立连接, 如果连对方的 IP 地址都不知道, 那么更不可能通过双方的套接字建立连接。</li>
<li>DHCP 是应用层协议, 因为它是通过客户/服务器模式工作的, DHCP 客户端向 DHCP 服务器请求服务, 而其他层次的协议是没有这两种工作方式的</li>
</ul>
</li>
</ul>
</li>
<li><p>网际控制报文协议 (ICMP，网络层协议)</p>
<ul>
<li><p>为了提高 IP 数据报交付成功的机会, 在网络层使用了网际控制报文协议 (ICMP) 来让主机或路由器报告差错和异常情况。</p>
</li>
<li><p><strong>ICMP 报文作为 IP 层数据报的数据, 加上数据报的首部, 组成 IP 数据报发送出去。</strong></p>
</li>
<li><p>ICMP 报文的种类</p>
<ul>
<li><p>ICMP 差错报告报文</p>
<ul>
<li>ICMP 差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。</li>
<li>种类<ul>
<li>终点不可达，当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。</li>
<li>源点抑制，当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，<br>使源点知道应当把数据报的发送速率放慢</li>
<li>时间超过，当路由器收到生存时间(TTL)为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。<br>当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>
<li>参数问题，当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li>
<li>改变路由（重定向），路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li>
</ul>
</li>
<li>不应发送ICMP差错报告报文的几种情况如下<ul>
<li>对ICMP差错报告报文不再发送ICMP差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li>
<li>对具有组播地址的数据报都不发送ICMP差错报告报文。</li>
<li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</li>
</ul>
</li>
</ul>
</li>
<li><p>ICMP询问报文有4种类型：回送请求和回答报文、时间戳请求和回答报文、地址掩码请求和回答报文、路由器询问和通告报文，最常用的是前两类。</p>
</li>
<li><p><strong>ICMP的两个常见应用是分组网间探测PING（用来测试两台主机之间的连通性）和Traceroute</strong></p>
<p>PING使用了ICMP回送请求和回答报文，Traceroute(Tracert)使用了ICMP时间超过报文。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四-IPV6"><a href="#四-IPV6" class="headerlink" title="四.IPV6"></a>四.IPV6</h3><h4 id="1-IPv6的主要特点"><a href="#1-IPv6的主要特点" class="headerlink" title="1.IPv6的主要特点"></a>1.IPv6的主要特点</h4><ul>
<li>IPv6的主要特点<ul>
<li><strong>IPv6将地址从32位(4B)扩大到128位(16B),更大的地址空间</strong></li>
<li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</li>
<li>IPv6支持<strong>即插即用（即自动配置），不需要DHCP协议。</strong></li>
<li>IPv6<strong>首部长度必须是8B的整数倍</strong>，IPv4首部是4B的整数倍。<br><strong>且首部长度固定为40B</strong></li>
<li><strong>IPv6中不允许分片</strong>。因此，如果路由器发现到来的数据报太大而不能转发到链路上，<br>那么丢弃该数据报，并向发送方发送一个指示分组太大的ICMP报文。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/07/pPEZyrj.png" alt="pPEZyrj.png"></li>
</ul>
</li>
</ul>
<h4 id="2-IPv6地址"><a href="#2-IPv6地址" class="headerlink" title="2.IPv6地址"></a>2.IPv6地址</h4><ul>
<li><p>IPv6数据报的三种类型</p>
<ul>
<li>单播：单播就是传统的点对点通信</li>
<li>多播：多播是一点对多点的通信，分组被交付到一组计算机的每台计算机</li>
<li>任播：这是IPv6增加的一种类型。<br>任播的目的站是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机。</li>
</ul>
</li>
<li><p>IPv6的地址表示法</p>
<ul>
<li>即把地址中的每4位用一个十六进制数表示，并用冒号分隔每16位，如4BF5:0000:0000:0000:BA5F:039A:000A:2176</li>
<li>当16位域的开头有一些0时，可以采用一种缩写表示法，但在域中必须至少有一个数字。<br>可以把地址缩写为4BF5:0:0:0:BA5F:39A:A:2176</li>
<li>当有相继的0值域时，还可以进一步缩写。这些域可以用双冒号缩写，双冒号表示法在一个地址中仅能出现一次，<br>可以写成4BF5::BA5F:39A:A:2176</li>
</ul>
</li>
</ul>
<h3 id="五-路由协议（✠）"><a href="#五-路由协议（✠）" class="headerlink" title="五.路由协议（✠）"></a>五.路由协议（✠）</h3><h4 id="1-自治系统（AS）"><a href="#1-自治系统（AS）" class="headerlink" title="1.自治系统（AS）"></a>1.自治系统（AS）</h4><ul>
<li>单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由，<br>同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由。</li>
<li>一个自治系统内的所有网络都由一个行政单位(如一家公司、一所大学、一个政府部门等)管辖，<br>一个自治系统的所有路由器在本自治系统内都必须是连通的。</li>
</ul>
<h4 id="2-域内路由与域间路由"><a href="#2-域内路由与域间路由" class="headerlink" title="2.域内路由与域间路由"></a>2.域内路由与域间路由</h4><ul>
<li>自治系统内部的路由选择称为域内路由选择，自治系统之间的路由选择称为域间路由选择</li>
<li>因特网有两大类路由选择协议<ul>
<li>内部网关协议(IGP)<ul>
<li>内部网关协议即在一个自治系统内部使用的路由选择协议，它与互联网中其他自治系统选用什么路由选择协议无关。<br>目前这类路由选择协议使用得最多，如RIP和OSPF。</li>
</ul>
</li>
<li>外部网关协议(EGP)<ul>
<li>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时（两个自治系统可能使用不同的IGP)<br>就需要使用一种协议将路由选择信息传递到另一个自治系统，目前使用最多的外部网关协议是BGP4</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-路由信息协议（RIP-✠）"><a href="#3-路由信息协议（RIP-✠）" class="headerlink" title="3.路由信息协议（RIP ✠）"></a>3.路由信息协议（RIP ✠）</h4><ul>
<li><p>RIP是一种分布式的<strong>基于距离向量</strong>的路由选择协议，其最大优点就是简单</p>
</li>
<li><p><strong>RIP是应用层协议，它使用UDP传送数据(端口520)。</strong></p>
</li>
<li><p>RIP选择的路径不一定是时间最短的，但一定是具有<strong>最少路由器的路径</strong>。因为它是根据最少跳数进行路径选择的。</p>
<p>要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）。</p>
</li>
<li><p>RIP的规定</p>
<ul>
<li>网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录（因此这是一组距离，称为距离向量）</li>
<li><strong>距离也称跳数</strong>，规定从一个路由器到直接连接网络的距离（跳数）为1。而每经过一个路由器，距离（跳数）加1</li>
<li>RIP认为好的路由就是它通过的路由器的数目少，即优先选择跳数少的路径</li>
<li><strong>RIP允许一条路径最多只能包含15个路由器(即最多允许15跳)。因此距离等于16时，它表示网络不可达</strong>。<br>RIP只适用于小型互联网。距离向量路由可能会出现环路的情况，规定路径上的最高跳数的目的是为了防止数据报不断循环在环路上，减少网络拥塞的可能性</li>
<li>RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表（动态维护）</li>
</ul>
</li>
<li><p>RIP的特点(注意与OSPF的特点比较)</p>
<ul>
<li><strong>仅和相邻路由器交换信息</strong>。</li>
<li><strong>路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。</strong></li>
<li>按固定的时间间隔交换路由信息，如每隔30秒</li>
<li>RIP通过距离向量算法来完成路由表的更新。经过若干RIP广播后，所有路由器都最终知道了整个RIP网络的路由表，<br>称为RIP最终是收敛的。</li>
<li><strong>通过RIP收敛后，每个路由器到每个目标网络的路由都是距离最短的（即跳数最少，最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。</strong></li>
</ul>
</li>
<li><p>距离向量算法（✪）</p>
<ul>
<li>每个路由表项目都有三个关键数据：&lt;目的网络N，距离d，下一跳路由器地址X&gt;</li>
<li><p>对于每个相邻路由器发送过来的RIP报文，执行如下步骤</p>
<ul>
<li><strong>对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目</strong><br><strong>把“下一跳”字段中的地址都改为X,并把所有“距离”字段的值加1</strong></li>
<li><p>对修改后的RIP报文中的每个项目，执行如下步骤</p>
<ul>
<li>当原来的路由表中没有目的网络N时，把该项目添加到路由表中</li>
<li>当原来的路由表中有目的网络N，且下一跳路由器的地址是X时，用收到的项目替换原路由表中的项目</li>
<li>当原来的路由表中有目的网络N，且下一跳路由器的地址不是X时，<br>如果收到的项目中的距离d小于路由表中的距离，那么就用收到的项目替换原路由表中的项目<br>否则什么也不做。</li>
</ul>
</li>
<li><p>如果180秒(RIP默认超时时间为180秒)还没有收到相邻路由器的更新路由表，<br>那么把此相邻路由器记为不可达路由器，即把距离设置为16(距离为16表示不可达)</p>
</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p>例1</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/07/pPEeMes.png" alt="pPEeMes.png"></li>
</ul>
</li>
<li><p>例2</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/07/pPEmE7R.png" alt="pPEmE7R.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RIP的优点：最大的优点是实现简单、开销小、收敛过程较快。</p>
</li>
<li><p>RIP的缺点（✪）</p>
<ul>
<li>限制了网络的规模，它能使用的最大距离为15(16表示不可达)</li>
<li>路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销也越大</li>
<li>网络出现故障时，会出现<strong>慢收敛现象</strong>（即需要较长时间才能将此信息传送到所有路由器），<br><strong>俗称“坏消息传得慢”，使更新过程的收敛时间长</strong></li>
<li>理解坏消息传的慢，此时R1还会向R2发送原来链路可到达的信息，因此R2的距离会更新到3<ul>
<li><img src="https://s21.ax1x.com/2024/08/12/pApeFcF.png" alt="pApeFcF.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-开放最短路径优先协议（OSPF）"><a href="#4-开放最短路径优先协议（OSPF）" class="headerlink" title="4.开放最短路径优先协议（OSPF）"></a>4.开放最短路径优先协议（OSPF）</h4><ul>
<li>OSPF是使用分布式链路状态路由算法的典型代表，也是内部网关协议(IGP)的一种。</li>
<li><strong>OSPF是网络层协议，它不使用UDP或TCP,而直接用IP数据报传送（其IP数据报首部的协议字段为89)</strong></li>
<li><strong>当互联网规模很大时，OSPF要比RIP好得多，而且OSPF协议没有“坏消息传播得慢”的问题。</strong></li>
<li>OSPF的特点<ul>
<li>OSPF对不同的链路可根据IP分组的不同服务类型(TOS)而设置成不同的代价。<br>因此，OSPF对于不同类型的业务可计算出不同的路由，十分灵活。</li>
<li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这称为多路径间的负载平衡。</li>
<li>所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li>
<li>支持可变长度的子网划分和无分类编址CDR</li>
<li>每个链路状态都带上一个32位的序号，序号越大，状态就越新。</li>
</ul>
</li>
<li>OSPF的基本工作原理<ul>
<li>各路由器之间频繁地交换链路状态信息，因此所有路由器最终都能建立一个链路状态数据库。<br>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（称为链路状态数据库的同步）。</li>
<li>每个路由器根据这个全网拓扑结构图，使用Dijkstra最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。</li>
<li>此后当链路状态发生变化时，每个路由器重新计算到各目的网络的最优路径，构造新的路由表。</li>
</ul>
</li>
<li>区域的概念<ul>
<li>为使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干更小的范围，称为区域。</li>
<li>划分区域的好处是，将利用洪泛法交换链路状态信息的范围局限于每个区域而非整个自治系统，减少了整个网络上的通信量。</li>
<li>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑情况。</li>
<li>区域也有层次之分。处在上层的域称为主千区域，负责连通其他下层的区域，并且还连接其他自治域。</li>
<li>采用分层划分区域的方法使交换信息的种类增多，OSPF协议更加复杂</li>
</ul>
</li>
<li>OSPF与RIP的4点主要区别<ul>
<li><strong>OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。而RIP仅向自己相邻的几个路由器发送信息</strong></li>
<li><strong>发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</strong><br><strong>“链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”（或代价）。</strong><br><strong>而在RIP中，发送的信息是本路由器所知道的全部信息，即整个路由表。</strong></li>
<li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，<br>不会出现RIP“坏消息传得慢”的问题。而在RIP中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息</li>
<li>OSPF是网络层协议，它不使用UDP或TCP,而直接用IP数据报传送（其IP数据报首部的协议字段为89)<br>而RIP是应用层协议，它在传输层使用UDP</li>
</ul>
</li>
</ul>
<h4 id="5-边界网关协议（BGP）"><a href="#5-边界网关协议（BGP）" class="headerlink" title="5.边界网关协议（BGP）"></a>5.边界网关协议（BGP）</h4><ul>
<li>边界网关协议(BGP)是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。<br>边界网关协议常用于互联网的网关之间。</li>
<li><strong>边界网关协议(BGP)只能力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非寻找一条最佳路由。</strong></li>
<li>BGP采用的是路径向量路由选择协议，它与距离向量协议和链路状态协议有很大的区别。</li>
<li><strong>BGP是应用层协议，它是基于TCP的。</strong></li>
</ul>
<h4 id="6-三种路由协议的区别（✪）"><a href="#6-三种路由协议的区别（✪）" class="headerlink" title="6.三种路由协议的区别（✪）"></a>6.三种路由协议的区别（✪）</h4><ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPAz7qS.png" alt="pPAz7qS.png"></li>
</ul>
<h3 id="六-IP组播"><a href="#六-IP组播" class="headerlink" title="六.IP组播"></a>六.IP组播</h3><h4 id="1-组播的概念"><a href="#1-组播的概念" class="headerlink" title="1.组播的概念"></a>1.组播的概念</h4><ul>
<li><p>组播的概念</p>
<ul>
<li>为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制。</li>
</ul>
</li>
</ul>
<ul>
<li>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分<br>发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点的传输方式</li>
</ul>
<ul>
<li><strong>组播一定仅应用于UDP，</strong>它对将报文同时送往多个接收者的应用来说非常重要。</li>
</ul>
<ul>
<li><strong>在IPV4中，组播地址在D类地址空间中分配，而IPv6也有一部分地址空间保留给组播组。</strong></li>
</ul>
<ul>
<li>组播的流程<ul>
<li><strong>主机使用一个称为IGMP（因特网组管理协议）的协议加入组播组。</strong>它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望。<br>通过扩展路由器的路由选择和转发功能，可以在许多路由器互连的支持硬件组播的网络上面实现因特网组播</li>
<li>对发送者而言，数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担。</li>
<li>主机组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发<br>组播需要路由器的支持才能实现，能够运行组播协议的路由器称为组播路由器。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/06/pPEpUpR.png" alt="pPEpUpR.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-IP组播地址"><a href="#2-IP组播地址" class="headerlink" title="2.IP组播地址"></a>2.IP组播地址</h4><ul>
<li><strong>IP组播使用D类地址格式。D类地址的前四位是1110，因此D类地址范围是224.0.0.0~239.255.255.255。</strong><br><strong>每个D类IP地址标志一个组播组。</strong></li>
<li><p>组播数据报的特点</p>
<ul>
<li>组播数据报也是“尽最大努力交付”，不提供可靠交付。</li>
<li>组播地址只能用于目的地址，而不能用于源地址。</li>
<li>对组播数据报不产生ICMP差错报文。因此，若在PING命令后面键入组播地址，将永远不会收到响应。</li>
<li>并非所有的D类地址都可作为组播地址。</li>
</ul>
</li>
<li><p>硬件组播（MAC地址的前六位固定，后六位由IP地址的后23位映射得来）</p>
<ul>
<li><img src="https://s21.ax1x.com/2024/08/12/pApeEnJ.png" alt="pApeEnJ.png"></li>
</ul>
</li>
</ul>
<h4 id="3-IGMP与组播路由算法"><a href="#3-IGMP与组播路由算法" class="headerlink" title="3.IGMP与组播路由算法"></a>3.IGMP与组播路由算法</h4><ul>
<li><p>IGMP的概念</p>
<ul>
<li>要使路由器知道组播组成员的信息，需要利用因特网组管理协议（IGMP)。</li>
<li>IGMP让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组。</li>
<li>IGMP并不是在因特网范围内对所有组播组成员进行管理的协议。IGMP不知道IP组播组包含的成员数，也不知道这些成员分布在哪些网络上。</li>
</ul>
</li>
<li>IGMP的工作原理<ul>
<li>当某台主机加入新的组播组时，该主机应向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员。本地的组播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他组播路由器。</li>
<li>本地组播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，那么组播路由器就认为这个组是活跃的。</li>
<li>但一个组在经过几次的探询后仍然没有一台主机响应时，则不再将该组的成员关系转发给其他的组播路由器。</li>
</ul>
</li>
<li>组播路由选择协议<ul>
<li>连接到局域网上的组播路由器还必须和因特网上的其他组播路由器协同工作，以便把组播数据报用最小代价传送给所有组成员，这就需要使用组播路由选择协议。</li>
<li>组播路由选择实际上就是要找出以源主机为根结点的<strong>组播转发树</strong>，其中每个分组在每条链路上只传送一次（即在组播转发树上的路由器不会收到重复的组播数据报），<strong>可以避免路由环路</strong></li>
<li>不同的多播组对应于不同的多播转发树：同一个多播组，对不同的源点也会有不同的多播转发树。</li>
<li>在许多由路由器互连的支持硬件多点传送的网络上实现因特网组播时，主要有三种路由算法：<ul>
<li>第一种是基于链路状态的路由选择</li>
<li>第二种是基于距离-向量的路由选择</li>
<li>第三种可以建立在任何路由器协议之上，因此称为协议无关的组播(PIM)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="七-移动IP"><a href="#七-移动IP" class="headerlink" title="七.移动IP"></a>七.移动IP</h3><h4 id="1-移动IP的概念"><a href="#1-移动IP的概念" class="headerlink" title="1.移动IP的概念"></a>1.移动IP的概念</h4><ul>
<li>移动IP技术是移动结点(计算机/服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，<br><strong>并保证了基于网络IP的网络权限在漫游过程中不发生任何改变</strong>。</li>
<li>移动结点：具有永久IP地址的移动设备。</li>
<li>归属代理（本地代理）：一个移动结点的永久“居所”称为归属网络，<br>在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理</li>
<li>永久地址(归属地址/主地址)：移动站点在归属网络中的原始地址。</li>
<li>外部代理（外地代理）：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理</li>
<li>转交地址（辅地址）：可以是外部代理的地址或动态配置的一个地址。</li>
</ul>
<h4 id="2-移动IP通信过程"><a href="#2-移动IP通信过程" class="headerlink" title="2.移动IP通信过程"></a>2.移动IP通信过程</h4><ul>
<li><img src="https://s1.ax1x.com/2023/08/07/pPECJzR.png" alt="pPECJzR.png"></li>
</ul>
<h3 id="八-网络层设备（✪）"><a href="#八-网络层设备（✪）" class="headerlink" title="八.网络层设备（✪）"></a>八.网络层设备（✪）</h3><h4 id="1-冲突域和广播域"><a href="#1-冲突域和广播域" class="headerlink" title="1.冲突域和广播域"></a>1.冲突域和广播域</h4><ul>
<li>冲突域<ul>
<li>冲突域是指连接到同一物理介质上的所有结点的集合，这些结点之间存在介质争用的现象。</li>
<li>在OSI参考模型中，冲突域被视为第1层概念，像集线器、中继器等简单无脑复制转发信号的第1层设备所连接的结点都属于同一个冲突域，也就是说它们不能划分冲突域。</li>
<li>而第2层（网桥、交换机）、第3层（路由器）设备都可以划分冲突域。</li>
<li>一个交换机的所有端口属于一个广播域，每个端口属于一个冲突域</li>
</ul>
</li>
<li>广播域<ul>
<li>广播域是指接收同样广播消息的结点集合。也就是说，在该集合中的任何一个结点发送一个广播帧，其他能收到这个帧的结点都被认为是该广播域的一部分。</li>
<li>在OSI参考模型中，广播域被视为第2层概念，像第1层（集线器等）、第2层（交换机等）设备所连接的结点都属于同一个<br>广播域。</li>
<li>路由器，作为第3层设备，则可以划分广播域，即可以连接不同的广播域。</li>
<li>通常所说的局域网(LAN)特指使用路由器分割的网络，也就是广播域</li>
</ul>
</li>
</ul>
<h4 id="2-路由器的组成与功能"><a href="#2-路由器的组成与功能" class="headerlink" title="2.路由器的组成与功能"></a>2.路由器的组成与功能</h4><ul>
<li><p>路由器的概述</p>
<ul>
<li><p>路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络（连接异构网络）并完成路由转发。<br>在多个逻辑网络（即多个广播域）互连时必须使用路由器。</p>
</li>
<li><p>当源主机要向目标主机发送数据报时，路由器先检查源主机与目标主机是否连接在同一个网络上。如果源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器。</p>
</li>
<li>如果源主机和目标主机不在同一个网络上，那么路由器按照转发表（路由表）指出的路由将数据报转发给下一个路由器，这称为间接交付。</li>
<li><strong>路由器隔离了广播域。从结构上看，路由器由路由选择和分组转发两部分构成，而从模型的角度看，路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。</strong></li>
</ul>
</li>
<li><p>路由器的组成</p>
<ul>
<li>路由选择部分<ul>
<li>路由选择部分也称控制部分，其核心构件是路由选择处理机，还包括路由选择协议，路由表</li>
<li>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表。</li>
</ul>
</li>
<li>分组转发部分<ul>
<li>由三部分组成：交换结构、一组输入端口和一组输出端口。</li>
<li>交换结构是路由器的关键部件，它根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去<br>交换结构本身就是一个网络</li>
<li>输入端口在从物理层接收到的比特流中提取出数据链路层帧，进而从帧中提取出网络层数据报<br>输出端口则执行恰好相反的操作</li>
<li>有三种常用的交换方法：通过存储器进行交换、通过总线进行交换和通过互联网络进行交换</li>
</ul>
</li>
</ul>
</li>
<li><p>路由器的功能</p>
<ul>
<li>路由计算：通过和其他路由器进行基于路由协议的交互，完成路由表的计算。</li>
<li>分组转发：处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等</li>
<li>当路由器监测到拥塞时，可合理丢弃IP分组，并向发出该IP分组的源主机发送一个源点抑制的ICMP报文。</li>
<li>路由器对收到的IP分组首部进行差错检验，丢弃有差错首部的报文，但不保证IP分组不丢失。</li>
</ul>
</li>
<li><p>路由器和网桥的区别</p>
<ul>
<li>网桥与高层协议无关，而路由器是面向协议的，它依据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等。</li>
<li>现今的路由器一般都提供多种协议的支持，包括OSI、TCP/IP、IPX等</li>
</ul>
</li>
</ul>
<h4 id="3-路由表与路由转发"><a href="#3-路由表与路由转发" class="headerlink" title="3.路由表与路由转发"></a>3.路由表与路由转发</h4><ul>
<li>路由表是根据路由选择算法得出的，主要用途是路由选择。</li>
<li>标准的路由表有4个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口<br>可能包含默认路由（0.0.0.0、0.0.0.0）</li>
<li>图片<ul>
<li><img src="https://s21.ax1x.com/2024/08/12/pApeZ7R.png" alt="pApeZ7R.png"></li>
</ul>
</li>
<li>转发表与路由表的区别<ul>
<li>转发表是从路由表得出的，其表项和路由表项有直接的对应关系。</li>
<li>但转发表的格式和路由表的格式不同，<strong>其结构应使查找过程最优化（而路由表则需对网络拓扑变化的计算最优化）</strong></li>
<li>转发表中含有一个分组将要发往的目的地址，以及分组的下一跳（即下一步接收者的目的地址，实际为MAC地址）</li>
<li>为了减少转发表的重复项目，可以使用一个默认路由代替所有具有相同“下一跳”的项目，并将默认路由设置得比其他项目的优先级低</li>
<li>路由表总是用软件来实现的；转发表可以用软件来实现，甚至也可以用特殊的硬件来实现。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第三章-数据链路层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h2 id="计算机网络第三章-数据链路层"><a href="#计算机网络第三章-数据链路层" class="headerlink" title="计算机网络第三章 数据链路层"></a>计算机网络第三章 数据链路层</h2><blockquote>
<p>计算机学科基础：计算机网络第三章数据链路层的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-数据链路层的功能（✪）"><a href="#一-数据链路层的功能（✪）" class="headerlink" title="一.数据链路层的功能（✪）"></a>一.数据链路层的功能（✪）</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，<br>将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</li>
</ul>
<h4 id="2-为网络层提供服务"><a href="#2-为网络层提供服务" class="headerlink" title="2.为网络层提供服务"></a>2.为网络层提供服务</h4><ul>
<li>无确认的无连接服务<ul>
<li>源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。</li>
<li><strong>适用于实时通信或误码率较低的通信信道，如以太网。</strong></li>
</ul>
</li>
<li>有确认的无连接服务。<ul>
<li>源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。</li>
<li><strong>该服务适用于误码率较高的通信信道，如无线通信。</strong></li>
</ul>
</li>
<li>有确认的面向连接服务。<ul>
<li>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。</li>
<li>目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧</li>
<li><strong>该服务的可靠性最高。该服务适用于通信要求(可靠性、实时性)较高的场合</strong></li>
</ul>
</li>
<li>注：有连接就一定要有确认，即不存在无确认的面向连接的服务。</li>
</ul>
<h4 id="3-链路管理"><a href="#3-链路管理" class="headerlink" title="3.链路管理"></a>3.链路管理</h4><ul>
<li>数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。</li>
<li>链路两端的结点要进行通信，必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号<br>初始化，然后才能建立连接</li>
<li>在传输过程中则要能维持连接，而在传输完毕后要释放该连接。</li>
<li>在多个站点共享同一物理信道的情况下（如在局域网中），如何在要求通信的站点间分配和管理信道<br>也属于数据链路层管理的范畴。</li>
</ul>
<h4 id="4-帧定界、帧同步与透明传输（✪）"><a href="#4-帧定界、帧同步与透明传输（✪）" class="headerlink" title="4.帧定界、帧同步与透明传输（✪）"></a>4.帧定界、帧同步与透明传输（✪）</h4><ul>
<li>两台主机之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。</li>
<li>帧定界<ul>
<li>将一段数据的前后分别添加首部和尾部，就构成了帧。帧长等于数据部分的长度加上首部和尾部的长度。<br>首部和尾部中含有很多控制信息，它们的一个重要作用是确定帧的界限，即帧定界。</li>
</ul>
</li>
<li>帧同步<ul>
<li>接收方应能从接收到的二进制比特流中区分出帧的起始与终止。（用帧定界标识位来区分）</li>
<li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但每种数据链路层<br>协议都规定了帧的数据部分的长度上限一最大传送单元(MTU)。</li>
</ul>
</li>
<li>透明传输<ul>
<li>如果在数据中恰好出现与帧定界符相同的比特组合（会误认为“传输结束”而丢弃后面的数据），那么就要采取有效的措施解决这个问题，即透明传输。</li>
<li>更确切地说，透明传输就是不管所传数据是什么样的比特组合，都应当能在链路上传送。</li>
</ul>
</li>
</ul>
<h4 id="5-差错控制（✪）"><a href="#5-差错控制（✪）" class="headerlink" title="5.差错控制（✪）"></a>5.差错控制（✪）</h4><ul>
<li>由于信道噪声等各种原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，这些错误可分为位错和帧错。</li>
<li><strong>位错指帧中某些位出现了差错。通常采用循环冗余校验(CRC)方式发现位错，通过自动重传请求(Automatic Repeat reQuest,.ARQ)方式来重传出错的帧</strong>。<ul>
<li>让发送方将要发送的数据帧附加一定的CRC冗余检错码一并发送，接收方则根据检错码对数据帧进行错误检测，</li>
<li>若发现错误则丢弃，发送方超时重传该数据帧。这种差错控制方法称为ARQ法。ARQ法只需返回很少的控制信息就可有效地确认所发数据帧是否被正确接收。</li>
</ul>
</li>
<li><strong>帧错指帧的丢失、重复或失序等错误。在数据链路层引入定时器（解决丢失问题）和编号机制（解决失序重复问题）</strong>，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</li>
</ul>
<h4 id="6-流量控制（✪）"><a href="#6-流量控制（✪）" class="headerlink" title="6.流量控制（✪）"></a>6.流量控制（✪）</h4><ul>
<li>流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。<br>否则会来不及接收帧而造成帧的丢失</li>
<li>需要有一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后继续发送。</li>
<li>流量控制并不是数据链路层特有的功能，许多高层协议中也提供此功能，只不过控制的对象不同而已。<ul>
<li>对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量</li>
<li>对于传输层来说，控制的则是从源端到目的端之间的流量。</li>
<li>在OSI体系结构中，数据链路层具有流量控制的功能。而在TCP/IP体系结构中，流量控制功能被移到了传输层。</li>
</ul>
</li>
</ul>
<h3 id="二-组帧（封装成帧✪）"><a href="#二-组帧（封装成帧✪）" class="headerlink" title="二.组帧（封装成帧✪）"></a>二.组帧（封装成帧✪）</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>组帧时既要加首部，又要加尾部。在网络中信息是以帧为最小单位进行传输的，<br>所以接收端要正确地接收帧，必须要清楚该帧在一串比特流中从哪里开始到哪里结束（因为接收端收到的是一串比特流，没有首部和尾部是不能正确区分帧的）</li>
<li>目前较常用的组帧方法是零比特填充法和违规编码法。</li>
<li>以太网MAC帧没有帧开始符和帧结束符<ul>
<li>在交付给物理层之后，物理层将在以太网帧前添加8字节的前导码（前7个字节为同步码，作用是使接收方的时钟同步，之后一个字节为帧开始符）。</li>
<li>并且以太网帧规定了帧间间隔为96比特的发送时间。（对于带宽为10Mb/s的传统以太网，96比特的发送时间为9.6us）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/30/pSdIIpQ.png" alt="pSdIIpQ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-字符计数法"><a href="#2-字符计数法" class="headerlink" title="2.字符计数法"></a>2.字符计数法</h4><ul>
<li><p>字符计数法是指在帧头部使用一个计数字段来标明帧内字符数。</p>
<p>目的结点的数据链路层收到字节计数值时，就知道后面跟随的字节数，从而可以确定帧结束的位置（计数字段提供的字节数包含自身所占用的一个字节）</p>
</li>
<li><p>如果计数字段出错，收发双方将失去同步</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/01/pP9XJLq.png" alt="pP9XJLq.png"></li>
</ul>
</li>
</ul>
<h4 id="3-字符填充的首尾定界符法（✪）"><a href="#3-字符填充的首尾定界符法（✪）" class="headerlink" title="3.字符填充的首尾定界符法（✪）"></a>3.字符填充的首尾定界符法（✪）</h4><ul>
<li>字符填充法使用特定字符来定界一帧的开始与结束，控制字符SOH放在帧的最前面，表示帧的首部开始，控制字符EOT表示帧的结束。</li>
<li>为了使信息位中出现的特定字符不被误判为帧的首尾定界符，可在特殊字符前面填充一个转义字符(ESC)来加以区分，以实现数据的透明传输。</li>
<li>接收方收到转义字符后，就知道其后面紧跟的是数据信息，而不是控制信息。<br>接收方收到数据后会自己删除这个插入的ESC字符，结果仍得到原来的数据</li>
<li>如果转义字符ESC也出现在数据中，那么解决方法仍是在转义字符前插入一个转义字符。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/01/pP9XDSJ.png" alt="pP9XDSJ.png"></li>
</ul>
</li>
</ul>
<h4 id="4-零比特填充的首尾标志法（✪）"><a href="#4-零比特填充的首尾标志法（✪）" class="headerlink" title="4.零比特填充的首尾标志法（✪）"></a>4.零比特填充的首尾标志法（✪）</h4><ul>
<li>零比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。它使用一个特定的比特模式，即01111110来标志一帧的开始和结束。</li>
<li>为了不使信息位中出现的比特流01111110被误判为帧的首尾标志<br>发送方的数据链路层在信息位中遇到5个连续的“1”时，将自动在其后插入一个“0”；</li>
<li>而接收方做该过程的逆操作，即每收到5个连续的“1”时，自动删除后面紧跟的“0”，以恢复原信息。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/01/pP9XWFO.png" alt="pP9XWFO.png"></li>
</ul>
</li>
<li>例题<ul>
<li><img src="https://s1.ax1x.com/2023/01/30/pSdTKGF.png" alt="pSdTKGF.png"></li>
</ul>
</li>
</ul>
<h3 id="三-差错控制（✪）"><a href="#三-差错控制（✪）" class="headerlink" title="三.差错控制（✪）"></a>三.差错控制（✪）</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>实际通信链路都不是理想的，比特在传输过程中可能会产生差错，1可能会变成0，0也可能会变成1，这就是比特差错</li>
<li>通常利用<u>编码技术</u>进行差错控制，主要有两类：自动重传请求ARQ和前向纠错FEC。</li>
<li>在ARQ方式中，接收端检测到差错时，就设法通知发送端重发，直到接收到正确的码字为止（检错编码）</li>
<li>在FEC方式中，接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正。（纠错编码）</li>
<li>发送方的数据链路层采用某种检错技术，根据帧的内容计算出一个检错码，将检错码填入帧尾部。<br>接收方的数据链路层从帧尾部取出检错码，采用与发送方相同的检错技术，就可以通过检错码检测出是否出现误码。（该字段即为帧检验序列FCS）</li>
</ul>
<h4 id="2-检错编码（✪）"><a href="#2-检错编码（✪）" class="headerlink" title="2.检错编码（✪）"></a>2.检错编码（✪）</h4><ul>
<li><p>概述</p>
<ul>
<li>检错编码都采用冗余编码技术，其核心思想是在有效数据（信息位）被发送前，先按某种关系附加一定的冗余位，构成一个符合某一规则的码字后再发送。</li>
<li>当要发送的有效数据变化时，相应的冗余位也随之变化，使得码字遵从不变的规则。</li>
<li>接收端根据收到的码字是否仍符合原规则来判断是否出错。常见的检错编码有奇偶校验码和循环冗余码。</li>
</ul>
</li>
<li><p>奇偶校验码（✪）</p>
<ul>
<li>奇校验是在待发送的数据后面添加一个校验位，使整个数据中1的个数为奇数，若接收到的1为偶数则说明错误。</li>
<li>偶校验是在待发送的数据后面添加一个校验位，使整个数据中1的个数为偶数，若接收到的1为奇数则说明错误。<ul>
<li><img src="https://s1.ax1x.com/2023/01/30/pSwQxc6.png" alt="pSwQxc6.png"></li>
</ul>
</li>
<li><strong>它只能检测奇数个比特的出错情况，但并不知道哪些位错了，也不能发现偶数个比特的出错情况。</strong></li>
</ul>
</li>
<li><p>冗余循环码（CRC✪）</p>
<ul>
<li><p>步骤</p>
<ul>
<li>收发双方约定好一个生成多项式G(X)</li>
<li>将数据作为被除数（后面添加生成多项式最高位次个0），生成多项式的各项系数构成的比特串作为除数</li>
<li>模2除法计算出差错检测码（冗余码），冗余码需在前面补0至与生成多项式的最高次项位数相同，将冗余码添加到待发送的数据的后面一起传输<ul>
<li>注：如多项式为10011，最高位是$x^{4}$，被除数后面需要添加4个0；算出余数之后需要再前面加0至余数的位数满足最高位次数4</li>
</ul>
</li>
<li>接收方收到了数据和冗余码后其作为被除数，生成多项式的各项系数构成的比特串作为除数，模2除法来计算是否误码，如果余数为0，则没有误码。</li>
</ul>
</li>
<li><p>关于生成多项式</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/01/30/pSw1GIH.md.png" alt="pSw1GIH.md.png"></li>
</ul>
</li>
<li><p>发送方操作</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/01/30/pSw1rdg.png" alt="pSw1rdg.png"></li>
</ul>
</li>
<li><p>接收方操作</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/01/30/pSw3EOf.png" alt="pSw3EOf.png"></li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>通过循环穴余码（CRC）的检错技术，数据链路层做到了对帧的无差错接收。<ul>
<li>凡是接收端数据链路层接受的，我们都认为这些帧在传输过程中没有产生差错</li>
<li>而接收端丢弃的帧虽然也收到了，但最终因为有差错而被丢弃，即未被接受。</li>
</ul>
</li>
<li><p>循环冗余校验（CRC）只能检测出错误，无法定位错误，因此无法纠错，是检错码，不是纠错码。 (海明码可以纠错)</p>
</li>
<li><p>循环冗余校验（CRC）漏检率极低，非常易于用硬件实现，被广泛应用于数据链路层。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-纠错编码"><a href="#3-纠错编码" class="headerlink" title="3.纠错编码"></a>3.纠错编码</h4><ul>
<li>海明码</li>
</ul>
<h3 id="四-流量控制与可靠传输机制-✪"><a href="#四-流量控制与可靠传输机制-✪" class="headerlink" title="四.流量控制与可靠传输机制(✪)"></a>四.流量控制与可靠传输机制(✪)</h3><h4 id="1-流量控制机制"><a href="#1-流量控制机制" class="headerlink" title="1.流量控制机制"></a>1.流量控制机制</h4><ul>
<li>停止-等待流量控制协议<ul>
<li>发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧</li>
<li>接收方每接收一帧，都要反馈一个应答信号，表示可接收下一帧，如果接收方不反馈应答信号，那么发送方必须一直等待</li>
<li>每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低。</li>
</ul>
</li>
<li>滑动窗口流量控制<ul>
<li>流程<ul>
<li>发送端每收到一个确认帧，发送窗口就向前滑动一个帧的位置</li>
<li>接收端收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</li>
<li>当发送窗口内没有可以发送的帧（即窗口内的帧全部是已发送但未收到确认的帧）时，发送方就会停止发送<br>直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧后，才开始继续发送。</li>
</ul>
</li>
<li>滑动窗口的特征<ul>
<li>只有接收窗口向前滑动并发送了确认帧时，发送方收到确认帧后，发送窗口才有可能向前滑动。</li>
<li>对于窗口大小为n的滑动窗口，最多可以有n-1帧已发送但没有确认</li>
</ul>
</li>
<li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意与第5章传输层的滑动窗口协议的区别）</li>
</ul>
</li>
</ul>
<h4 id="2-可靠传输机制"><a href="#2-可靠传输机制" class="headerlink" title="2.可靠传输机制"></a>2.可靠传输机制</h4><ul>
<li>确认机制<ul>
<li>确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。</li>
</ul>
</li>
<li>超时重传机制<ul>
<li>发送方在发送某个数据帧后就开启一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止。</li>
</ul>
</li>
<li>自动重传请求(ARQ)，通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一<ul>
<li>传统自动重传请求分为三种，即停止-等待（SW）、后退N帧（GBN）和选择重传（SR）。</li>
<li>后两种协议由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。</li>
</ul>
</li>
</ul>
<h4 id="3-单帧滑动窗口与停止-等待协议（SW）"><a href="#3-单帧滑动窗口与停止-等待协议（SW）" class="headerlink" title="3.单帧滑动窗口与停止-等待协议（SW）"></a>3.单帧滑动窗口与停止-等待协议（SW）</h4><ul>
<li><p>确认、否认与重传机制</p>
<ul>
<li><p>发送方每发送完一个帧就必须停下来，等待接收方发来的确认（ACK）或者否认（NAK）</p>
<ul>
<li>出现误码时，接收方丢弃该帧，并向发送方发送一个NAK帧，接收方收到NAK帧后，再重传该帧</li>
<li>没有出现误码时，接收方向发送方发送一个ACK帧，接收方收到ACK帧，发送下一个帧。</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/02/02/pSDO8oQ.md.png" alt="pSDO8oQ.md.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>超时重传机制</p>
<ul>
<li>发送方可在每发送完一个数帧时启动一个超时重传器<br>若到了超时重传器设置的超时重传时间（RTO），但未收到接收方发送的确认帧和否认帧，就重传之前发送过的这个帧</li>
<li>RTO的时长不能太长（等待时间过长，降低信道利用率）不能太短（发送方出现不必要的超时重传）<br>一般可将RTO设置为略大于收发双方的平均往返时间RTT。</li>
<li>补充了超时重传机制后，可以不使用否认机制。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/02/02/pSDjPED.md.png" alt="pSDjPED.md.png"></li>
</ul>
</li>
</ul>
</li>
<li>编号机制<ul>
<li>为了区别收到的是重复帧，可以每个帧带上不同的序号</li>
<li>每发送一个帧，其序号于上一次发送的数据帧的序号不相同（可用序号为0和1来标识）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/02/02/pSDvcWj.md.png" alt="pSDvcWj.md.png"></li>
</ul>
</li>
</ul>
</li>
<li>此外，为了超时重发和判定重复帧的需要，发送方和接收方都须设置一个帧缓冲区。<ul>
<li>发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传。</li>
<li>只有在收到对方发来的确认帧ACK时，方可清除此副本。</li>
</ul>
</li>
</ul>
<h4 id="4-多帧滑动窗口与后退N帧协议（GBN）"><a href="#4-多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="4.多帧滑动窗口与后退N帧协议（GBN）"></a>4.多帧滑动窗口与后退N帧协议（GBN）</h4><ul>
<li><p>概述（属于有序接收的滑动窗口协议）</p>
<ul>
<li><p>为了减少开销，GBN协议规定接收端不一定每收到一个正确的数据帧就必须立即发回一个确认帧，而可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认信息。</p>
<ul>
<li>对某一数据帧的确认就表明该数据帧和此前所有的数据帧均已正确无误地收到，称为累积确认。</li>
</ul>
</li>
<li><p>如本题选A，收到5号帧的确认，说明前面都已经收到，只有6没有收到</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/01/pPCNbkj.png" alt="pPCNbkj.png"></li>
</ul>
</li>
<li>当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重传该出错帧及随后的N个帧。</li>
</ul>
</li>
<li><p>后退N帧协议的窗口设置</p>
<ul>
<li><strong>后退N帧协议的接收窗口为1，可以保证按序接收数据帧。若采用n比特对帧编号，则其发送窗口的尺寸W应满足$1&lt;W≤2^{n}-1$。</strong></li>
<li>若发送窗口的尺寸大于$2^{n}-1$，则会造成接收方无法分辨新帧和旧帧</li>
<li>后退N帧协议因连续发送数据帧而提高了信道的利用率<br>但是当信道的传输质量很差导致误码率较大时，后退N帧协议不一定优于停止-等待协议。</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/01/pPClSmR.png" alt="pPClSmR.png"></li>
</ul>
</li>
</ul>
<h4 id="5-多帧滑动窗口与选择重传协议（SR）"><a href="#5-多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="5.多帧滑动窗口与选择重传协议（SR）"></a>5.多帧滑动窗口与选择重传协议（SR）</h4><ul>
<li><p>概述（属于无序接收的滑动窗口协议）</p>
<ul>
<li>为进一步提高信道的利用率，可设法只重传出现差错的数据帧或计时器超时的数据帧</li>
<li>但此时必须加大接收窗口，以便先收下发送序号不连续但仍处在接收窗口中的那些数据帧。<br>等到所缺序号的数据帧收到后再一并送交主机。</li>
<li>在选择重传协议中，每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传。</li>
<li>一旦接收方怀疑帧出错，就会发一个否定帧NAK给发送方，要求发送方对NAK中指定的帧进行重传。</li>
</ul>
</li>
<li><p>SR的滑动窗口设置</p>
<ul>
<li><p>选择重传协议的接收窗口尺寸$W_R$和发送窗口尺寸$W_T$都大于1，一次可以发送或接收多个帧。</p>
</li>
<li><p>在选择重传协议中，需要满足：<strong>发送窗口大小+接收窗口大小≤$2^n$</strong></p>
<ul>
<li>选择重传协议是对单帧进行确认，所以发送窗口大于接收窗口会导致溢出，发送窗口小于接收窗口没有意义</li>
<li>接收窗口和发送窗口的大小通常是相同的，所需缓冲区的数目等于窗口的大小</li>
<li><strong>SR中最大值都为序号范围的一半，若采用n比特对帧编号，则需要满足$W_Tmax=W_Rmax=2^{n-1}$</strong></li>
<li>如果窗口大小大于序号范围一半，当一个或多个确认帧丢失时，发送方就会超时重传之前的数据帧<br>但接收方无法分辨是新的数据帧还是重传的数据帧。</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/01/pPC1aKH.png" alt="pPC1aKH.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-关于求信道利用率的问题（♚）"><a href="#6-关于求信道利用率的问题（♚）" class="headerlink" title="6.关于求信道利用率的问题（♚）"></a>6.关于求信道利用率的问题（♚）</h4><ul>
<li><p>信道的效率，也称信道利用率。信道效率是对发送方而言的，是指发送方在一个发送周期的时间内，有效地发送数据<br>所需要的时间占整个发送周期的比率。</p>
<ul>
<li>发送方从开始发送数据到收到<strong>第一个确认帧</strong>为止，称为一个发送周期，设为T</li>
<li>发送方在这个周期内共发送L比特的数据（<strong>不止一个确认帧</strong>），发送方的数据传输速率为C</li>
<li>则发送方用于发送有效数据的时间为L/C，在这种情况下，信道的利用率=$\LARGE\frac{ \frac {L}{C}}{T}$</li>
<li>信道吞吐率=信道利用率×发送方的发送速率。</li>
</ul>
</li>
<li><p>做题思路</p>
<ul>
<li><strong>首先应该以一个数据帧为基准，算一个周期的时延T</strong></li>
<li>一个周期的总时延包括单个数据帧与确认帧的发送时延与传播时延，传播时延是来回的，需乘以2</li>
<li>确认帧的发送时延不算作有效数据发送时延</li>
<li>停止-等待协议中，信道利用率就直接以一个数据帧的发送时延为有效发送数据所需要的时间</li>
<li><p>滑动窗口协议中，一般会求满足相关信道利用率时的帧序号的比特数，此时需要求滑动窗口的数量$&lt;=2^{n}-1$</p>
<ul>
<li>窗口数量=发送的帧的数目=总发送数据量/单个帧数据量</li>
<li>信道的利用率=$\LARGE\frac{ \frac {L}{C}}{T}$，可以求出总发送数据量L</li>
</ul>
</li>
<li><p>例</p>
<ul>
<li><p>题目</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCqi9J.png" alt="pPCqi9J.png"></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>发送数据帧和确认帧的时间均为t=1000×8b/10kb/s=800ms.（确认帧不算有效数据发送时间）</li>
<li>发送周期为T=800ms+200ms+800ms+200ms=2000ms.</li>
<li>信道利用率为t/T×100%=800/2000=40%</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>例1</p>
<ul>
<li><p><strong>在滑动窗口协议中，信道利用率最高时，说明其在一个数据帧发送的时间周期之内，发送方一直在发送数据</strong><br><strong>此时可以通过总时长除一个帧的发送时长求出其一共发出了多少帧，此时再利用定则算编号的比特数</strong></p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCbW6I.png" alt="pPCbW6I.png"></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCb50f.png" alt="pPCb50f.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>例2</p>
<ul>
<li><p>本题设发送的数据量为L，代入公式计算即可，之后再除以帧长算出发送了多少帧并用定则求出帧序号比特数</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCbOcn.png" alt="pPCbOcn.png"></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCbL1s.png" alt="pPCbL1s.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>例3</p>
<ul>
<li><p>最大数据传输速率说明在一个T之内发送方都在传数据，此时使用总的窗口数据量除以一个周期的时延即可求出最大数据传输速率，之后再和带宽作比较，选较小的</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCbvn0.png" alt="pPCbvn0.png"></li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPCbz7T.png" alt="pPCbz7T.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五-介质访问机制（✪）"><a href="#五-介质访问机制（✪）" class="headerlink" title="五.介质访问机制（✪）"></a>五.介质访问机制（✪）</h3><h4 id="1-介质访问控制子层"><a href="#1-介质访问控制子层" class="headerlink" title="1.介质访问控制子层"></a>1.介质访问控制子层</h4><ul>
<li>介质访问控制的概述<ul>
<li>介质访问控制所要完成的主要任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。</li>
<li>用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制(Medium Access Control,MAC)子层。</li>
</ul>
</li>
<li>介质访问控制的分类<ul>
<li>介质访问控制的内容是，采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况。</li>
<li>常见的介质访问控制方法有信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制。<br>其中前者是静态划分信道的方法，而后两者是动态分配信道的方法。</li>
</ul>
</li>
</ul>
<h4 id="2-信道划分介质访问控制（✠）"><a href="#2-信道划分介质访问控制（✠）" class="headerlink" title="2.信道划分介质访问控制（✠）"></a>2.信道划分介质访问控制（✠）</h4><ul>
<li>概述<ul>
<li>信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备。</li>
<li>可以造成共享时间，共享空间或者既共享时间又共享空间的效果</li>
</ul>
</li>
<li>多路复用技术<ul>
<li>当传输介质的带宽超过传输单个信号所需的带宽时，人们就通过<u>在一条介质上同时携带多个传输信号的方法</u>来提高传输系统的利用率，也是实现信道划分介质访问控制的途径。</li>
<li>多路复用技术把多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源，提高了信道的利用率。</li>
<li>采用多路复用技术可把多个输入通道的信息整合到一个复用通道中，在接收端把收到的信息分离出来并传送到对应的输出通道<ul>
<li>复用技术在发送端需要一个复用器，让多个用户通过复用器使用一个大容量的共享信道进行通信；<br>在接收端需要使用一个分用器，将共享信道中传输的信息分别发送给相应的用户</li>
<li><img src="https://s1.ax1x.com/2023/08/02/pPPisWq.png" alt="pPPisWq.png"></li>
</ul>
</li>
</ul>
</li>
<li>信道划分<ul>
<li>信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道。</li>
</ul>
</li>
<li>频分多路复用（FDM）<ul>
<li>概述<ul>
<li>频分多路复用是一种将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路复用技术。</li>
<li>将传输媒体的总频带划分成多个子频带，每个子频带作为一个通信子信道。<br>频分复用的所有用户同时占用不同的频带资源发送数据。</li>
<li>每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽。</li>
<li>在实际应用中，为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”。</li>
</ul>
</li>
<li>频分多路复用的优点在于充分利用了传输介质的带宽，系统效率较高；<br>由于技术比较成熟，实现也较容易。</li>
<li>适用于传输模拟信号</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/28/pSUqpLR.png" alt="pSUqpLR.png"></li>
</ul>
</li>
</ul>
</li>
<li>时分多路复用（TDM）<ul>
<li>概述<ul>
<li>时分多路复用是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。</li>
<li>每个时间片由复用的一个信号占用，利用每个信号在时间上的交叉，就可以在一条物理信道上传输多个信号</li>
</ul>
</li>
<li>统计时分多路复用（STDM）<ul>
<li>又称异步时分多路复用，是TDM的一种改进，它采用STDM帧，<br>STDM帧并不固定分配时隙，而按需动态地分配时隙，</li>
<li>当终端有数据要传送时，才会分配到时间片，因此可以提高线路的利用率</li>
<li>如线路传输速率为8000b/s，4个用户的平均速率都为2000b/s，当采用TDM方式时，每个用户的最高速率为2000b/s<br>而在STDM方式下，每个用户的最高速率可达8000b/s。</li>
</ul>
</li>
<li>适用于传输数字信号</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/28/pSUqAJO.png" alt="pSUqAJO.png"></li>
</ul>
</li>
</ul>
</li>
<li>波分多路复用（WDM）<ul>
<li>概述<ul>
<li>波分多路复用即光的频分多路复用，它在一根光纤中传输多种<u>不同波长（频率）</u>的光信号<br>由于波长（频率）不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来</li>
<li>由于光波处于频谱的高频段，有很高的带宽，因而可以实现多路的波分复用</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/28/pSUqtyj.png" alt="pSUqtyj.png"></li>
</ul>
</li>
</ul>
</li>
<li>码分多路复用（CDM✪）<ul>
<li>概述（也称为码分多址，CDMA）<ul>
<li>码分多路复用是采用不同的编码来区分各路原始信号的一种复用方式。<br>与FDM和TDM不同，它既共享信道的频率，又共享时间。</li>
<li>将每个比特时间再划分成m个更短的时间槽，称为码片(Chip)，通常m的值是64或128</li>
<li>信号以向量形式发送，各向量之间需要正交（内积为0），向量中的分量，就是所谓的码片</li>
<li>任何一个码片向量和该码片向量自身的规格化内积都是1</li>
<li>任何一个码片向量和该码片反码的向量的规格化内积是-1</li>
</ul>
</li>
<li>码分多址的流程<ul>
<li>每个站点被指派一个唯一的m比特码片序列。<ul>
<li>发送1时，站点发送它自己的m比特码片序列</li>
<li>发送0时，站点发送其m比特码片序列的反码。</li>
<li>码片序列中的0可用-1表示</li>
</ul>
</li>
<li>如果有两个或多个站点同时发送数据，此时各路数据在信道中的值为这些向量的线性叠加</li>
<li>最后到达接收站点，分别与对应站点的码片序列进行规格化内积<br>为1发送的是1，为-1发送的是0，为0没有发送信息</li>
</ul>
</li>
<li>码分多址的举例，设m=8，此时A<ul>
<li>站点A的码片序列被指派为00011011（-1-1-1+1+1-1+1+1）<ul>
<li>则A站发送00011011就表示发送比特1</li>
<li>发送11100100就表示发送比特0</li>
</ul>
</li>
<li>令站点B为(-1-1+1-1+1+1+1-1)，当A站向C站发送数据1时，就发送了向量(-1-1-1+1+1-1+1+1)；<br>当B站向C站发送数据0时，就发送了向量(+1+1-1+1-1-1-1+1)</li>
<li>两个向量到了公共信道上就进行叠加，实际上就是线性相加，得到S+T=(0 0 -2 2 0 -2 0 2)</li>
<li>到达C站后，进行数据分离，如果要得到来自A站的数据，C站就必须知道A站的码片序列，让S与S+T进行规格化内积。根据叠加原理，其他站点的信号都在内积的结果中被过滤掉了，内积的相关项都是0，而只剩下A站发送的信号。得到S(S+T)=1</li>
<li>所以A站发出的数据是1。同理，如果要得到来自B站的数据，那么T(S+T)=-1<br>因此从B站发送过来的信号向量是一个反码向量，代表0</li>
</ul>
</li>
<li>特点<ul>
<li>码分多路复用技术具有频谱利用率高、抗干扰能力强、保密性强、语音质量好等优点<br>还可以减少投资和降低运行成本，主要用于无线通信系统，特别是移动通信系统。</li>
</ul>
</li>
<li>例题<ul>
<li>注：收到谁发送的序列，用谁的码片去求得数据。</li>
<li><img src="https://s1.ax1x.com/2023/01/28/pSUxkFI.png" alt="pSUxkFI.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-随机访问介质访问控制（✪）"><a href="#3-随机访问介质访问控制（✪）" class="headerlink" title="3.随机访问介质访问控制（✪）"></a>3.随机访问介质访问控制（✪）</h4><ul>
<li><p>概述</p>
<ul>
<li>在随机访问协议中，不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。</li>
<li>在总线型网络中，当有两个或多个用户同时发送信息时，就会产生帧的冲突（碰撞），导致所有用户的发送均以失败告终</li>
<li>为了解决随机接入时发生的碰撞，每个用户需要按照一定的规则反复地重传它的帧，直到无碰撞的通过</li>
<li>这些规则即为随机访问介质访问控制协议，它们的核心思想是：<ul>
<li>胜利者通过争用获得信道，从而获得信息的发送权。因此，随机访问介质访问控制协议又称争用型协议。</li>
</ul>
</li>
<li>采用随机访问控制机制时，各结点之间的通信就可既不共享时间，又不共享空间<ul>
<li>因此其实质上是一种将广播信道转化为点到点信道的行为</li>
</ul>
</li>
</ul>
</li>
<li><p>ALOHA协议（非重点）</p>
<ul>
<li>纯ALOHA协议<ul>
<li>概述<ul>
<li>当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。</li>
<li>发生碰撞时让各站等待一段随机的时间，然后再进行重传</li>
<li>若再次发生碰撞，则需要再等待一段随机的时间，直到重传成功为止</li>
</ul>
</li>
<li>吞吐量<ul>
<li>假设网络负载(T时间内所有站点发送成功的和未成功而重传的帧数)为G<br>则纯ALOHA网络的吞吐量(T时间内成功发送的平均帧数)为$S=Ge^{-2G}$(e=0.5时取极大值)</li>
</ul>
</li>
</ul>
</li>
<li>时隙ALOHA协议<ul>
<li>概述<ul>
<li>把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙(Slot)，规定只能在每个时隙开始时才能发送一个帧。<br>从而避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率。</li>
<li>每个帧在到达后，一般都要在缓存中等待一段小于时隙的时间，然后才能发送出去</li>
<li>在一个时隙内有两个或两个以上的帧到达时，在下一个时隙将产生碰撞。碰撞后重传的策略与纯ALOHA的情况是相似的。</li>
</ul>
</li>
<li>吞吐量：S=$Ge^{-G}$。当G=1时取极大值，比纯ALOHA网络的吞吐量大了1倍。</li>
</ul>
</li>
</ul>
</li>
<li>CSMA协议（载波监听多路访问，非重点）<ul>
<li>每个站点在发送前都先监听一下共用信道，发现信道空闲后再发送</li>
<li>1-坚持CSMA（易受传播延迟的影响）<ul>
<li>一个结点要发送数据时，首先监听信道，如果信道空闲，那么立即发送数据</li>
<li>如果信道忙，那么等待，同时继续监听直至信道空闲</li>
<li>如果发生冲突，那么随机等待一段时间后，再重新开始监听信道。</li>
<li>“1-坚持”的含义是：监听到信道忙后，继续坚持监听信道；监听到信道空闲后，发送帧的概率为1，即立刻发送数据。</li>
</ul>
</li>
<li>非坚持CSMA（增加平均延迟）<ul>
<li>一个结点要发送数据时，首先监听信道，如果信道空闲，那么立即发送数据（此特性与“1-坚持”一样）</li>
<li><strong>如果信道忙，那么放弃监听，等待一个随机的时间后再重复上述过程。</strong></li>
<li>非坚持CSMA协议在监听到信道忙后就放弃监听，因此降低了多个结点等待信道空闲后同时发送数据导致冲突的概率<br>但也会增加数据在网络中的平均延迟。</li>
</ul>
</li>
<li>p坚持CSMA（用于时分信道）<ul>
<li>一个结点要发送数据时，首先监听信道，<strong>如果信道空闲，那么以概率p发送数据，以概率1-P推迟到下一个时隙</strong></li>
<li>如果信道忙，就持续监听，直至信道空闲</li>
<li>这个过程一直持续到数据发送成功或因其他结点发送数据而检测到信道忙为止，<br>若是后者，则等待下一个时隙再重新开始监听。</li>
<li>其目的是降低1-坚持CSMA协议中多个结点检测到信道空闲后同时发送数据的冲突概率</li>
</ul>
</li>
<li>区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPPX56J.png" alt="pPPX56J.png"></li>
</ul>
</li>
</ul>
</li>
<li>CSMA/CD协议（载波监听多路访问/碰撞检测✪）<ul>
<li>概述（先听后发、边听边发，冲突停发，随机重发）<ul>
<li>适用于总线形网络或半双工网络环境。</li>
<li>载波监听是指每个站点在发送前和发送中都必须不停地检测信道<ul>
<li>站点要发送数据前先监听信道，只有信道空闲才能发送</li>
<li>在发送中检测信道是为了及时发现发送的数据是否发生了碰撞。</li>
</ul>
</li>
<li>碰撞检测(Collision Detection)就是边发送边监听<ul>
<li>如果监听到了碰撞，则立即停止数据发送，等待一段随机时间后，重新开始尝试发送数据。</li>
</ul>
</li>
</ul>
</li>
<li>争用期<ul>
<li>信号在最远两个端点之间往返传输的时间为${2 \tau}$称为争用期</li>
<li>在发送帧后至多经过时间${2 \tau}$就能知道所发送的帧有没有发生碰撞 。</li>
<li>每个站在自己发送数据之后的一小段时间内, 存在发生碰撞的可能性, 只有经过争用期这段时间还未检测到碰撞时, 才能确定这次发送不会发生碰撞。</li>
</ul>
</li>
<li>最小帧长（争用期内可发送的数据长度）<ul>
<li>在争用期内如果检测到碰撞，站点就会停止发送，此时已发送出去的数据一定小于最短帧长，因此凡长度小于这个最短帧长的帧都是由于冲突而异常中止的无效帧。</li>
<li><strong>最小帧长的计算公式为：最小帧长=总线传播时延×2×数据传输速率</strong></li>
<li>以太网规定最短帧长为64B，凡长度小于64B的帧都是由于冲突而异常中止的无效帧，收到这种无效帧时应立即丢弃。</li>
<li>如果只发送小于64B的帧，如40B的帧，那么需要在MAC子层中于数据字段的后面加入一个整数字节的填充字段，以保证以太网的MAC帧的长度不小于64B</li>
<li>例题<ul>
<li>保持等式两边不变<img src="https://s1.ax1x.com/2023/08/03/pPiKHHI.png" alt="pPiKHHI.png"></li>
</ul>
</li>
</ul>
</li>
<li>随机重发（采用截断二进制指数退避算法）<ul>
<li>在检测到碰撞之后需要进行一段退避时间才能进行重新发送，此时该时间由截断二进制指数退避算法确定</li>
<li>截断二进制指数退避算法的流程<ul>
<li>首先需要确定基本退避时间, 一般取两倍的总线端到端传播时延${2 \tau}$(即争用期)。</li>
<li>定义参数${k}$，它等于重传次数，<strong>但${k}$不超过10 , 即${k=\min [}$重传次数，10]。</strong><ul>
<li>当重传次数不超过10时，${k}$等于重传次数</li>
<li>当重传次数大于 10 时，${k}$就不再增大而一直等于10 </li>
</ul>
</li>
<li>从离散的整数集合${\left[0,1, \cdots, 2^{k}-1\right]}$中随机取出一个数${r}$，重传所需退避的时间就是${r}$倍的基本退避时间，即${2 r \tau}$。<ul>
<li>第1次重传时，k=1，随机数r从整数[0,1]中选择，因此适配器可选的重传推迟时间是0或${2\tau}$。</li>
<li>若再次发送碰撞，则在第2次重传时，随机数r从整数[0,1,2,3]中选择，因此重传推迟时间是在0，${2 \tau}$，${4  \tau}$，${6  \tau}$<br>这4个时间中随机地选取一个。以此类推。</li>
</ul>
</li>
<li>当重传达 16 次仍不能成功时, 说明网络太拥挤, 认为此帧永远无法正确发出, 抛弃此帧并向高层报告出错</li>
</ul>
</li>
<li>使用截断二进制指数退避算法可使重传需要推迟的平均时间随重传次数的增大而增大<br>也称动态退避，因而能降低发生碰撞的概率，有利于整个系统的稳定</li>
<li>例题，此时注意碰撞的次数为11，大于10，因此k=10，区间小于等于$2^{10}-1=1023$<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPiPdfI.png" alt="pPiPdfI.png"></li>
</ul>
</li>
</ul>
</li>
<li>CSMA/CD的流程<ul>
<li>准备发送：适配器从网络层获得一个分组，封装成帧，放入适配器的缓存。</li>
<li>检测信道：若检测到信道空闲，它就开始发送这个帧。<br>若检测到信道忙，它就持续检测直至信道上没有信号能量，然后开始发送这个帧。</li>
<li>在发送过程中，适配器仍持续检测信道。这里只有两种可能<ul>
<li>发送成功：在争用期内一直未检测到碰撞，这个帧肯定能发送成功。</li>
<li>发送失败：在争用期内检测到碰撞，此时立即停止发送，适配器执行指数退避算法，<br>等待此算法生成的一段随机时间后继续进行信道检测。若重传16次仍不能成功，则停止重传并向上报错。</li>
</ul>
</li>
</ul>
</li>
<li>适用范围<ul>
<li>应用于总线型的有线连接的局域网</li>
<li>使用此协议的以太网只能进行半双工通信，全双工的网络不需要使用此协议</li>
<li>不适用于无线局域网<ul>
<li>无线局域网中接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度的动态变化范围很大，因此若要实现碰撞检测，则硬件上的花费就会过大。</li>
<li>在无线通信中，并非所有的站点都能够听见对方，即存在“隐蔽站”问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CSMA/CA协议（载波监听多路访问/碰撞避免✪）<ul>
<li>概述（适用于802.11无线局域网）<ul>
<li>碰撞避免”并不是指协议可以完全避免碰撞，而是指协议的设计要尽量降低碰撞发生的概率。<ul>
<li>由于802.11无线局域网不使用碰撞检测，一旦站点开始发送一个帧，就会完全地发送该帧，要采用碰撞避免技术降低碰撞的可能性。</li>
</ul>
</li>
<li>由于无线信道的通信质量远不如有线信道，802.11使用链路层ARQ方案（停止-等待协议）<br>即站点每通过无线局域网发送完一帧，就要在收到对方的确认帧后才能继续发送下一帧，以此来实现可靠传输</li>
<li>使用分布式协调功能（DCF），在DCF模式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获得发送权。因此DCF向上提供争用服务。为802.11无线局域网的默认方式（必须实现）</li>
</ul>
</li>
<li>帧间间隔<ul>
<li>为了尽量避免碰撞，802.11无线局域网规定，所有的站完成发送后，必须再等待一段很短的时间后（此时继续<br>监听）才能发送下一帧。这段时间称为帧间间隔 (IFS) </li>
<li>IFS的长短取决于站点要发送的帧的类型<ul>
<li>短帧间间隔SIFS<ul>
<li>最短的帧间间隔，用来分隔属于一次对话的各帧</li>
<li>发送<u>ACK帧、CTS帧</u>等帧时需要先经过一段SIFS的时延</li>
</ul>
</li>
<li>DCF帧间间隔DIFS<ul>
<li>为最长的帧间间隔，在DCF方式中作为开始进入争用窗口的一段时延</li>
<li>发送RTS预约帧需要先经过一段DIFS时延</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CSMA/CA退避算法以及其流程<ul>
<li>信道从忙态变为空闲态时，任何一个站要发送数据帧，不仅都要等待一个DIFS，而且之后要进入争用窗口，计算随机退避时间以便再次试图接入信道，因此降低了碰撞发生的概率。</li>
<li>当且仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时，才不使用退避算法。<br>其他所有情况都必须使用退避算法<ul>
<li>在发送第一个帧前检测到信道忙；</li>
<li>每次重传</li>
<li>每次成功发送后要发送下一帧</li>
</ul>
</li>
<li>否则，站点执行CSMA/CA退避算法<ul>
<li>选取一个随机回退值，进入争用窗口</li>
<li>只要信道空闲，退避计时器就进行倒计时；一旦检测到信道忙，退避计时器就冻结</li>
<li>当某个站点的退避计时器减到0时（这时信道只可能是空闲的），该站点就发送整个帧并等待确认帧<br>其它站点的退避倒计时在此阶段又冻结</li>
</ul>
</li>
<li>发送站结束退避算法并成功发送一个数据帧后，存在两种可能<ul>
<li>若在规定时间内收到确认，就知道已发送的这个帧被目的站正确接收。<br>这时如果要发送第二个帧，需要再次执行CSMA/CA退避算法，随机选定一段退避时间并进入争用窗口。</li>
<li>若发送站在规定时间（由重传计时器控制）内没有收到确认帧ACK，就必须重传该帧<br>此时需要再次使用CSMA/CA协议争用该信道进行重传<ul>
<li>该过程直到收到确认帧，或经过若干次重传失败后放弃发送才结束。</li>
</ul>
</li>
</ul>
</li>
<li>争用窗口与退避算法执行的图片<ul>
<li><img src="https://s1.ax1x.com/2023/02/09/pSWn8m9.png" alt="pSWn8m9.png"></li>
</ul>
</li>
</ul>
</li>
<li>信道预约机制（RTS，CTS帧，处理屏蔽站问题）<ul>
<li>站A和B都在AP的覆盖范围内，但A和B相距较远，彼此都听不见对方。<br>当A和B检测到信道空闲时，都向AP发送数据，导致碰撞的发生，这就是隐蔽站问题。</li>
<li>为了避免该问题，802.11允许发送站对信道进行预约。<ul>
<li>源站要发送数据帧之前先广播一个很短的“请求发送”RTS控制帧<ul>
<li>它包括源地址、目的地址和这次通信所持续的时间，该帧能被其范围内包括AP在内的所有站点听到</li>
</ul>
</li>
<li>若信道空闲，等待一个SIFS间隔后，AP广播一个“允许发送”CTS控制帧，它包括这次通信所需的持续时间（从RTS帧复制），该帧也能被其范围内包括A和B在内的所有站点听到。<ul>
<li>CTS帧有两个目的<ul>
<li>给源站明确的发送许可</li>
<li>指示其他站点在预约期内不要发送。</li>
</ul>
</li>
</ul>
</li>
<li>B和其他站听到CTS后，在CTS帧中指明的时间内将抑制发送，当A收到CTS帧之后，在经过一段SIFS后将发送其第一个数据帧并等待确认帧</li>
</ul>
</li>
<li>无线局域网传输数据帧图片<ul>
<li><img src="https://s1.ax1x.com/2023/02/09/pSWumBd.png" alt="pSWumBd.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CSMA/CD与CSMA/CA的区别<ul>
<li>对于冲突的处理<ul>
<li>CSMA/CD可以检测冲突，但无法避免；</li>
<li>CSMA/CA发送数据的同时不能检测信道上有无冲突，本结点处没有冲突并不意味着在接收结点处就没有冲突，只能尽量避免冲突</li>
</ul>
</li>
<li>传输介质不同：CSMA/CD用于总线形以太网，CSMA/CA用于无线局域网802.11</li>
<li>检测方式不同<ul>
<li>CSMA/CD通过电缆中的电压变化来检测</li>
<li>而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式。</li>
</ul>
</li>
<li>总结<ul>
<li>CSMA/CA协议的基本思想是在发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免出现碰撞。</li>
<li>CSMA/CD协议的基本思想是发送前监听，边发送边监听，一旦出现碰撞马上停止发送。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六-局域网（✪）"><a href="#六-局域网（✪）" class="headerlink" title="六.局域网（✪）"></a>六.局域网（✪）</h3><h4 id="1-局域网的概念（LAN）"><a href="#1-局域网的概念（LAN）" class="headerlink" title="1.局域网的概念（LAN）"></a>1.局域网的概念（LAN）</h4><ul>
<li>局域网的三个要素<ul>
<li>局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式<br>其中最重要的是介质访问控制方式，它决定着局域网的技术特性。</li>
<li>拓扑结构<ul>
<li>主要有以下4大类：①星形结构：②环形结构；③总线形结构；④星形和总线形结合的复合型结构。</li>
</ul>
</li>
<li>传输介质<ul>
<li>局域网可以使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质。</li>
</ul>
</li>
<li>介质访问控制方法<ul>
<li>主要有CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</li>
</ul>
</li>
</ul>
</li>
<li>局域网的两个子层（媒体接入控制MAC子层和逻辑链路控制LLC子层）<ul>
<li>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，</li>
<li>与接入传输媒体有关的内容都放在MAC子层，它向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问<br>主要功能是：组帧和拆帧、比特差错检测、寻址、竞争处理</li>
<li>LLC子层的主要功能是：建立和释放数据链路层的逻辑连接、提供与高层的接口、差错控制、给帧加序号（待确认的服务）</li>
</ul>
</li>
</ul>
<h4 id="2-以太网（IEEE-802-3✪）"><a href="#2-以太网（IEEE-802-3✪）" class="headerlink" title="2.以太网（IEEE 802.3✪）"></a>2.以太网（IEEE 802.3✪）</h4><ul>
<li>以太网的概述（802.3局域网简称为以太网）<ul>
<li>IEEE802.3标准是一种基带总线形的局域网标准，它描述物理层和数据链路层的MAC子层的实现方法。</li>
<li>以太网<strong>逻辑上</strong>采用总线形拓扑结构，物理拓扑是星形或拓展星形结构</li>
<li>以太网中的所有计算机共享同一条总线，信息以广播方式发送，包括发送结点在内的总线上的所有结点都能收到信息</li>
<li>为了保证数据通信的方便性和可靠性，以太网简化了通信流程并使用了CSMA/CD方式对总线进行访问控制。<br>当以太网工作在全双工模式下不需要使用CSMA/CD方式（高速以太网）</li>
<li>以太网采用两项措施以简化通信<ul>
<li><strong>采用无确认无连接的工作方式</strong>，不对发送的数据帧编号，也不要求接收方发送确认，<br>即以太网尽最大努力交付数据，提供的是不可靠服务，对于差错的纠正则由高层完成</li>
<li>发送的数据都使用曼彻斯特编码的信号，每个码元的中间出现一次电压转换，接收端利用这种电压转换方便地把位同步信号提取出来。</li>
</ul>
</li>
</ul>
</li>
<li>以太网的传输介质与网卡（✪）<ul>
<li>传输介质<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPi1J2T.png" alt="pPi1J2T.png"></li>
<li>注意：10BASE-T非屏蔽双绞线以太网拓扑结构为星形网，星形网中心为集线器，<br>但使用集线器的以太网在逻辑上仍然是一个总线形网，属于一个冲突域。</li>
</ul>
</li>
<li>网卡（工作在数据链路层与物理层）<ul>
<li>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板【又称网络适配器或网络接口卡(NIC)】实现的。<br>网卡上装有处理器和存储器，是工作在数据链路层的网络组件。</li>
<li>网卡和局域网的通信是通过电缆或双绞线以串行方式进行的，而网卡和计算机的通信则是通过计算机主板上的I/O总线以并行方式进行的。因此，网卡的重要功能就是进行数据的<u>串并转换</u>。</li>
<li>网卡不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</li>
<li>全世界的每块网卡在出厂时都有一个唯一的代码，称为介质访问控制(MAC)地址，<br>这个地址用于控制主机在网络上的数据通信。数据链路层设备(网桥、交换机等)都使用各个网卡的MAC地址。</li>
<li>网卡控制着主机对介质的访问，因此网卡也工作在物理层，<br>因为它只关注比特，而不关注任何地址信息和高层协议信息。</li>
</ul>
</li>
</ul>
</li>
<li>以太网的MAC帧（✪）<ul>
<li>物理地址（MAC地址）<ul>
<li>MAC地址长6字节，一般用由连字符（或冒号）分隔的12个十六进制数表示，如02-60-8c-e4-b1-21</li>
<li>高24位为厂商代码，低24位为厂商自行分配的网卡序列号。</li>
<li>局域网的“地址”应是每个站的“名字”或标识符。</li>
</ul>
</li>
<li>以太网的MAC帧<ul>
<li>由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先要用硬件检查MAC帧中的MAC地址。<br>如果是发往本站的帧，那么就收下，否则丢弃。</li>
<li>以太网MAC帧格式有两种标准：DIX Ethernet V2标准(即以太网V2标准)和IEEE802.3标准。<ul>
<li>以太网V2标准（64-1518字节）<ul>
<li>前导码：使接收端与发送端时钟同步，在帧前面插入8字节<ul>
<li>第一个字段共7字节，是前同步码，用来快速实现MAC帧的比特同步</li>
<li>第二个字段是帧开始定界符，表示后面的信息就是MAC帧。<ul>
<li>注意：MAC帧并不需要帧结束符，因为以太网在传送帧时，各帧之间必须有一定的<u>间隙</u>。</li>
<li>因此，接收端只要找到帧开始定界符，其后面连续到达的比特流就都属于同一个MAC帧</li>
</ul>
</li>
</ul>
</li>
<li>帧的首部（14字节）<ul>
<li>目的地址与源地址：通常使用6字节(48bit)MAC地址</li>
<li>类型：2字节，指出数据域中携带的数据应交给哪个协议实体处理。</li>
</ul>
</li>
<li>数据部分：46~1500字节，包含高层的协议消息。<ul>
<li>由于CSMA/CD算法的限制，以太网帧必须满足最小长度为64字节，0一46字节时数据较少时必须加以填充</li>
<li>由CSMA/CD可知，以太网帧的最短帧长为64B，而MAC帧的首部和尾部的长度为18字节<br>所以数据字段最短为64-18=46字节。最大的1500字节是规定的。</li>
<li>填充：0~46字节，当帧长太短时填充帧，使之达到64字节的最小长度。</li>
</ul>
</li>
<li>帧的尾部：校验码(FCS)，4字节<ul>
<li>校验范围从目的地址段到数据段的末尾，算法采用32位循环冗余码(CRC)，<br>不但需要检验MAC帧的数据部分，还要检验目的地址、源地址和类型字段，但不校验前导码。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPi8O5n.png" alt="pPi8O5n.png"></li>
</ul>
</li>
</ul>
</li>
<li>802.3帧格式<ul>
<li>与DIX以太帧格式的不同之处在于用长度域替代了DIX帧中的类型域，指出数据域的长度</li>
<li>在实践中，前述长度/类型两种机制可以并存，由于IEEE802.3数据段的最大字节数是1500，<br>所以长度段的最大值是1500，因此从1501到65535的值可用于类型段标识符。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>高速以太网（速率达到或超过100Mb/s的以太网称为高速以太网）<ul>
<li>100BASE-T以太网<ul>
<li>100BASE-T以太网是在双绞线上传送100Mb/s基带信号的星形拓扑结构以太网</li>
<li>使用CSMA/CD协议，既支持全双工方式，又支持半双工方式</li>
<li>可在全双工方式下工作而无冲突发生，因此在全双工方式下不使用CSMA/CD协议</li>
<li>MAC帧格式仍然是802.3标准规定的。保持最短帧长不变，<br>但将一个网段的最大电缆长度减小到100m。帧间时间间隔从原来的9.6us改为现在的0.96us.</li>
</ul>
</li>
<li>吉比特以太网（千兆以太网）<ul>
<li>允许在1G/s速率下用全双工和半双工两种方式工作</li>
<li>在半双工方式下使用CSMA/CD协议（全双工方式则不使用）</li>
</ul>
</li>
<li>10吉比特以太网<ul>
<li>以太网不再使用铜线而只使用光纤作为传输媒体。只工作在全双工方式，因此没有争用问题，也不使用CSMA/CD协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-无线局域网（IEEE-802-11✠）"><a href="#3-无线局域网（IEEE-802-11✠）" class="headerlink" title="3.无线局域网（IEEE 802.11✠）"></a>3.无线局域网（IEEE 802.11✠）</h4><ul>
<li><p>无线局域网的组成</p>
<ul>
<li><p>有固定基础设施的无线局域网</p>
<ul>
<li><p>无线局域网802.11（Wi-Fi），802.11使用星形拓扑，其中心称为接入点(AP)，在MAC层使用CSMA/CA协议</p>
</li>
<li><p>无线局域网的最小构件是基本服务集（BSS），一个基本服务集包括一个接入点 (AP) 和若干移动站。</p>
<p>安装AP时，必须为该AP分配一个不超过32字节的服务集标识符(SSID)和一个信道</p>
</li>
<li><p>一个基本服务集覆盖的地理范围称为一个基本服务区(BSA)</p>
</li>
</ul>
</li>
<li><p>无固定基础设施移动自组织网络</p>
<ul>
<li>又称自组网络。自组网络没有上述基本服务集中的AP，而是由一些平等状态的移动站相互通信组成的临时网络</li>
<li>各结点之间地位平等，中间结点都为转发结点，因此都具有路由器的功能。</li>
</ul>
</li>
</ul>
</li>
<li><p>802.11局域网的MAC帧（无线局域网采取有确认无连接的服务）</p>
<ul>
<li>分为数据帧，控制帧，管理帧<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPiOB7t.png" alt="pPiOB7t.png"></li>
</ul>
</li>
<li>数据帧<ul>
<li>MAC首部，共30字节。帧的复杂性都在MAC首部。</li>
<li>帧主体，即帧的数据部分，不超过2312字节。它比以太网的最大长度长很多。</li>
<li>帧检验序列FCS是尾部，共4字节。</li>
</ul>
</li>
</ul>
</li>
<li><p>802.11帧首部的地址字段（✪）</p>
<ul>
<li><strong>地址字段中的前三个地址由帧控制字段中的去往AP和来自AP决定</strong></li>
<li><strong>当去往AP的值为1时，地址1就是接收AP的MAC地址，否则就是目的移动站的MAC地址；</strong></li>
<li><strong>当来自AP的值为1时，地址2就是发送AP的MAC地址，否则就是源移动站的MAC地址。</strong></li>
<li><img src="https://s1.ax1x.com/2023/08/03/pPiOVYT.png" alt="pPiOVYT.png"></li>
<li>举例<ul>
<li><img src="https://s1.ax1x.com/2023/02/09/pSW6yHH.md.png" alt="pSW6yHH.md.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-虚拟局域网VLAN（802-1Q）"><a href="#4-虚拟局域网VLAN（802-1Q）" class="headerlink" title="4.虚拟局域网VLAN（802.1Q）"></a>4.虚拟局域网VLAN（802.1Q）</h4><ul>
<li>可以把一个较大的局域网分割成一些较小的与地理位置无关的逻辑上的VLAN，以软件方式实现</li>
<li>可以同时隔离冲突域与广播域，一个VLAN是一个广播域</li>
<li>在以太网帧中插入一个4字节的标识符（插入在源地址字段和类型字段之间），称为VLAN标签<br>用来指明发送该帧的计算机属于哪个虚拟局域网。</li>
<li>插入VLAN标签的帧称为802.1Q帧。由于VLAN帧的首部增加了4字节，因此以太网的最大帧长从原来的1518字节变为1522字节。VLAN帧后12位为标识符VID（可表示4096个）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPij9Zn.png" alt="pPij9Zn.png"></li>
</ul>
</li>
</ul>
<h3 id="七-广域网"><a href="#七-广域网" class="headerlink" title="七.广域网"></a>七.广域网</h3><h4 id="1-广域网的基本概念"><a href="#1-广域网的基本概念" class="headerlink" title="1.广域网的基本概念"></a>1.广域网的基本概念</h4><ul>
<li>广域网比局域网多了一个网络层的层次（使用的协议主要在网络层）</li>
<li>广域网与局域网的区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPFSqgK.png" alt="pPFSqgK.png"></li>
</ul>
</li>
</ul>
<h4 id="2-PPP协议（点对点协议）"><a href="#2-PPP协议（点对点协议）" class="headerlink" title="2.PPP协议（点对点协议）"></a>2.PPP协议（点对点协议）</h4><ul>
<li>概述<ul>
<li>使用串行线路通信的<u>面向字节</u>的协议，该协议应用在直接连接两个结点的链路上。</li>
<li>通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同的解决方案。</li>
</ul>
</li>
<li>三个组成部分<ul>
<li>链路控制协议(LCP)：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</li>
<li>网络控制协议(NCP)：PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</li>
<li>一个将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元(MTU)的限制。</li>
</ul>
</li>
<li>PPP帧的格式<ul>
<li>PPP是面向字节的，因而所有PPP帧的长度都是整数个字节</li>
<li><img src="https://s1.ax1x.com/2023/08/03/pPFVeVf.png" alt="pPFVeVf.png"></li>
</ul>
</li>
<li>ppp协议的特点<ul>
<li>PPP提供差错检测但不提供纠错功能，只保证无差错接收(通过硬件进行CRC校验)<br>它是不可靠的传输协议，因此也不使用序号和确认机制。</li>
<li>它仅支持点对点的链路通信，不支持多点线路。</li>
<li>PPP只支持全双工链路。</li>
<li>PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信。</li>
<li>PPP是面向字节的，当信息字段出现和标志字段一致的比特组合时，PPP有两种不同的处理方法<ul>
<li>若PPP用在异步线路（默认），则采用字符填充法；</li>
<li>若PPP用在SONET/SDH等同步线路，则协议规定采用硬件来完成比特填充(和HDLC的做法一样)。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="八-数据链路层设备（✪）"><a href="#八-数据链路层设备（✪）" class="headerlink" title="八.数据链路层设备（✪）"></a>八.数据链路层设备（✪）</h3><h4 id="1-网桥"><a href="#1-网桥" class="headerlink" title="1.网桥"></a>1.网桥</h4><ul>
<li>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段</li>
<li>网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域（又称冲突域）。</li>
<li>网桥必须具有路径选择的功能，接收到帧后，要决定正确的路径，将该帧转送到相应的目的局域网站点。</li>
</ul>
<h4 id="2-交换机的原理与特点"><a href="#2-交换机的原理与特点" class="headerlink" title="2.交换机的原理与特点"></a>2.交换机的原理与特点</h4><ul>
<li>原理<ul>
<li>以太网交换机的实质是一种多端口网桥<ul>
<li>网桥：隔离冲突域，但只有一个发送端口一个接收端口</li>
</ul>
</li>
<li>检测从以太端口来的数据帧的源和目的地的MAC（介质访问层）地址，然后与系统内部的动态查找表进行比较，</li>
<li>若数据帧的源MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</li>
</ul>
</li>
<li>特点<ul>
<li>以太网交换机的每个端口都直接与单台主机相连（网桥的端口往往连接到一个网段），并且一般都工作在全双工方式。</li>
<li>以太网交换机能同时连通多对端口，使每对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</li>
<li>以太网交换机是一种即插即用设备，其内部的帧的转发表是通过自学习算法自动地逐渐建立起来的。</li>
<li>以太网交换机由于使用专用的交换结构芯片，交换速率较高。</li>
<li>以太网交换机独占传输媒体的带宽。<ul>
<li>若交换机连接的10Mb/s的共享式以太网，若共有10个用户，则每个用户能够占有10MB/S带宽</li>
<li>且总带宽为10*10=100MB/S</li>
</ul>
</li>
</ul>
</li>
<li>两种交换模式<ul>
<li>直通式交换机<ul>
<li>只检查帧的目的地址，这使得帧在接收后几乎能马上被传出去。</li>
<li>这种方式速度快，但缺乏智能性和安全性，也无法支持具有不同速率的端口的交换。</li>
<li>例<ul>
<li>此时为直通交换只检查目的地址6字节为：6*8/v，选B</li>
<li><img src="https://s1.ax1x.com/2023/08/03/pPFntX9.png" alt="pPFntX9.png"></li>
</ul>
</li>
</ul>
</li>
<li>存储转发式交换机<ul>
<li>先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，</li>
<li>确认无误后通过查找表转换成输出端口将该帧发送出去。如果发现帧有错，那么就将其丢弃。</li>
<li>优点是可靠性高，并能支持不同速率端口间的转换，缺点是延迟较大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-交换机的自学习功能"><a href="#3-交换机的自学习功能" class="headerlink" title="3.交换机的自学习功能"></a>3.交换机的自学习功能</h4><ul>
<li>决定一个帧是应该转发到某个端口还是应该将其丢弃称为过滤</li>
<li>决定个顺应该被移动到哪个接口称为转发</li>
<li>交换机的过滤和转发借助于交换表完成；<br>至少包含：一个MAC地址；连通该MAC地址的交换机端口。</li>
<li>自学习流程：<ul>
<li>记录帧从相应端口进入交换机的源地址（建立地址与端口对应的交换表）</li>
<li>在查找到转发表没有相关目的地址的情况下，从除接收端口以外的其它所有端口转发出去</li>
<li>在有效时间之后将自动删除交换机的表项</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/08/03/pPFmp5T.png" alt="pPFmp5T.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第二章-物理层</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="计算机网络第二章-物理层"><a href="#计算机网络第二章-物理层" class="headerlink" title="计算机网络第二章 物理层"></a>计算机网络第二章 物理层</h2><blockquote>
<p>计算机学科基础：计算机网络第二章物理层的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-通信基础（✪）"><a href="#一-通信基础（✪）" class="headerlink" title="一.通信基础（✪）"></a>一.通信基础（✪）</h3><h4 id="1-基本概念（✠）"><a href="#1-基本概念（✠）" class="headerlink" title="1.基本概念（✠）"></a>1.基本概念（✠）</h4><ul>
<li>消息、数据和信号<ul>
<li>消息：需要由计算机处理和传输的文字、图片、音频和视频等内容。</li>
<li>数据是指传送信息的实体，计算机只处理二进制数据（0/1）</li>
<li>信号则是数据的电气或电磁表现，是数据在传输过程中的存在形式。</li>
</ul>
</li>
<li>数字信号和模拟信号<ul>
<li>离散的信号称为数字信号，是用一系列断续变化的电压脉冲或光脉冲来表示。<br>数字信号可看做基波与高次谐波的叠加。如二进制数</li>
<li>连续变化的信号称为模拟信号，用一系列连续变化的电磁波或电压信号来表示，如声音</li>
</ul>
</li>
<li>信道（信号传输的媒介）<ul>
<li>按照传输信号形式的不同：数字信道，模拟信道</li>
<li>按照传输介质的不同：无线信道，有线信道</li>
<li>按照通信双方的交互方式：单向通信、半双工通信、全双工通信<ul>
<li>单向通信：只能有一个方向的通信（无线电广播和电视广播）</li>
<li>半双工通信：发送信息不能同时进行（对讲机、总线型以太网）</li>
<li>全双工通信：可以同时通信（有线电话、交换式以太网）</li>
</ul>
</li>
</ul>
</li>
<li>基带信号和宽带信号<ul>
<li>由信源发出的原始信号称为基带信号，也就是基本频带信号。<ul>
<li>基带信号将数字信号1和0直接用高电平和低电平表示</li>
</ul>
</li>
<li>宽带信号是基带信号调制之后形成的频分复用模拟信号</li>
</ul>
</li>
<li>基带传输，频带传输与宽带传输<ul>
<li>基带传输：将基带信号直接传送到数字信道上（不需要进行调制，用于局域网）</li>
<li>频带传输：将基带信号进行调制后形成了模拟信号，之后送到模拟信道上传输<br>适用于远距离传输与无线传输</li>
<li>宽带传输<ul>
<li>借助频带传输，可将链路容量分解成两个或多个信道，每个信道可以携带不同的信号</li>
<li>宽带传输中所有的信道能同时互不干扰地发送信号，链路容量大大增加。</li>
<li>比如把信道进行频分复用，划分为2条互不相关的子信道，<br>分别在两条子信道上同时进行频带传输，链路容量就大大增加了</li>
</ul>
</li>
</ul>
</li>
<li>串行传输与并行传输<ul>
<li>串行传输：只有一条数据传输线路，数据逐比特依次传输（远距离通信通常采用串行传输）</li>
<li>并行传输：若干比特通过多条通信信道同时传输。并行传输的成本高，仅适用于短距离传输（计算机内部的数据传输）<ul>
<li>多条数据传输线路，数据传输线路的数量也称为数据总线宽度（8/16/32/64）。</li>
<li>计算机中的网卡具有串行传输和并行传输的功能，网卡可以进行串并转换。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/24/pSY43rD.png" alt="pSY43rD.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>同步传输和异步传输<ul>
<li>同步传输<ul>
<li>以比特为传输单位，数据块以比特流的形式传输，字节之间没有间隔，也没有起始位和终止位</li>
<li>要求收发双方对表示比特的信号的时间长度达成一致。接收方在比特信号的中间时刻进行采样，<br>收发双方时钟频率的误差累积会造成比特信号采样时刻的严重偏移。</li>
<li>在同步传输方式中实现收发双方的时钟同步，可以采取以下方法：<ul>
<li>外同步：在收发双方之间增加一条时钟线，多发一路时钟信号。</li>
<li>内同步：发送端将时钟信号编码到发送数据中一起发送。（如曼彻斯特编码和差分曼彻斯特编码都含时钟编码）</li>
</ul>
</li>
</ul>
</li>
<li>异步传输：以字节为传输单位，但字节之间的时间间隔并不固定，给每个字节添加起始位和结束位<br>接收端只在每个字节的起始处对字节内的比特实现同步。</li>
</ul>
</li>
<li>码元<ul>
<li>码元是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，<br>代表不同离散数值的基本波形，是数字通信中数字信号的计量单位</li>
<li>这个时长内的信号称为k进制码元，而该时长称为码元宽度。1码元可以携带若干比特的信息量<ul>
<li>例如，在使用二进制编码时，只有两种不同的码元：一种代表0状态，另一种代表1状态。</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/24/pSYqWK1.png" alt="pSYqWK1.png"></li>
</ul>
</li>
</ul>
</li>
<li>码元传输速率，信息传输速率（✪）<ul>
<li>速率也称数据率，指的是数据传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示。</li>
<li>码元传输速率。又称波特率，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），<br>单位是波特(Bud)<ul>
<li>1波特表示数字通信系统每秒传输一个码元。码元可以是多进制的，也可以是二进制的，码元速率与进制数无关。</li>
</ul>
</li>
<li>信息传输速率。又称信息速率、比特率等，它表示单位时间内数字通信系统传输的比特数，单位是比特/秒(b/s)。<ul>
<li>信息的传输速率=波特率*一个码元所含的比特数</li>
</ul>
</li>
<li>例题<ul>
<li>此时为曼彻斯特编码，每个比特中间会产生一次跳变，相当于是1个比特由两个码元表示，因此信息速率为$\frac{1}{2}$波特率<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pP9Cy7R.png" alt="pP9Cy7R.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-信号失真"><a href="#2-信号失真" class="headerlink" title="2.信号失真"></a>2.信号失真</h4><ul>
<li><p>任何实际的信道都是不理想的，信号在信道的传输中会不可避免的出现失真。</p>
</li>
<li><p>造成信号失真的主要因素</p>
<ul>
<li><p>码元的传输速率越高，信号经过传输后的失真就越严重</p>
</li>
<li><p>信号的传输距离越远，信号经过传输后的失真就越严重</p>
</li>
<li><p>噪音干扰越大，信号经过传输后的失真就越严重</p>
</li>
<li><p>传输媒体的质量越差，信号经过传输后的失真就越严重</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-奈氏定理（✪）"><a href="#3-奈氏定理（✪）" class="headerlink" title="3.奈氏定理（✪）"></a>3.奈氏定理（✪）</h4><ul>
<li><p>奈氏定理解决的问题：避免码间串扰</p>
<ul>
<li>对于每一种信道来说，能通过的频率的范围是有限的，信号中的许多高频分量往往不能通过信道</li>
<li><p>如果数字信号中的高频分量在传输时受到衰减甚至不能通过信道，则接收端接收到的波形的前沿和后沿就变得不那么陡峭，<br>每一个码元所占的时间界限也不再明确，而是前后都拖了尾巴。<br>此时在接收端接收到的信号波形就失去了码元之间的清晰界限，这种现象成为码间串扰。</p>
</li>
<li><p>如果信道的频带越宽，则能够通过的信号的高频分量越多，那么码元的传输速率就可以更高，就不会导致码间串扰。</p>
</li>
<li>因此提出了奈氏准则：解决理想低通信道（无噪声，带宽受限）的频率带宽和该信道的最高码元传输速率的问题。</li>
</ul>
</li>
<li><p>奈氏定理内容</p>
<ul>
<li><strong>理想低通信道下的极限数据传输速率</strong>=$2W(码元/s)=2W1og_2V(单位为b/s)$</li>
<li>一般来说需要将以波特率为单位的速率转换为以比特每秒为单位的速率<ul>
<li>波特率B：码元传输速率=调制速率=波形数率=符号速率</li>
<li>信息的传输速率=波特率*一个码元具有的比特数量（信息量）</li>
<li>一个码元所携带的比特数量=$\log_{2}{X}$  (X为调制出的码元种数)</li>
<li>码元种数=一个码元所取的有效离散值=码元的波形个数</li>
</ul>
</li>
<li>W为理想低通信道的带宽</li>
<li>V表示每个码元离散电平的数目，即每个码元所带的信息量</li>
<li>在任何信道中，若码元的传输速率超过此上限(2倍带宽)，则会出现严重的码间串扰问题</li>
<li>总结：由于码元传输速率受奈氏准则的制约，所以要提高数据传输速率，就必须设法使每个码元携带更多比特的信息量，<br>此时就需要采用多元制的调制方法。</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/01/28/pSUvGse.png" alt="pSUvGse.png"></li>
</ul>
</li>
</ul>
<h4 id="4-香农公式（✪）"><a href="#4-香农公式（✪）" class="headerlink" title="4.香农公式（✪）"></a>4.香农公式（✪）</h4><ul>
<li>香农公式解决的问题：带宽受限且在噪声干扰下的极限信息传输速率<ul>
<li>根据奈氏准则，在理想信道上，为了提升信道的传输速率，就需要使每个码元可以表示更多的信息量（提高每个码元携带比特的数量），可以采取更复杂信号调制方法实现。但是信息的传输速率并不能无限制的提高，因为有噪声的干扰。</li>
<li>香农公式推导出了频率带宽受限且有高斯白噪声干扰下的信道的极限信息传输速率，用此速率进行传输时，可以不产生误差</li>
</ul>
</li>
<li>香农公式内容<ul>
<li>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率：${C=W \log _{2}(1+\frac{S}{N})}$ </li>
<li>C: 信道的极限信息传输速率 (单位为${\mathbf{b} / \mathbf{s}}$)</li>
<li>W: 信道的频率带宽 (单位为${\mathrm{Hz}}$)</li>
<li>S: 信道内所传信号的平均功率</li>
<li>N: 信道内的高斯噪声功率</li>
<li>计算时公式中的信噪比$\frac{S}{N}$必须是无量纲的常数值<ul>
<li>如果题目中的信噪比没有单位，直接代入计算即可</li>
<li>如果题目中的信噪比的单位是db，则需要通过公式转换为无量纲的值后再代入此，$信噪比(单位分贝){=10 \log _{10}\left(\frac{S}{N}\right)}$</li>
</ul>
</li>
</ul>
</li>
<li><p>对于香农公式的说明</p>
<ul>
<li><p>如果已知信噪比的分贝值，需用公式求出$\frac{S}{N}$的值。</p>
</li>
<li><p>信道的频率带宽或信道中的信噪比越大，信道的极限信息传输速率就越高。</p>
</li>
<li><p>信道的实际传输速率要比香农公式中的极限传输速率低不少，因为信道还要受到各种脉冲干扰和信号衰减。</p>
</li>
<li>总结：在频带带宽一定的情况下，提高信道的传输速率需要采取多元制（更复杂的调制技术）并提高信噪比。</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p><strong>对于算极限数据传输速率的题目，如果出现信噪比而不涉及信号的状态，则只需要考虑利用香农公式来求解</strong><br><strong>如果在出现信噪比的同时还出现了信号的状态，则此时还需要用奈氏公式，计算后取速率较小的值</strong></p>
<ul>
<li><p>本题需要将两种公式分别列出后计算。由于信噪比的单位是分贝，此时需要用公式转换为无量纲的值</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/01/28/pSUbMPU.png" alt="pSUbMPU.png"></li>
</ul>
</li>
<li><p>本题涉及了信号的状态数（二进制信号，说明一个比特有两个信号数）此题需要列出两种公式并选择其中最小的值作为最大的速率，信噪比无量纲，直接代入公式计算即可</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pPpvNtS.png" alt="pPpvNtS.png"></li>
</ul>
</li>
<li><p>本题只有信噪比给出不涉及码元与比特数之间的关系，直接用香农定理以及量纲转换求出即可，选C</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pPpzVPO.png" alt="pPpzVPO.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-编码与调制（✠）"><a href="#5-编码与调制（✠）" class="headerlink" title="5.编码与调制（✠）"></a>5.编码与调制（✠）</h4><ul>
<li>把数据变为数字信号称为编码，把数据变为模拟信号称为调制<ul>
<li>编码：对数字基带信号的波形进行变换，使其能够与信道特性相适应，调制后的信号仍是数字基带信号</li>
<li>调制：将数字基带信号的频率范围利用载波搬移到更高的频段，并转换为模拟信号，使其能够在模拟信道中传输。</li>
</ul>
</li>
<li>数字数据编码成为数字信号<ul>
<li>归零编码  (RZ)<ul>
<li>高电平表示1，低电平表示0</li>
<li>信号在每个码元期间(中间)会回归到零电平。</li>
<li>归零编码相当于将时钟信号编码在了数据之内，也称为自同步信号。</li>
<li>缺点：大部分的带宽为了传输归零而浪费掉了。</li>
</ul>
</li>
<li>非归零编码（NRZ）<ul>
<li>信号在每个码元期间不会回归到零电平。</li>
<li>此编码效率最高，但是需要增加时钟信号线来解决同步问题。</li>
</ul>
</li>
<li>反向非归零编码（NRZI）<ul>
<li>与非归零编码的区别在于用信号的翻转代表0，信号保持不变则代表1</li>
<li>既能传输时钟信号，又能尽量不损失系统带宽</li>
</ul>
</li>
<li>曼彻斯特编码（✪）<ul>
<li>在每个码元的中间时刻电平都会发生跳变（即可作为同步信号，又可作为数据信号）</li>
<li>自行定义向上跳变时和向下跳变时的表示数据。</li>
<li>比如设中间时刻上变化为0，向下为1。则直接看码元中间是向上还是向下，向上变化为0，向下变化为1。</li>
<li>10Mb/s的传统以太网采用的是曼彻斯特编码。</li>
<li>例<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pP9J8u4.md.png" alt="pP9J8u4.md.png"></li>
</ul>
</li>
</ul>
</li>
<li>差分曼彻斯特编码（✪）<ul>
<li>在每个码元的中间时刻都会进行跳变（仅作为同步信号）</li>
<li><strong>数据信号的表示在于每一个码元开始处是否有电平跳变，无跳变表示1，有跳变表示0</strong></li>
<li>可在题目中设置第一个码元是0还是1，之后的码元都可以根据波形来判断</li>
<li>在噪声干扰环境下比曼彻斯特编码更容易检测。</li>
<li>例<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pP9ARyT.md.jpg" alt="pP9ARyT.md.jpg"></li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/30/pPpIkp6.png" alt="pPpIkp6.png"></li>
</ul>
</li>
</ul>
</li>
<li>数字数据调制成为模拟信号（✪）<ul>
<li>基本调制方法<ul>
<li>调幅(ASK)：通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。</li>
<li>调频(FSK)：通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，目前应用较为广泛。</li>
<li>调相(PSK)。通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/24/pSYOJ6s.png" alt="pSYOJ6s.png"></li>
</ul>
</li>
</ul>
</li>
<li>正交振幅调制(QAM)：在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。（✪）<ul>
<li>使一个码元可以表示多个比特的信息量。</li>
<li>因为载波的频率和相位是相关的，所以载波的频率和相位不能进行混合调制。<br>载波的振幅和相位可以结合起来一起调制，被称为正交振幅调制（QAM）</li>
<li>设波特率为B，采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输速率R为：$R = B \log _ { 2 } ( m n )$</li>
<li>例：易错，本题为无噪声环境，应该优先考虑奈氏定理=2<em>3\</em>$log_216$=24<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pP9EkX8.png" alt="pP9EkX8.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>模拟数据编码为数字信号（主要是脉冲编码调制PCM）（✪）<ul>
<li>这种编码方式最典型的例子是常用于对<strong>音频信号</strong>进行编码的脉冲编码调制(PCM)。它主要包括三个步骤，即采样、量化和编码。</li>
<li>采样是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。<ul>
<li>当采样的频率大于或等于模拟数据的频带带宽（最高变化频率）的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。（采样定理）</li>
</ul>
</li>
<li>量化是把采样取得的电平幅值按照一定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li>
<li>编码是把量化的结果转换为与之对应的二进制编码。</li>
<li>例题<ul>
<li>求最大传输速率，此时24无效，大于2*8（不符合采样定理）$V=2<em>8</em>log_28=48$（无噪声可以用奈氏定理）<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pP9SufU.png" alt="pP9SufU.png"></li>
</ul>
</li>
<li>求最大的传输速率，但此时没有说是理想低通或无噪声信道下，不能用奈氏定理（因此不乘2）选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pP9pMUP.png" alt="pP9pMUP.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>模拟数据调制为模拟信号<ul>
<li>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。</li>
</ul>
</li>
</ul>
<h4 id="6-三种数据交换方式（✪）"><a href="#6-三种数据交换方式（✪）" class="headerlink" title="6.三种数据交换方式（✪）"></a>6.三种数据交换方式（✪）</h4><ul>
<li>电路交换（电话交换机的交换方式）<ul>
<li>电路交换的流程：建立连接、数据传输、连接释放（在数据传输的过程中，用户始终占用端到端的固定传输带宽）</li>
<li>电路交换不提供差错控制功能</li>
<li>电路交换的优点<ul>
<li><strong>传输时延较小：数据传输量较大时明显</strong></li>
<li>有序传输：不存在失序问题</li>
<li>没有冲突：不同的通信双方拥有不同的信道</li>
<li>适用范围广：既适用于传输模拟信号，又适用于传输数字信号</li>
<li>实时性强：通信双方之间的物理通路一旦建立，双方就可以随时通信</li>
<li>控制简单</li>
</ul>
</li>
<li>电路传输的缺点<ul>
<li>建立连接时间长：不利于计算机通信</li>
<li>线路独占：信道利用率低</li>
<li>灵活性差</li>
<li>难以规格化</li>
</ul>
</li>
<li>总结<ul>
<li>由于计算机之间的数据传输是突发式的，使用电路交换来传输计算机数据的效率很低</li>
<li>若要连续传送大量的数据，并且数据传送的时间远长于建立连接的时间，则电路交换具有更高的传输效率</li>
<li>用户线是电话用户专用的，电话交换机之间的中继线是许多用户共享的<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS1WkWQ.md.png" alt="pS1WkWQ.md.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>报文交换<ul>
<li>报文交换采用存储转发的方式，单位是报文（携带源地址，目的地址信息）<ul>
<li>存储转发：交换设备收到报文之后先存储整个报文，存储完成之后再选择链路转发</li>
</ul>
</li>
<li>报文交换的优点<ul>
<li>无需建立连接</li>
<li>动态分配链路</li>
<li>链路可靠性强</li>
<li>线路利用率高</li>
<li>提供多目标服务</li>
</ul>
</li>
<li>报文交换的缺点<ul>
<li>存在转发时延</li>
<li><strong>报文交换对报文的大小没有限制，需要网络结点有较大的存储空间</strong><ul>
<li>由于其对报文的大小没有限制，数据经过网络的传输延迟长而且不固定，因此报文交换不能用于语音数据传输</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分组交换</p>
<ul>
<li>分组交换采用存储转发的方式，限制了每次传送的数据块大小的上限，并且加上一些必要的控制信息（地址信息）构成分组（Packet）</li>
<li>分组交换的过程：网络结点根据控制信息把分组送到下一个结点，下一个结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一个结点，直到到达目的结点。</li>
<li><p>分组交换的优点</p>
<ul>
<li>无建立时延</li>
<li>线路利用率高</li>
<li>相对于报文交换简化了存储（缓冲区）管理</li>
<li>加速传输（<strong>相较于报文交换而言</strong>）</li>
<li>减少了出错概率和重发数据量</li>
</ul>
</li>
<li><p>分组交换的缺点</p>
<ul>
<li>分组首部带来了额外的传输开销，增加时延</li>
<li>存储转发造成了一定的时延</li>
<li><strong>当分组交换采用数据报服务时，可能会出现失序，丢失或重复分组等问题</strong><ul>
<li>当分组交换采用虚电路时，有三个虚电路的过程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>区别<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS1fVhD.png" alt="pS1fVhD.png"></li>
</ul>
</li>
<li>计算分组交换时延（♚）<ul>
<li>计算分组交换时延时，首先计算出分组的数量，在第一个链路上需要计算所有分组的发送时延，之后经过的链路只需计算单个分组的发送时延</li>
<li>总发送时延=在一条链路上所有分组的发送时延+在一条链路上一个分组发送时延*路由器的数量（链路数-1）</li>
<li>报文交换的时延=在一条链路上的发送时延*链路数</li>
<li>例题：<ul>
<li>本题需要注意B=8b<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS15rUP.png" alt="pS15rUP.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-分组交换的两种方式（✪）"><a href="#7-分组交换的两种方式（✪）" class="headerlink" title="7.分组交换的两种方式（✪）"></a>7.分组交换的两种方式（✪）</h4><ul>
<li>数据报方式与虚电路方式均由网络层提供    </li>
<li><p>数据报交换（无连接的数据报方式）</p>
<ul>
<li><p>流程</p>
<ul>
<li>在端系统中的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据报分组(即网络层的PDU).</li>
<li>中间结点存储分组很短一段时间，找到最佳的路由后，尽快转发每个分组。</li>
<li>不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pPpLoi4.png" alt="pPpLoi4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>数据报方式的特点</p>
<ul>
<li>不需要建立连接，可随时发送和接收</li>
<li>属于不可靠传输（没有确认机制，可能引发丢失与失序问题）</li>
<li>发送的分组需要包括源地址与目的地址，以便可以独立传输</li>
<li>存储转发具有排队时延，发生拥塞时，时延增大</li>
<li>网络具有冗余路径，对故障的适应能力强，可以用在出错率较高的传输系统</li>
<li>网络吞吐量较高</li>
<li>资源利用率较高</li>
</ul>
</li>
</ul>
</li>
<li><p>虚电路交换（面向连接的虚电路方式）</p>
<ul>
<li><p>流程：虚电路建立、数据传输与虚电路释放</p>
<ul>
<li><p>在分组发送之前，要求在发送方和接收方建立一条<strong>逻辑上相连的虚电路</strong>，并且连接一旦建立，就固定了虚电路所对应的物理路径。</p>
<ul>
<li>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路，以区别于本系统中的其他虚电路。</li>
<li>为进行数据传输，主机A与主机B之间先建立一条逻辑通路，主机A发出一个特殊的“呼叫请求”分组，该分组通过中间结点送往主机B，若主机B同意连接，则发送“呼叫应答”分组予以确认。</li>
</ul>
</li>
<li><p>虚电路建立后，主机A就可向主机B发送数据分组，主机B也可在该虚电路上向主机A发送数据。</p>
<ul>
<li>在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它要通过的虚电路号，以区别于其他虚电路上的分组。</li>
<li>在虚电路网络中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路的信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。</li>
<li>数据的传输是双向进行的，上述信息是在虚电路的建立过程中确定的。</li>
</ul>
</li>
<li><p>传送结束后主机A通过发送“释放请求”分组来拆除虚电路，逐段断开整个连接。</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/31/pPpOiQI.png" alt="pPpOiQI.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>虚电路传输的特点</p>
<ul>
<li>虚电路连接的建立和拆除需要时间开销，虚电路对于长时间、频繁的数据交换的效率较高</li>
<li>虚电路的路由选择体现在连接建立阶段，连接建立之后就确定了传输数据</li>
<li><strong>虚电路属于可靠连接（可靠性由网络保证，有确认机制），能够确保每个分组正确并且有序到达，并且还可以进行流量控制</strong></li>
<li>拓展性差，发生故障影响较大，不宜用在出错率较高的传输系统</li>
<li><strong>虚电路的分组首部不包含目的地址，包含的是虚电路表示符，开销较小</strong></li>
<li>每个结点到其它结点之间的链路可以同时有若干虚电路通过，也可以与多个结点之间建立虚电路（不需要对每条虚电路预分配带宽）<ul>
<li>每条虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据报服务和虚电路服务的区别<ul>
<li><img src="https://s1.ax1x.com/2023/08/02/pPP7jp9.png" alt="pPP7jp9.png"></li>
</ul>
</li>
</ul>
<h3 id="二-传输介质（✠）"><a href="#二-传输介质（✠）" class="headerlink" title="二.传输介质（✠）"></a>二.传输介质（✠）</h3><h4 id="1-各种传输介质"><a href="#1-各种传输介质" class="headerlink" title="1.各种传输介质"></a>1.各种传输介质</h4><h5 id="①导向型传输媒体"><a href="#①导向型传输媒体" class="headerlink" title="①导向型传输媒体"></a>①导向型传输媒体</h5><ul>
<li><p>双绞线</p>
<ul>
<li><p>把两根互相绝缘的铜导线按一定的密度互相绞合构成了双绞线</p>
</li>
<li><p>绞合可以减少对相邻导线的电磁干扰</p>
</li>
<li><p>对双绞线外部加上一层金属丝屏蔽层，则称为屏蔽双绞线电缆（STP），可进一步提高抗电磁干扰的能力</p>
<p>没有的话则为非屏蔽双绞线电缆（UTP）</p>
</li>
<li><p>双绞线的带宽取决于铜线的粗细和传输的距离</p>
</li>
<li><p>适用范围</p>
<ul>
<li>模拟传输和数字传输都可以使用双绞线</li>
<li>100BaseT 快速以太网使用的导向传输介质是双绞线</li>
</ul>
</li>
<li><p>双绞线对于模拟传输距离太长的话需要添加放大器设备，以便将衰减了的信号放大到合适的强度 </p>
<p>对于数字传输距离太长的话需要添加中继器设备，以便对失真的信号进行整形</p>
</li>
</ul>
</li>
<li><p>同轴电缆</p>
<ul>
<li>同轴电缆由内导体、绝缘层、外屏蔽层和外部保护层组成。</li>
<li><strong>同轴电缆具有较好的抗干扰性（屏蔽性更好），被广泛的用于高速率数据传输。</strong></li>
<li>同轴电缆一般有以下的两类：<ul>
<li>50Ω阻抗的基带同轴电缆：用于数字传输，局域网</li>
<li>75Ω阻抗的宽带同轴电缆：用于模拟传输，有线电视系统</li>
</ul>
</li>
</ul>
</li>
<li><p>光纤</p>
<ul>
<li><strong>光纤是光导纤维的简称，是用高透明度的石英玻璃拉成的柔软细丝，由包层（通常直径不超过125um）和纤芯（8—100um）组成的双层通信圆柱形传输媒体</strong></li>
<li>光纤通信是利用光脉冲在光纤中的传递来进行通信的，有光脉冲相当于比特1，没有相当于比特0。</li>
<li>光波在光纤中不断发生全反射，就可以沿着光纤传输下去<ul>
<li><img src="https://s1.ax1x.com/2023/01/24/pSY20YV.md.png" alt="pSY20YV.md.png"></li>
</ul>
</li>
<li><p>单模光纤和多模光纤</p>
<ul>
<li>有多个入射角度射入光纤时可产生多条光波在同一条光纤中传输（不断全反射），称为多模光纤。<ul>
<li>多模光纤的光源为发光二极管</li>
<li>光脉冲在多模光纤中传输时会逐渐展宽，造成失真，只适合在近距离传输</li>
</ul>
</li>
<li>当光纤的直径减小到只有一个光的波长，则光波会一直向前传播而不会发生多次反射，称为单模光纤。<ul>
<li>单模光纤的光源为半导体激光器，其制造成本较高</li>
<li>单模光纤的衰减较小，可以不必采用中继器，适合远距离传输</li>
</ul>
</li>
</ul>
</li>
<li><p>光纤的优点</p>
<ul>
<li>通信容量非常大，传输速率十分大</li>
<li>抗雷电和电磁干扰性能好。在有大电流脉冲干扰的环境下十分稳定</li>
<li>传输损耗小。中继距离长，对远距离传输十分经济</li>
<li>无串音干扰，保密性好。</li>
<li>体积小，重量轻。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="②非导向型传输媒体"><a href="#②非导向型传输媒体" class="headerlink" title="②非导向型传输媒体"></a>②非导向型传输媒体</h5><ul>
<li>无线电波：具有较强的穿透能力，适用于无线局域网(WLAN)</li>
<li>微波、红外线和激光（高带宽无线通信）<ul>
<li>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz，因而通信信道的容量大</li>
<li>与通常的无线电波不同，微波通信的信号是沿直线传播的，因此在地面的传播距离有限，超过一定距离后就要用中继站来接力</li>
<li>红外通信和激光通信把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</li>
<li>卫星通信利用地球同步卫星作为中继来转发微波信号，可以克服地面微波通信距离的限制。<br>三颗相隔120°的同步卫星几乎能覆盖整个地球表面，因而基本能实现全球通信。<ul>
<li>卫星通信的优点是通信容量大、距离远、覆盖广，缺点是保密性差、端到端传播时延长。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-物理层接口的特性（✠）"><a href="#2-物理层接口的特性（✠）" class="headerlink" title="2.物理层接口的特性（✠）"></a>2.物理层接口的特性（✠）</h4><ul>
<li>物理层实现的功能<ul>
<li>在各种传输媒体上传输比特流，进而给其上面的数据链路层提供透明传输比特流的服务<ul>
<li>透明传输比特流：数据链路层看不见（也无需看见）物理层究竟使用的是什么方法来传输比特流，<br>数据链路层只需享受物理层提供的传输比特流的服务即可。</li>
</ul>
</li>
<li>物理层为数据链路层屏蔽掉了各种传输媒体和通信手段的差异。</li>
</ul>
</li>
<li>物理层接口特性（✪）<ul>
<li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li>
<li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性：<strong>指明某条线上出现的某一电平的电压表示<u>何种意义</u>。</strong></li>
<li>过程特性：或称规程特性。指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
</li>
</ul>
<h3 id="三-物理层设备"><a href="#三-物理层设备" class="headerlink" title="三.物理层设备"></a>三.物理层设备</h3><h4 id="1-中继器（仅作用于信号的电气部分）"><a href="#1-中继器（仅作用于信号的电气部分）" class="headerlink" title="1.中继器（仅作用于信号的电气部分）"></a>1.中继器（仅作用于信号的电气部分）</h4><ul>
<li>中继器的主要功能是将信号整形并放大再转发出去，以消除信号经过一长段电缆后而产生的失真和衰减，使信号的波形和强度达到所需要的要求，进而扩大网络传输的距离。<ul>
<li>中继器的原理是信号再生，并非简单的将衰减的信号放大</li>
</ul>
</li>
<li>放大器和中继器都起放大作用，只不过放大器放大的是模拟信号，原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。</li>
<li>在一个由中继器或集线器互联的网络中，任意发送方和接收方最多只能经过4个中继器，5个网段</li>
<li>由于中继器工作在物理层，因此它不能连接两个具有不同速率的局域网。<ul>
<li>只有具有存储-转发功能的网络设备才能够连接两个不同的协议</li>
<li>两个网段在物理层进行互联时要求数据传输速率必须相同，但是数据链路层协议可以不同</li>
</ul>
</li>
</ul>
<h4 id="2-集线器（Hub）"><a href="#2-集线器（Hub）" class="headerlink" title="2.集线器（Hub）"></a>2.集线器（Hub）</h4><ul>
<li>实质是一个多端口的中继器，组成共享式网络，但是在逻辑上仍然是一个总线型网络<br>集线器的一个端口收到数据之后，从除输入端口以外的所有端口广播出去</li>
<li>集线器的每个端口连接的网络部分是同一个网络的不同网段，只能在半双工状态工作，网络的吞吐率受到限制</li>
<li>多台计算机必然会发生同时通信的情形，集线器不能分割冲突域，<strong>所有集线器的端口都属于同一个冲突域</strong></li>
<li>集线器在一个时钟周期中只能传输一组信息，如果一台集线器连接的机器数目较多，且多台机器经常需要同时通信，那么将导致信息碰撞，使得集线器的工作效率很差。<ul>
<li>一个带宽为10Mb/s的集线器上连接了8台计算机，当这8台计算机同时工作时，每台计算机真正所拥有的带宽为10/8Mb/s=1.25Mb/s。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第一章-计算机网络体系结构</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="计算机网络第一章-计算机网络体系结构"><a href="#计算机网络第一章-计算机网络体系结构" class="headerlink" title="计算机网络第一章 计算机网络体系结构"></a>计算机网络第一章 计算机网络体系结构</h2><blockquote>
<p>计算机学科基础：计算机网络第一章计算机网络体系结构的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="一-计算机网络概述（✠）"><a href="#一-计算机网络概述（✠）" class="headerlink" title="一.计算机网络概述（✠）"></a>一.计算机网络概述（✠）</h3><h4 id="1-计算机网络的概念"><a href="#1-计算机网络的概念" class="headerlink" title="1.计算机网络的概念"></a>1.计算机网络的概念</h4><ul>
<li>计算机网络就是一些互连的、自治的计算机系统的集合。</li>
</ul>
<h4 id="2-计算机网络的组成"><a href="#2-计算机网络的组成" class="headerlink" title="2.计算机网络的组成"></a>2.计算机网络的组成</h4><ul>
<li>组成部分来看：由硬件、软件、协议三大部分组成</li>
<li>工作方式来看：由边缘部分与核心部分组成</li>
<li>功能组成上看：由通信子网和资源子网组成<ul>
<li>通信子网由各种<strong>传输介质、通信设备和相应的网络协议组成</strong>，它使网络具有数据传输、交换、控制和存储的能力，<br>实现联网计算机之间的数据通信。</li>
<li>资源子网是<strong>实现资源共享功能的设备及其软件</strong>的集合，<br>向网络用户提供共享其他计算机上的<u>硬件资源、软件资源和数据资源</u>的服务。</li>
</ul>
</li>
</ul>
<h4 id="3-计算机网络的功能"><a href="#3-计算机网络的功能" class="headerlink" title="3.计算机网络的功能"></a>3.计算机网络的功能</h4><ul>
<li>数据通信：作为最基本功能</li>
<li>资源共享</li>
<li>分布式处理（提高效率）</li>
<li>提高可靠性</li>
<li>负载均衡</li>
</ul>
<h4 id="4-计算机网络的分类"><a href="#4-计算机网络的分类" class="headerlink" title="4.计算机网络的分类"></a>4.计算机网络的分类</h4><ul>
<li><p>按网络的覆盖范围</p>
<ul>
<li><p>广域网（WAN）：几十千米到几千千米（因特网的核心部分），<strong>广域网使用交换技术</strong></p>
</li>
<li><p>城域网（MAN）：5到50km</p>
</li>
<li><p>局域网（LAN） ：1km以内，<strong>局域网使用广播技术</strong></p>
</li>
<li><p>个人网（PAN）：10m</p>
</li>
</ul>
</li>
<li><p>按传输技术分类：</p>
<ul>
<li><strong>广播式网络：局域网、无线、卫星通信网络</strong><br>所有联网计算机都共享一个信道</li>
<li><strong>点对点网络：广域网</strong><br>通过分组存储转发和路由机制交换数据</li>
</ul>
</li>
<li><p>按拓扑结构分类（取决于通信子网）</p>
<ul>
<li>总线型网络</li>
<li>星型网络</li>
<li>环形网络：令牌环局域网</li>
<li>网状网络：广域网</li>
</ul>
</li>
<li>按使用者分类：公有网、私有网</li>
<li>按交换技术分类：电路交换网络、报文交换网络(存储-转发网络)、分组交换网络(包交换网络)</li>
</ul>
<h4 id="5-计算机网络的性能指标（✪）"><a href="#5-计算机网络的性能指标（✪）" class="headerlink" title="5.计算机网络的性能指标（✪）"></a>5.计算机网络的性能指标（✪）</h4><h5 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h5><ul>
<li>单位（bit/s或bps）</li>
<li>需要注意相关的换算！<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS1h2i8.png" alt="pS1h2i8.png"></li>
</ul>
</li>
</ul>
<h5 id="2-带宽（最高数据率）"><a href="#2-带宽（最高数据率）" class="headerlink" title="2.带宽（最高数据率）"></a>2.带宽（最高数据率）</h5><ul>
<li>单位为bit/s，带宽指的是最高的数据率,表示网络的通信线路所能传送数据的能力</li>
<li>在描述通信线路中的传输速率时，一般速率遵守木桶效应：<br>数据传送的速率取主机的接口速率、线路带宽、交换机和路由器的接口速率中的最小者</li>
</ul>
<h5 id="3-吞吐量（实际的数据率）"><a href="#3-吞吐量（实际的数据率）" class="headerlink" title="3.吞吐量（实际的数据率）"></a>3.吞吐量（实际的数据率）</h5><ul>
<li>是指在单位时间之内通过某个网络或接口的实际数据量</li>
<li>吞吐量受网络带宽的限制</li>
</ul>
<h5 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h5><ul>
<li>网络中的时延由发送时延、传播时延、排队时延、以及处理时延构成<ul>
<li>图片<img src="https://s1.ax1x.com/2023/02/05/pS6JVit.jpg" alt="pS6JVit.jpg"></li>
</ul>
</li>
<li>发送时延（也称传输时延✪）<ul>
<li>指的是主机或路由器发送分组所耗费的时间，发送分组的第一个比特开始，到该分组最后一个比特发送完毕为止所耗费的时间</li>
<li>发送时延=分组长度/发送速率</li>
<li>在最后一个比特发送出去之后，此时之前已发送的比特正在陆续传播达到接收方，<br>而最后一个比特还需要经过一个传播时延的时间才能到达接收方。</li>
<li>发送一个分组时，往往在最后一个比特完全传出之后，前面传出的比特经过链路上的传输刚刚到达发送方。</li>
</ul>
</li>
<li>传播时延<ul>
<li>电磁波在链路（传播介质）上传播一定的距离所耗费的时间</li>
<li>传播时延=链路长度/电磁波在链路上传播的距离<ul>
<li>电磁波在自由空间上：$3*10^8 m/s$</li>
<li>在铜线和电缆中：$2.3*10^8 m/s$</li>
<li>在光纤中：$2*10^8 m/s$</li>
</ul>
</li>
</ul>
</li>
<li>排队时延<ul>
<li>分组进入路由器后，在路由器的输入队列中排队缓存并等待处理。<br>在路由器确定了分组的转发接口后，分组会在输出队列中排队缓存并等待转发。在排队缓存中所耗费的时间就是排队时延。</li>
<li>如果通信量过大，会使路由器的队列溢出</li>
</ul>
</li>
<li>处理时延<ul>
<li>一般是检查是否误码、提取首部目的地址、查找相应的转发接口等操作。</li>
</ul>
</li>
</ul>
<h5 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h5><ul>
<li>时延带宽积是传播时延和带宽的乘积，也称以比特为单位的链路长度，表示一段链路可以容纳的比特数量<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS1IuPf.png" alt="pS1IuPf.png"></li>
</ul>
</li>
</ul>
<h5 id="6-往返时间（RTT）"><a href="#6-往返时间（RTT）" class="headerlink" title="6.往返时间（RTT）"></a>6.往返时间（RTT）</h5><ul>
<li>往返时间是指从发送端发送数据分组开始，到发送端收到接收端发来的相应确认分组为止，总共耗费的时间。</li>
</ul>
<h5 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h5><ul>
<li>链路利用率（有百分之几的时间是被利用的）和网络利用率（所有链路的链路利用率的加权平均）</li>
<li>当某链路的利用率增加时，该链路引起的时延就会迅速增加</li>
<li>用以下的公式来表示：$D= \frac{D_0}{1-U}$   (D:网络当前的时延、$D_0$:网络空闲时的时延、U:网络利用率)<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS1oU0A.png" alt="pS1oU0A.png"></li>
</ul>
</li>
</ul>
<h5 id="8-丢包率"><a href="#8-丢包率" class="headerlink" title="8.丢包率"></a>8.丢包率</h5><ul>
<li>丢包率是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比例</li>
<li>在传输过程中出现误码或由于网络拥塞等造成的分组交换机根据丢弃策略主动丢弃。</li>
</ul>
<h4 id="6-因特网历史"><a href="#6-因特网历史" class="headerlink" title="6.因特网历史"></a>6.因特网历史</h4><ul>
<li><p>由单个阿帕网向互联网发展、逐步建成三级结构的互联网、逐步建成多层次ISP的因特网</p>
<ul>
<li><p>1969年，美国建立了第一个分组交换网：ARPANET</p>
</li>
<li><p>1983年，TCP/IP协议族成为ARPANET的标准协议（因特网的诞生时间）</p>
</li>
<li><p>1985年，美国建成了由主干网、地区网、校园网三级结构所构成的国家科学基金网（NSFNET）</p>
</li>
<li><p>1993年，因特网转变为由互联网服务提供者（Internet Service Provider）ISP来运营</p>
</li>
<li><p>1994年，万维网（WWW）技术在因特网上被广泛运用</p>
</li>
</ul>
</li>
<li><p>因特网已发展成基于ISP的多层次结构的互联网络</p>
<ul>
<li>第一层ISP：国际级</li>
<li>第二层ISP：区域级或国家级</li>
<li>第三层ISP：本地级</li>
</ul>
</li>
</ul>
<h4 id="7-因特网的标准化工作和管理机构"><a href="#7-因特网的标准化工作和管理机构" class="headerlink" title="7.因特网的标准化工作和管理机构"></a>7.因特网的标准化工作和管理机构</h4><ul>
<li>因特网的标准化工作的流程<ul>
<li>在成为互联网标准之前需要在网络上发布：RFC文档（Request for comments）</li>
<li>经过以下阶段才能变成因特网标准：因特网草案、建议标准（成为RFC文档）、因特网标准</li>
</ul>
</li>
<li>因特网的管理机构：因特网协会（ISOC）<ul>
<li>下设因特网体系结构委员会（IAB）并有两个子部门<ul>
<li>互联网工程部（IETF）</li>
<li>互联网研究部（IRTF）</li>
</ul>
</li>
</ul>
</li>
<li>专门制定计算机网络标准的组织：IEEE（Institute of Electrical and Electronics Engineers），电气与电子工程协会。</li>
</ul>
<h3 id="二-计算机网络的体系结构（✪）"><a href="#二-计算机网络的体系结构（✪）" class="headerlink" title="二.计算机网络的体系结构（✪）"></a>二.计算机网络的体系结构（✪）</h3><h4 id="1-常见的三种计算机网络的体系结构（✪）"><a href="#1-常见的三种计算机网络的体系结构（✪）" class="headerlink" title="1.常见的三种计算机网络的体系结构（✪）"></a>1.常见的三种计算机网络的体系结构（✪）</h4><ul>
<li><p>开放系统互联参考模型（OSI✪）</p>
<ul>
<li><p>由国际标准化组织（ISO）制订，分为7层</p>
</li>
<li><p>高三层统称为资源子网，相当于计算机系统，完成数据的处理等功能</p>
</li>
<li><p>低三层统称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能</p>
</li>
<li><p>物理层</p>
<ul>
<li>物理层的传输单位是比特，功能是在物理媒体上为数据端设备透明地传输原始比特流。</li>
<li>物理层主要定义数据终端设备(DTE)和数据通信设备(DCE)的物理与逻辑连接方法<br>所以物理层协议也称物理层接口标准，物理层协议也称物理层规程。</li>
<li>传输信息所用的物理媒体（双绞线、光缆、无线信道等），不属于物理层协议</li>
</ul>
</li>
<li><p>数据链路层</p>
<ul>
<li>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。</li>
<li>数据链路层的功能可以概括为<strong>物理寻址、封装成帧、差错控制、流量控制和传输管理等</strong>。<br>保证数据正确的顺序和完整性</li>
<li>广播式网络在数据链路层还要处理新的问题，即如何控制对共享信道的访问<br>数据链路层的一个特殊的子层一一介质访问子层，就是专门处理这个问题的</li>
<li><strong>数据链路层提供的是点到点的通信</strong>（主机到主机之间的通信）</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li><p>网络层的传输单位是IP数据报（分组），它关心的是通信子网的运行控制，</p>
<p>主要任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p>
</li>
<li><p>关键问题是对分组进行<strong>路由选择</strong>，并实现<strong>差错控制、流量控制、拥塞控制和网际互连</strong>等功能。</p>
</li>
<li><p>因特网是一个很大的互联网，它由大量异构网络通过路由器(Router)相互连接起来。</p>
<ul>
<li>因特网的主要网络层协议是无连接的网际协议(IP)和许多路由选择协议<br>因此因特网的网络层也称网际层或IP层。</li>
</ul>
</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li>传输层也称运输层，传输单位是报文段(TCP)或用户数据报(UDP)</li>
<li>传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，<br>为端到端连接提供<strong>差错控制、流量控制、拥塞控制、服务质量、数据传输管理</strong>等服务。</li>
<li><strong>传输层提供的是端到端的通信</strong>（运行在不同主机的两个进程之间的通信）</li>
</ul>
</li>
<li><p>会话层：会话管理，也称为建立同步（SYN）</p>
<ul>
<li>这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步(SYN)。</li>
<li>会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步</li>
</ul>
</li>
<li><p>表示层：数据格式转换</p>
</li>
<li><p>应用层：提供用户和网络的接口。应用层为特定类型的网络应用提供访问OSI参考模型环境的手段</p>
</li>
</ul>
</li>
<li><p>TCP/IP参考模型（✪）</p>
<ul>
<li>分为四层：网络接口层、网际层（主机之间）、传输层（进程之间）、应用层（用户之间）</li>
<li>网络接口层：从主机或结点接收IP分组，并把它们发送到指定的物理网络上</li>
<li>网际协议IP是TCP/IP体系结构（因特网）中的核心协议<ul>
<li>进行路由选择，提供无连接不可靠的数据报服务</li>
<li>IP协议作为 TCP/IP体系结构中的核心协议, 一方面负责互连不同的网络接口, 也就是IP over everything；<br>另一方面为各种网络应用提供服务, 也就是Everything over IP。</li>
<li>TCP/IP 协议族图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS17QxO.png" alt="pS17QxO.png"></li>
</ul>
</li>
</ul>
</li>
<li>传输层：使发送端和目的端主机上的对等实体进行会话<ul>
<li>实现端到端通信，处理关于可靠性、流量控制和错误矫正等问题</li>
<li>传输控制协议(TCP)。它是面向连接的，<br>数据传输的单位是<strong>报文段，能够提供可靠的交付</strong>。</li>
<li>用户数据报协议(UDP)。它是无连接的，<br>数据传输的单位是<strong>用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”</strong>。</li>
</ul>
</li>
<li>应用层：包含所有的高层协议，如虚拟终端协议(Telnet)、文件传输协议(FTP)、<br>域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。</li>
</ul>
</li>
<li><p>原理参考模型：五层，物理层、数据链路层、网络层、传输层、应用层（学习时采用的模型）</p>
</li>
<li><p>OSI参考模型与TCP/IP模型的区别（✪）</p>
<ul>
<li>OSI参考模型在网络层支持无连接和面向连接的通信<br>但在传输层仅有面向连接的通信。</li>
<li>而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式<br>但传输层支持无连接和面向连接两种模式</li>
</ul>
</li>
</ul>
<h4 id="2-数据传输的过程"><a href="#2-数据传输的过程" class="headerlink" title="2.数据传输的过程"></a>2.数据传输的过程</h4><ul>
<li><p>主机发送报文（自顶向下逐层封装）：</p>
<ul>
<li>1.应用层: 根据HTTP协议的规定, 构建一个HTTP请求报文, 用来请求Web服务器执行相应的操作。<br>应用层将构建好的HTTP请求报文向下交付给运输层。</li>
<li>2.运输层: 给HTTD请求报文添加一个TCP首部， 将其封装成TCP报文段，TCP首部的主要作用是区分应用进程和实现可靠转输，运输层将封装好的TCP报文段向下交付给网络层。</li>
<li>3.网络层: 为TCP报文段添加一个IP首部, 将其封装成IP数据报。<br>IP首部的主要作用是IP寻址和路由。网络层将封装好的IP数据报向下交付给数据链路层。</li>
<li>4.数据链路层: 为IP数据报添加一个首部和一个尾部，将其封装成帧。帧首部和尾部的主要作用是MAC寻址和帧校验。<br>数据链路层将封装好的帧可下交付给物理层。</li>
<li>5.物理层: 并不认识帧的结构, 仅仅将其看作比特流, 以便将比特流转换成相应的电信号进行发送。<br>对于以太网, 物理层还会在比特流前添加前导码, 目的是使接收方的时钟同步, 并做好接收准备。<ul>
<li>注：物理层并不参与数据封装工作。</li>
</ul>
</li>
</ul>
</li>
<li><p>路由器处理报文（自低向下逐层解封）：</p>
<ul>
<li>1.接收口的物理层：将收到的电信号装换成比特流，并去掉前导码，然后将帧向上交给数据链路层。</li>
<li>2.接收口的数据链路层: 去掉帧的首部和尾部后, 将IP数据报向上交付给网络层。</li>
<li>3.网络层: 网络层从IP数据报的首部中提取出目的IP地址，根据目的IP地址查找自己的转发表，以便决定从哪个接口转发该IP数据<br>报。与此同时，还要对首部中的某些字段值（例如生存时间TTL字段的值）进行相应的修改，然后将该IP数据报向下交付给数据链路层。</li>
<li>4.转发口的数据链路层: 为IP数据报添加一个首部和一个尾部, 将其封装成帧，然后将帧向下交付给物理层。</li>
<li>5.转发口的物理层: 将帧看作比特流, 给其添加前导码后转变成相应的电信号发送出去。</li>
</ul>
</li>
<li><p>流程图</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS1Hbng.png" alt="pS1Hbng.png"></li>
</ul>
</li>
</ul>
<h4 id="3-分层体系结构中的相关术语"><a href="#3-分层体系结构中的相关术语" class="headerlink" title="3.分层体系结构中的相关术语"></a>3.分层体系结构中的相关术语</h4><ul>
<li><p>计算机网络的各层及其协议的集合被称为体系结构</p>
<ul>
<li>分层描述了每层必须完成的功能，但是没有定义功能执行的方法<br>分层不涉及协议的内部实现细节    </li>
</ul>
</li>
<li><p>实体</p>
<ul>
<li>实体是指任何可发送或接收信息的硬件或软件进程</li>
<li>不同机器上的同一层称为对等层</li>
<li>同一层的实体称为对等实体</li>
</ul>
</li>
<li>PDU(协议数据单元)，由SDU、PCI组成<ul>
<li>服务数据单元（SDU）：层与层之间交换的数据单元称为服务数据单元</li>
<li>服务控制信息（PCI）：控制协议操作的信息</li>
<li>协议数据单元（PDU）：对等层之间传送的数据单元称为该层的协议数据单元</li>
</ul>
</li>
</ul>
<h4 id="4-协议、接口、服务（OSI参考模型的三个主要概念✪）"><a href="#4-协议、接口、服务（OSI参考模型的三个主要概念✪）" class="headerlink" title="4.协议、接口、服务（OSI参考模型的三个主要概念✪）"></a>4.协议、接口、服务（OSI参考模型的三个主要概念✪）</h4><ul>
<li><p>协议（✪）</p>
<ul>
<li><p><strong>协议是控制两个对等实体在”水平方向”进行”逻辑通信”的规则的集合</strong></p>
<ul>
<li>物理层对等实体使用物理层协议进行逻辑通信, 例如传统以太网使用曼彻斯特编码。</li>
<li>数据链路层对等实体使用数据链路层协议进行逻辑通信, 例如传统以太网使用 CSMA/CD协议。</li>
<li>网络层对等实体使用网络层协议进行逻辑通信, 例如IP协议。</li>
<li>运输层对等实体使用运输层协议进行逻辑通信, 例如TCP协议或UDP协议。</li>
<li>应用层对等实体使用应用层协议进行逻辑通信, 例如HTTP协议、FTP协议以及SMTP协议等。</li>
</ul>
</li>
<li><p><strong>协议三要素：语法、语义、同步</strong></p>
<ul>
<li>语法：语法用来定义数据与控制信息的结构与格式，以及数据出现的顺序<ul>
<li>比如说IP数据报文，其中的每一个小格子被称为字段或域。</li>
</ul>
</li>
<li>语义：语义解释控制信息每个部分的意义，规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应</li>
<li>同步：用来定义通信双方的时序关系，对事件发生的顺序进行详细说明<ul>
<li>例：此时为三次握手，展现先后关系<ul>
<li><img src="https://s1.ax1x.com/2023/01/19/pS8dFDe.png" alt="pS8dFDe.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接口与服务访问点（SAP）</p>
<ul>
<li>接口是同一结点内相邻两层间交换信息的连接点</li>
<li>同一结点相邻两层的实体通过服务访问点（SAP）进行交互</li>
<li>各层的SAP<ul>
<li>物理层：网卡接口</li>
<li>数据链路层：MAC地址（网卡地址）或帧的类型字段</li>
<li>网络层：IP地址（网络地址）或IP数据报首部的协议字段</li>
<li>传输层：端口号</li>
<li>应用层：用户界面</li>
</ul>
</li>
</ul>
</li>
<li><p>服务（✪）</p>
<ul>
<li>服务的基本概念<ul>
<li><strong>在协议的控制下，两个对等实体在水平方向上的逻辑通信使得本层能够向上一层提供服务。</strong></li>
<li>要实现本层协议，还需要使用下面一层所提供的服务，其下面的一层称为服务提供者</li>
<li>协议是水平的，而服务是垂直的。</li>
<li>实体看得见下层提供的服务，但并不知道实现该服务的具体协议。下层的协议对上层的实体是透明的。<ul>
<li>网络层享受链路层提供的服务，并给传输层提供服务。</li>
</ul>
</li>
</ul>
</li>
<li>服务原语：<strong>上层要使用下层所提供的服务，必须通过与下层交换一些命令，这些命令称为服务原语。</strong><ul>
<li>分为请求、指示、响应、证实四类</li>
</ul>
</li>
<li>服务的分类<ul>
<li>面向连接服务与无连接服务<ul>
<li>面向连接服务（分为连接建立、数据传输和连接释放三个阶段）<ul>
<li>通信前双方必须先建立连接，分配相应的资源（如缓冲区），以保证通信能正常进行</li>
<li>传输结束后释放连接和所占用的资源。</li>
<li>TCP就是一种面向连接服务的协议</li>
</ul>
</li>
<li>无连接服务（尽最大努力交付）<ul>
<li>通信双方不需要先建立连接，直接发送数据即可，是一种不可靠的服务</li>
<li>IP，UDP为无连接服务</li>
</ul>
</li>
</ul>
</li>
<li>可靠服务与不可靠服务<ul>
<li>可靠服务是指网络具有纠错、检错、应答机制，能保证数据正确、可靠地传送到目的地。</li>
<li>不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的<br>地，是一种尽力而为的服务。</li>
</ul>
</li>
<li>有应答服务与无应答服务<ul>
<li>应答由传输系统内部自动实现，如文件传输服务</li>
<li>无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现<br>如www服务</li>
</ul>
</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/01/17/pS3A6vF.png" alt="pS3A6vF.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第八章-排序</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="数据结构第八章-排序"><a href="#数据结构第八章-排序" class="headerlink" title="数据结构第八章 排序"></a>数据结构第八章 排序</h2><blockquote>
<p>计算机学科基础：数据结构第八章排序的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1.排序的基本概念"></a>1.排序的基本概念</h3><ul>
<li>评价指标<ul>
<li>稳定性：关键字相同的元素经过排序后<strong>相对顺序</strong>是否会改变</li>
<li>时间复杂度、空间复杂度</li>
</ul>
</li>
<li>分类<ul>
<li>内部排序：数据都存放在内存中<ul>
<li>一般内部排序算法在执行过程中都需要进行比较和移动两种操作（但是基数排序不基于比较）</li>
</ul>
</li>
<li>外部排序：数据无法全部同时存放在内存中</li>
</ul>
</li>
</ul>
<h3 id="2-插入排序（✪）"><a href="#2-插入排序（✪）" class="headerlink" title="2.插入排序（✪）"></a>2.插入排序（✪）</h3><ul>
<li><p>直接插入排序</p>
<ul>
<li><p>算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>
</li>
<li><p>流程</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjN6gJ.png" alt="pCjN6gJ.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) <span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;  <span class="comment">//每次都比较该位置的前驱，看是否小于前驱</span></span><br><span class="line">            temp=A[i];  <span class="comment">// temp暂存</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;A[j]&gt;temp;--j)<span class="comment">//检查前面排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j]; <span class="comment">//所有大于temp的元素都向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接插入排序的性能分析</p>
<ul>
<li>空间效率：空间复杂度为O(1)</li>
<li>时间复杂度：主要来自对比关键字、移动元素，若有n个元素，则需要n-1趟处理<ul>
<li>最好时间复杂度为O(n)（全部顺序）<ul>
<li>最好的情况下做 n-1次关键字的比较，也就是执行n-1趟，每趟只比较一次，此时不需要移动元素</li>
</ul>
</li>
<li>最坏/平均时间复杂度为O($n^{2}$) (全部逆序)<ul>
<li>直接插入排序在最坏的情况下做 n(n-1)/2次关键字的比较，此时移动次数也达到最大</li>
</ul>
</li>
</ul>
</li>
<li>稳定性：为稳定的排序算法</li>
<li>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>折半插入排序</p>
<ul>
<li><p>算法思想：先用折半查找找到应该插入的位置，再移动元素</p>
<ul>
<li><p>当low&gt;high时折半查找停止，应将[Iow,i-1]内的元素全部右移，并将A[0]复制到Iow所指位置</p>
</li>
<li><p>当A[mid]==A[0]时，为了保证算法的“稳定性”，应继续在mid所指位置右边寻找插入位置</p>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>如此时向前插入8位置的55，需要在1-7个位置之间进行折半查找<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCOdDEV.png" alt="pCOdDEV.png"></li>
</ul>
</li>
<li>此时通过折半查找，找到其应该插入的位置为5，则将6-7的元素统一后移一位，并在5位置插入55<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCOdc34.png" alt="pCOdc34.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Void <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>,i&lt;=n;i++)&#123; 	<span class="comment">//依次将A[2]到A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i]; 	<span class="comment">//A[0]作为暂存位</span></span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>; 	<span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;	<span class="comment">//折半查找</span></span><br><span class="line">            mid=(low+high)/<span class="number">2</span>; <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>; <span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span> <span class="comment">//查找右半子表</span></span><br><span class="line">            	<span class="comment">//注意：一直到Iow&gt;high时才停止折半查找。当mid所指元素等于当前元素时，</span></span><br><span class="line">				<span class="comment">//应继续令Iow=mid+1,以保证“稳定性”。最终应将当前元素插入到Iow所指位置(即high+1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;i&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];	<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];    	<span class="comment">//插入操作</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>折半插入排序的性能分析</p>
<ul>
<li>折半插入排序的比较次数与原始状态无关，仅取决于n</li>
<li><p>折半插入排序仅减少了比较元素的次数，约为O($nlog_{2}{n}$)</p>
</li>
<li><p>折半插入排序没有改变元素的移动次数，时间复杂度仍然是O($n^{2}$)，依赖于原始状态</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>希尔排序（缩小增量排序）</p>
<ul>
<li><p>算法思想：先追求表中元素部分有序，再逐渐逼近全局有序</p>
<ul>
<li>设置增量为d的子表，把相隔某个增量的记录组成一个子表，对各个子表分别进行直接插入排序。<br>之后进行增量的缩小再进行一次这样的排序，当整个表中的呈现基本有序时，再对全体记录进行一次直接插入排序</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO0aT0.png" alt="pCO0aT0.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>第一趟排序之后<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO0rpF.png" alt="pCO0rpF.png"></li>
</ul>
</li>
<li>第二趟排序之后<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO07Xd.png" alt="pCO07Xd.png"></li>
</ul>
</li>
<li>第三趟排序之后<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO0jtf.png" alt="pCO0jtf.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>) <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123; <span class="comment">//若前序较大，需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];	<span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j]; <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>]		<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>希尔排序的性能分析</p>
<ul>
<li>空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)</li>
<li>时间效率：当n在某个特定范围时，希尔排序的时间复杂度约为O($n^{1.3}$)，在最坏情况下希尔排序的时间复杂度为O($n^{2}$)</li>
<li>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，希尔排序是一种不稳定的排序方法。</li>
<li>适用性：希尔排序算法<strong>仅适用于线性表为顺序存储的情况</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-交换排序（✪）"><a href="#3-交换排序（✪）" class="headerlink" title="3.交换排序（✪）"></a>3.交换排序（✪）</h3><ul>
<li><p>冒泡排序</p>
<ul>
<li>算法思想：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置<ul>
<li>从后往前（或从前往后）两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换它们，直到序列比较完。<br>称这样过程为“一趟”冒泡排序。</li>
<li>下一趟冒泡时，前一趟确定的最小元素不再参与比较，<br>每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置</li>
<li>最多做n-1趟冒泡就能把所有元素排好序。</li>
</ul>
</li>
<li>流程<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjBBU1.png" alt="pCjBBU1.png"></li>
</ul>
</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/24/pCO6peH.png" alt="pCO6peH.png"></li>
</ul>
</li>
<li>冒泡排序的性能分析<ul>
<li>空间复杂度：仅使用了常数个辅助单元，因而空间复杂度为O(1).</li>
<li>时间复杂度<ul>
<li>当初始序列有序时，显然第一趟冒泡后flag依然为false（本趟没有元素交换）从而直接跳出循环，<br>比较次数为n-1，移动次数为0，从而最好情况下的时间复杂度为O($n$)</li>
<li>当初始序列为逆序时，需要进行n-1趟排序，第i趟排序要进行n-i次关键字的比较，<br>而且每次比较后都必须移动元素3次来交换元素位置，此时<ul>
<li>比较次数：$\frac{n(n-1)}{2}$，移动次数：$\frac{3n(n-1)}{2}$</li>
<li>最坏情况下的时间复杂度O($n^{2}$)</li>
</ul>
</li>
<li>平均时间复杂度为O($n^{2}$)</li>
</ul>
</li>
<li>稳定性：冒泡排序是一种稳定的排序方法</li>
<li>适用于顺序表和链表</li>
<li>快速排序一趟会确定一个元素最终的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li><p>算法思想：分治法</p>
<ul>
<li>在待排序表L[1..n]中任取一个元素pivot作为枢轴(或基准，<strong>通常取首元素</strong>)</li>
<li>通过一趟排序将待排序表划分为独立的两部分L[1……k-1]和L[k+1……n]，使得L[1……k-1]中的所有元素小于pivot，<br>L[k+1……n]中的所有元素大于等于pivot，则<strong>pivot放在了其最终位置L(k)上，这个过程称为一次“划分”</strong>。</li>
<li>然后分别<strong>递归地对两个子表重复上述过程</strong>，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</li>
</ul>
</li>
<li><p>代码实现（掌握）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序（表长为n，初始的low为表头0，high为表尾n-1）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">()</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;	<span class="comment">//当low=high时，此时递归跳出</span></span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low,high); <span class="comment">//进行一次分治划分</span></span><br><span class="line">        QuickSort(A,low,pivotpos<span class="number">-1</span>);	<span class="comment">//划分左子表(上一次划分后返回的之前枢纽存放的最终位置的左边一位在划分左子表时作为&quot;high&quot;，low为当前递归工作栈的存放位置)</span></span><br><span class="line">        QuickSort(A,Pivotpos+<span class="number">1</span>,high);   <span class="comment">//划分右子表(上一层划分后返回的之前枢纽存放的最终位置的右边一位在划分右子表时作为&quot;low&quot;,high为当前递归工作栈的存放位置)</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];   <span class="comment">//将当前表中的low作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;	<span class="comment">//当low=high时，说明此轮的枢纽已经搜索到了最终的位置，跳出此轮枢纽的循环</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)  <span class="comment">//从后往前找到比枢纽更小的元素，将其移动到左边</span></span><br><span class="line">            --high;</span><br><span class="line">        A[low]=A[high];   <span class="comment">//在high位置上比枢纽小的元素移动到当前low的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)   <span class="comment">//从前往后找到比当前枢纽更大的元素，将其移动到右边</span></span><br><span class="line">            ++low;</span><br><span class="line">        A[high]=A[low];	  <span class="comment">//在low位置上比枢纽更大的元素移动到当前的high位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;     <span class="comment">//进行一次分治算法后，枢纽存放的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;       <span class="comment">//返回枢纽存放的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流程</p>
<ul>
<li>第一轮分治法时，递归工作栈中的low为0，high为7，此时将49作为枢纽，将high指针左移，找到比枢纽小的元素移动到low指针处，<br>之后又将low指针右移，找到比枢纽大的元素移动到high指针处。</li>
<li>互相进行以上操作，直到low=high时，此时就找到了枢纽元素的最终位置。并返回当前的枢纽指针位置，进行左子表的新一轮递归操作。<ul>
<li>初始情况<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCO5Bh4.png" alt="pCO5Bh4.png"></li>
</ul>
</li>
<li>第一趟递归操作<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjsLrD.png" alt="pCjsLrD.png"></li>
</ul>
</li>
</ul>
</li>
<li>第二轮分治法时，递归工作栈中的low为0，high为之前的枢纽位置3减1为2，此时选择27为枢纽进行操作<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCO5XE8.png" alt="pCO5XE8.png"></li>
</ul>
</li>
<li>到了处理右子表时，递归的工作栈中low为之前的枢纽3加1为4，high为7，此时选择76为枢纽进行操作<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOIm8J.png" alt="pCOIm8J.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>快速排序的性能分析</p>
<ul>
<li>算法表现主要取决于递归深度若每次“划分”越均匀，则递归深度越低。“划分”越不均匀，递归深度越深</li>
<li>空间复杂度：最好空间复杂度：O($log_{2}n$)，最坏空间复杂度：O($n$)</li>
<li><p>时间复杂度：</p>
<ul>
<li>最好时间复杂度：O($nlog_{2}n$)，每次选的枢轴元素都能将序列划分成均匀的两部分</li>
<li>最坏时间复杂度：O($n^{2}$​)，若序列原本就有序或逆序，则时空复杂度最高，可优化，尽量选择<br>可以把数据中分的枢轴元素。</li>
</ul>
</li>
<li><p>快速排序是所有内部排序算法中平均性能最优的算法</p>
</li>
<li>快速排序是一种不稳定的排序</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li>判断快速排序时速度最快和最慢的情况<ul>
<li>此时需要判断以枢纽为中心的两边所划分的元素个数是否平均，<br>小于枢纽的元素的个数和大于枢纽的元素的个数的比例越不平均，所耗时越多</li>
<li>速度最慢显然是D选项，均为有序排序时，速度最快时看大于和小于枢纽的数的比例，<br>A，C选项的比例1:1；B选项为5:1，<br>再从AC选项里面选择进行一趟快速排序（A：9,5,7,21,25,23,30；B:5,9,17,21,25,23,30）<br>此时A的左右子表都满足与新枢纽的比例为1:1，但是B的左右子表关于新枢纽的比例均为2:0，选A<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOHtTP.png" alt="pCOHtTP.png"></li>
</ul>
</li>
</ul>
</li>
<li>判断不可能是快速排序第2趟排序的结果的序列，利用快速排序一趟会确定一个元素最终的位置，<br>此时写出有序序列与选项作比较，此时只需要选项中有两个在相应位置上契合的元素即可<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOOeje.png" alt="pCOOeje.png"></li>
</ul>
</li>
<li>除了需要满足上面的条件，还需要满足此时有一个符合的元素位于边界<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCOOo8K.png" alt="pCOOo8K.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-选择排序（✪）"><a href="#4-选择排序（✪）" class="headerlink" title="4.选择排序（✪）"></a>4.选择排序（✪）</h3><ul>
<li><p>简单选择排序</p>
<ul>
<li><p>算法思想：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列<br>每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;		<span class="comment">//一共进行n-1趟	</span></span><br><span class="line">        <span class="type">int</span> min=i;     <span class="comment">//记录最小元素的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;  <span class="comment">//在A[i……n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])		<span class="comment">//如果存在更小的元素，则更新最小元素的位置</span></span><br><span class="line">                min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)</span><br><span class="line">            swap(A[i],A[min]);   <span class="comment">//交换位置，此时该趟中最小的元素到了i位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单选择排序性能分析</p>
<ul>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：O($n^{2}$)</li>
<li>无论有序、逆序、还是乱序，一定需要n-1趟处理</li>
<li>元素间比较的次数与序列的初始状态无关，始终是$n(n-1)/2$次，因此时间复杂度始终是O($n^{2}$)</li>
<li>简单选择排序是一种不稳定的排序算法</li>
<li>适用于顺序表和链表</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序</p>
<ul>
<li><p>堆（堆是用来排序的，他的查找效率很低）</p>
<ul>
<li><strong>从二叉树的任意结点出发到根的路径上所经过的所有结点序列按其关键字有序，则此二叉树是根</strong></li>
<li><p>大根堆与小根堆</p>
<ul>
<li><p>若${n}$个关键字序列${L[1 \ldots n]}$满足下面某一条性质, 则称为堆（Heap）</p>
<ul>
<li>若满足:${\mathrm{L}(\mathrm{i}) \geqslant \mathrm{L}(2 \mathrm{i})}$且${\mathrm{L}(\mathrm{i}) \geqslant \mathrm{L}(2 \mathrm{i}+1) (1 \leq i \leq n / 2)—}$大根堆（大顶堆）    </li>
<li>若满足:${\mathrm{L}(\mathrm{i}) \leqslant \mathrm{L}(2 \mathrm{i})}$且${\mathrm{L}(\mathrm{i}) \leqslant \mathrm{L}(2 \mathrm{i}+1) (1 \leq i \leq n / 2) —}$小根堆（小顶堆）</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCXeqsJ.png" alt="pCXeqsJ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流程</p>
<ul>
<li>建立大根堆<ul>
<li>可以将堆看做是一个完全二叉树，大根堆就是根结点的关键字大于左右孩子结点，<br>此时可以对于一个给定的初始的序列建立大根堆，之后方便进行选择排序</li>
<li>把所有非终端结点都检查一遍，是否满足大根堆的要求，<br>如果不满足，则进行调整，在顺序存储的完全二叉树中, 非终端结点编号  $\mathbf{i} \leq\lfloor n / 2\rfloor$</li>
<li>从编号为$\lfloor n / 2\rfloor$的分支结点开始从后往前检查，检查当前结点是否满足根≥左、右，<br>若不满足，将当前结点与更大的一个孩子互换</li>
<li>之后依次这样处理前面序号的非终端结点，<br>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整(小元素不断“下坠”)</li>
<li>图片（注：初始序列为：（53,17,78,9,45,65,87,32），初始对$\lfloor n / 2\rfloor$位置开始检查，从后往前检查）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjcjZF.png" alt="pCjcjZF.png"></li>
</ul>
</li>
</ul>
</li>
<li>进行堆排序<ul>
<li>在建立大根堆完成之后，每一趟将堆顶关键字与待排序序列中的最后一个元素交换（将堆顶元素加入有序子序列）</li>
<li>并将待排序元素序列再次调整为大根堆(小元素不断“下坠”)</li>
<li>在经过n-1趟之后得到基于“大根堆”的堆排序的“递增序列”</li>
<li>图片<ul>
<li>此时已建立好堆排序，此时将堆顶元素87与最后一个元素9进行互换，87输出到最后位<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX1S74.png" alt="pCX1S74.png"></li>
</ul>
</li>
<li>互换之后，此时9在完全二叉树中破坏了大堆根，此时应该进行调整，使最小的元素坠入底端，9与78互换<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX1ZnO.png" alt="pCX1ZnO.png"></li>
</ul>
</li>
<li>互换之后，还需要使其与下一层更大的65进行互换<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX113t.png" alt="pCX113t.png"></li>
<li>此时互换后，重新形成了一个大根堆，如果继续进行下一趟排序的话，<br>此时已经变成有序序列的第8号元素所在的关键字87不参与排序，此时的len减一为7。78将输出，与7位置上的53互换<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCX18jf.png" alt="pCX18jf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现（了解）</p>
<ul>
<li><p>建立大根堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;	<span class="comment">//从后向前调整所有的非终端结点</span></span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将以K为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k];   <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k;i&lt;len;i*=<span class="number">2</span>)&#123; <span class="comment">//沿关键字较大的根结点的子节点向下筛选，若超出原数组长度，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])	<span class="comment">//此时取关键字更大的其中子节点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])</span><br><span class="line">            <span class="keyword">break</span>;		<span class="comment">//此时根结点的值较大，则停止筛选</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[K]=A[i];  <span class="comment">//将被筛选中的结点调整到双亲结点上</span></span><br><span class="line">            k=i;	<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];    <span class="comment">//筛选完成后，被筛选的节点放入最终的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现根排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>	<span class="comment">//建立大根堆</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span><span class="comment">//将以k为根的子树调整大根堆</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;		<span class="comment">//堆排序的完整逻辑</span></span><br><span class="line">    BuildMaxHeap(A,len);	<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;		<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);	<span class="comment">//堆顶元素和堆底元素进行互换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);	<span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>堆的插入</p>
<ul>
<li>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。<br>新元素就这样一路“上升”，直到无法继续上升为止</li>
<li>删除时，被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止</li>
<li>向具有n个结点的堆中插入一个新元素的时间复杂度为O($log_{2}n$)，删除一个元素的时间复杂度为O($log_{2}n$)</li>
<li>例题<ul>
<li>按照插入的方法，逐个插入即可，此时选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/25/pCXhNlR.png" alt="pCXhNlR.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/25/pCXhU61.png" alt="pCXhU61.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>堆排序的性能分析</p>
<ul>
<li>空间效率: 仅使用了常数个辅助单元, 所以空间复杂度为${O(1)}$</li>
<li>时间效率: 建堆时间为${O(n)}$, 之后有${n-1}$次向下调整操作, 每次调整的时间复杂度为${O(h)}$,<br>故在最好、最坏和平均情况下, 堆排序的时间复杂度为${O\left(n \log _{2} n\right)}$</li>
<li>堆排序是一种不稳定的排序方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-归并排序和基数排序（✪）"><a href="#5-归并排序和基数排序（✪）" class="headerlink" title="5.归并排序和基数排序（✪）"></a>5.归并排序和基数排序（✪）</h3><ul>
<li><p>归并排序（可以作为外部排序）</p>
<ul>
<li><p>算法思想</p>
<ul>
<li>把两个或多个<strong>已经有序</strong>的序列合并成一个新的有序表</li>
<li>m路归并，每选出一个元素需要对比关键字m-1次</li>
<li>将两个各有N个元素的有序表合并成一个有序表，最少的比较次数是N次（一个表中的最小元素大于另一个表的最大元素时），<br>最多的比较次数是2N-1次（两个表中的元素依次间隔地比较时）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjPZh4.png" alt="pCjPZh4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>流程（在内部排序中一般选择二路归并）</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjPucR.png" alt="pCjPucR.png"></li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li>第一趟为2个一组，第二趟为4个一组，每组内部排序即可，选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjeUmj.png" alt="pCjeUmj.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现（了解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//定义辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并算法</span></span><br><span class="line">Void <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">        B[k]=A[k]; 	<span class="comment">//将A中所有元素复制到辅助元素B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j]) <span class="comment">//此时有等于号的原因是使两个元素相等时，优先使用靠前的那一个（稳定性）</span></span><br><span class="line">            A[k]=B[i++];   <span class="comment">//将较小的复制到A的位置，之后前半部分的指针位加一</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[K]=B[j++];	<span class="comment">//将较大的复制到A的位置，之后后半部分的指针位加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) </span><br><span class="line">        A[k++]=B[i++]; <span class="comment">//若第一个辅助表没有检测完，则直接复制到原表的尾部</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=hige)</span><br><span class="line">         A[k++]=B[j++]; <span class="comment">//若第二个辅助表没有检测完，则直接复制到原表的尾部</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归的归并算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>; <span class="comment">//从序列的中间划分出子序列</span></span><br><span class="line">        MergeSort(A,low,mid);	<span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,high);	<span class="comment">//整体归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序的性能分析</p>
<ul>
<li>空间复杂度${=O(n)}$, 来自于辅助数组${\mathbf{B}}$</li>
<li>${\mathrm{n}}$个元素进行2路归并排序, 归并趟数${=\left\lceil\log _{2} n\right\rceil}$，每路归并时间复杂度为${O(n)}$, 则算法的时间复杂度为${O\left(n \log _{2} n\right)}$</li>
<li>归并排序是一种稳定的排序算法</li>
</ul>
</li>
</ul>
</li>
<li><p>基数排序</p>
<ul>
<li>算法思想<ul>
<li>基数排序不是基于比较的排序算法，是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法，<br>通常基于链式存储实现</li>
<li>最高位优先法（MSD）：按关键字位权重递减（先看最高位）；最低位优先法（LSD）：按关键字位权重递增（先看个位）</li>
<li>采用最低位优先法进行基数排序的流程<ul>
<li>将整个关键字拆分为d位(或“组”)</li>
<li>按照各个关键字位权重递增的次序(如：个、十、百)，做d趟“分配”和“收集”，<br>若当前处理的关键字位可能取得r个值，则需要建立r个队列</li>
<li>分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配耗时O(n)</li>
<li>收集：把各个队列中的结点依次出队并链接。一趟收集耗时O(r)</li>
</ul>
</li>
</ul>
</li>
<li>流程<ul>
<li>最低位优先法，分为三元组（个、十、百）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjAgoV.png" alt="pCjAgoV.png"></li>
</ul>
</li>
<li>进行第一趟的分配，将个位满足相应关键字位的元素入队（先进先出）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjAOJO.png" alt="pCjAOJO.png"></li>
</ul>
</li>
<li>进行第一趟收集，使这些元素依次出队<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjE9eI.png" alt="pCjE9eI.png"></li>
</ul>
</li>
<li>进行第二趟分配与第三趟分配，最终得到相应的结果</li>
</ul>
</li>
<li>基数排序的性能分析<ul>
<li>基数排序擅长解决的问题<ul>
<li>数据元素的关键字可以方便地拆分为d组，且d较小</li>
<li>每组关键字的取值范围不大，即”较小</li>
<li>数据元素个数n较大</li>
</ul>
</li>
<li>基数排序只能对int型进行排序，无法对float型以及double型进行排序</li>
<li>空间复杂度：取决于分组队列的情况，r个队列，空间复杂度为O(r)</li>
<li>时间复杂度：基数排序需要进行d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，时间复杂度为O($d(n+r)$），<br>它与序列的初始状态无关。</li>
<li>基数排序是一种稳定的排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-各种内部排序算法的比较及应用（✪）"><a href="#6-各种内部排序算法的比较及应用（✪）" class="headerlink" title="6.各种内部排序算法的比较及应用（✪）"></a>6.各种内部排序算法的比较及应用（✪）</h3><ul>
<li>各种内部算法的比较<ul>
<li>时间复杂度分析<ul>
<li>平均时间复杂度为O($n^{2}$)：直接插入排序、折半插入排序、简单选择排序、冒泡排序<ul>
<li>直接插入排序、冒泡排序最好情况下的时间复杂度为：O($n$)（在基本有序的情况下）</li>
<li>简单选择排序与序列的初始状态无关</li>
</ul>
</li>
<li>平均时间复杂度为O($nlog_2n$)：快速排序、堆排序、归并排序<ul>
<li>快速排序的最坏时间复杂度为：O($n^{2}$)（在基本有序的情况下）</li>
<li>堆排序和归并排序的在最好、最坏和平均情况下, 堆排序的时间复杂度为：${O\left(n \log _{2} n\right)}$</li>
</ul>
</li>
<li>希尔排序作为插入排序的拓展，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间</li>
<li>基数排序的时间复杂度取决于划分的组数d、组内的队列数r、元素数量n，时间复杂度为：O($d(n+r)$)</li>
</ul>
</li>
<li>空间复杂度分析<ul>
<li>空间复杂度为O($1$)：插入排序（直接插入、折半插入、希尔排序）、冒泡排序、选择排序（简单选择排序、堆排序）<br>仅需要借助常数个辅助空间</li>
<li>空间复杂度为O($log_2{n}$)：快速排序需要借助一个递归工作栈<ul>
<li>快速排序在最坏情况下的空间复杂度可能达到O($n$)</li>
</ul>
</li>
<li>空间复杂度为O($n$)：归并排序</li>
</ul>
</li>
<li>稳定性分析<ul>
<li>稳定的排序算法：直接插入排序、折半插入排序、冒泡排序、归并排序、基数排序<ul>
<li>平均时间复杂度为O($nlog_2n$)的排序只有归并排序</li>
</ul>
</li>
<li>不稳定的排序算法：希尔排序、快速排序、选择排序（简单选择排序、堆排序）</li>
</ul>
</li>
<li>过程特征分析<ul>
<li>排序趟数与序列的原始状态的关系<ul>
<li><strong>趟数与原始序列状态无关：插入类、选择类的排序、基数排序</strong><ul>
<li>直接插入排序(每次固定插入一个元素)、简单选择排序(每次都选出一个最大/最小的元素) 均为n-1趟排序</li>
<li>基数排序：每趟都要进行分配和收集，排序趟数固定为d</li>
</ul>
</li>
<li><strong>趟数与原始序列状态有关：交换类的排序(冒泡排序、快速排序)</strong><ul>
<li>冒泡排序如果为顺序，只需要进行一趟排序（本趟无元素交换）；若为逆序需要进行n-1趟排序</li>
<li>快速排序若每趟的枢纽元素都能平均的划分两个子序列则需要的趟数最少，若原始序列有序，则需要的趟数最多</li>
</ul>
</li>
</ul>
</li>
<li>比较次数与序列的原始状态的关系<ul>
<li><strong>比较次数与序列的原始状态无关：折半插入排序、选择类的排序(简单选择排序、堆排序)</strong><ul>
<li>折半插入排序的比较次数仅取决于表中的元素个数n</li>
<li>简单选择排序的关键字比较次数恒为：n(n−1)/2次</li>
</ul>
</li>
<li><strong>比较次数与序列的原始状态有关：直接插入排序、希尔排序、冒泡排序、快速排序</strong><ul>
<li>直接插入排序最好只做n-1次关键字比较（顺序时），最坏做n(n−1)/2次关键字比较（逆序时）</li>
<li>冒泡排序顺序时比较次数为n-1次，逆序时比较次数为n(n−1)/2次</li>
</ul>
</li>
</ul>
</li>
<li>移动次数与序列的原始状态的关系<ul>
<li><strong>元素的移动次数与序列的原始状态无关：基数排序</strong></li>
<li>元素的移动次数与序列的原始状态有关：直接插入排序、折半排序、冒泡排序、快速排序、简单选择排序<ul>
<li>直接插入排序在顺序的情况下，不需要移动元素；若逆序需要移动大量元素</li>
<li>冒泡排序有序时不需要移动元素；若逆序时需要移动3n(n-1)/2次</li>
<li>快速排序若每趟的枢纽元素都能平均的划分两个子序列则需要的移动的次数少，<br>若原始序列有序，则需要移动的次数最多</li>
<li>简单选择排序在有序的情况下不需要移动元素</li>
</ul>
</li>
</ul>
</li>
<li>每趟排序结束后都至少能确定一个元素的最终位置的排序算法：冒泡排序、快速排序、简单选择排序、堆排序</li>
</ul>
</li>
</ul>
</li>
<li>内部排序算法的应用<ul>
<li>基于关键字个数n选择排序算法<ul>
<li>若n较小，可采用直接插入排序或简单选择排序。由于直接插入排序所需的记录移动次数较简单选择排序的多，<br>因而当记录本身信息量较大时，用简单选择排序较好。</li>
<li>若n较大，则应采用时间复杂度为O($nlog_2{n}$)的排序方法：快速排序、堆排序或归并排序。<br>快速排序被认为是目前基于比较的内部排序方法中最好的方法</li>
<li>当待排序的关键字随机分布时，快速排序的平均时间最短。<br>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，这两种排序都是不稳定的。</li>
<li>若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好。</li>
</ul>
</li>
<li>若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排序为宜。</li>
<li>若要求排序稳定且时间复杂度为O($log_2{n}$)，则可选用归并排序。<ul>
<li>但本章介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。<br>先利用直接插入排序求得较长的有序子文件，然后两两归并。直接插入排序是稳定的，因此改进后的归并排序仍是稳定的。</li>
</ul>
</li>
<li>在基于比较的排序方法中，每次比较两个关键字的大小之后，仅出现两种可能的转移，<br>因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个关键字随机分布时，任何借助于“比较”的排序算法，至少需要O($nlog_2{n}$)的时间。</li>
<li>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构。<ul>
<li>但是希尔排序和堆排序利用顺序存储的随机访问特性，如果将其换为链式存储结构其时间复杂度将增加</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-外部排序（✪）"><a href="#7-外部排序（✪）" class="headerlink" title="7.外部排序（✪）"></a>7.外部排序（✪）</h3><ul>
<li><p>外部排序的基本概念与方法</p>
<ul>
<li>外部排序的基本概念<ul>
<li>外部排序：数据元素太多，无法一次全部读入内存进行排序。</li>
<li>因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，<br>在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为外部排序。</li>
</ul>
</li>
<li>外部排序的方法<ul>
<li>外部排序通常采用归并排序法。它包括两个阶段：<ul>
<li>根据内存缓冲区大小，将外存上的文件分成若干长度为L的子文件，依次读入内存并利用内部排序方法对它们进行排序<br>并将排序后得到的有序子文件重新写回外存，<strong>称这些有序子文件为<u>归并段</u>或顺串</strong></li>
<li>对这些归并段在内存中进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。</li>
</ul>
</li>
<li>使用“归并排序”的方法，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序</li>
<li>在内存中，归并后的对象顺序存放在输出缓冲区中，若缓冲区的对象存满，则将其顺序写到输出归并段中并清空缓冲区</li>
<li>若某个输入缓冲区中的对象在移动到输出缓冲区之后为空，则从其对应的输入归并段中再读取下一块，继续参加归并</li>
</ul>
</li>
<li>外部排序进行归并的流程<ul>
<li>内存读取外存的子文件进行内部排序，将排序好的有序子文件依次返回外层，这些有序子文件又称为归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjLMSf.png" alt="pCjLMSf.png"></li>
</ul>
</li>
<li>经过16次读和16次写之后，由于经过了内存中的内部排序，此时在外存中形成了初始归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjO8gK.png" alt="pCjO8gK.png"></li>
<li>此时对这8个初始归并段在内存中进行第一趟归并，需要读16次，写16次<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjXKsS.png" alt="pCjXKsS.png"></li>
</ul>
</li>
<li>在进行了第一趟归并之后，形成了4个新的归并段，之后需要对这4个归并段在内存中进行进一步的归并（第二趟归并）<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjXCrD.png" alt="pCjXCrD.png"></li>
</ul>
</li>
<li>此时对这4个归并段在内存中进行归并操作，依旧需要读16次，写16次，最后会形成一个新的2个归并段，<br>此时再进行一次归并即可得到最终的有序序列<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjX6Rx.png" alt="pCjX6Rx.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外部排序的优化</p>
<ul>
<li>在外部排序中实现两两归并时，由于不可能将两个有序段及归并结果同时存放在内存中，<br>因此需要不停地将数据读出、写入磁盘，这会消耗大量的时间<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjLzng.png" alt="pCjLzng.png"></li>
</ul>
</li>
<li>多路平衡归并<ul>
<li>${\mathrm{k}}$路平衡归并的概念<ul>
<li>最多只能有${\mathrm{k}}$个段归并为一个</li>
<li>每一趟归并中, 若有${\mathrm{m}}$个归并段参与归并, 则经过这一趟处理得到${\lceil\mathrm{m} / \mathrm{k}\rceil}$个新的归并段</li>
<li>图片<ul>
<li>4路平衡归并<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvSMUe.png" alt="pCvSMUe.png"></li>
</ul>
</li>
<li>4路归并<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvSGvt.png" alt="pCvSGvt.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>可以用多路归并的方法进行优化，采用4路归并时，只需要两趟归并，总读写次数为=32*2+32=96<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCjjmk9.png" alt="pCjjmk9.png"></li>
</ul>
</li>
<li>在做m路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置2m个输入缓冲区和2个输出缓冲区<br>以便在执行内部归并时，能同时进行输入输出操作。若仅设置m个输入缓冲区，则仅能进行串行操作，无法并行处理。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于优化归并趟数(读写次数)的分析</p>
<ul>
<li>对r个初始归并段，做k路归并，则归并树可用K叉树来表示</li>
<li>若树高为h，则归并趟数$=\mathbf{h}-\mathbf{1}=\left\lceil\log _{k} r\right\rceil $<ul>
<li>推导：${\mathrm{k}}$叉树第${\mathrm{h}}$层最多有${k^{h-1}}$个结点，则${r \leq k^{h-1},(\mathrm{h}-1)}$最小${=\left\lceil\log _{k} r\right\rceil}$</li>
<li>由此，k越大，r越小，则归并趟数越少，读写次数越少</li>
</ul>
</li>
<li>可以增加输入缓冲区的数量来提高$K$（归并路数），即实现多路归并，但是会产生一些负面影响<ul>
<li>k路归并时，需要开辟k个输入缓冲区，内存开销增加。</li>
<li>每挑选一个关键字需要对比关键字(k-1)次，内部归并所需时间增加（可以设置败者树来解决此问题）</li>
</ul>
</li>
<li>可以减少初始归并段数量$r$来减少归并趟数，<br>生成初始归并段的“内存工作区”越大，初始归并段越长，此时初始归并段的数量越少<ul>
<li>若共${\mathbf{N}}$个记录, 内存工作区可以容纳${\mathrm{L}}$个记录, 则初始归并段数量  $\mathrm{r}=\lceil N / L\rceil$</li>
<li>可用“置换-选择排序”进一步减少初始归并段数量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>败者树</p>
<ul>
<li>败者树可以在多路归并时减少每挑选一个关键字时的比较次数，提高内部归并的时间</li>
<li>对于k路归并，第一次构建败者树时，需要对比关键字k-1次<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvp6Wd.png" alt="pCvp6Wd.png"></li>
</ul>
</li>
<li>有了败者树, 选出最小元素, 对于每一次比较只需对比关键字${\left\lceil\log _{2} k\right\rceil}$次 <ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv9pY4.png" alt="pCv9pY4.png"></li>
</ul>
</li>
<li>例题<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvX4EQ.png" alt="pCvX4EQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>置换-选择排序（生成初始归并段的优化方法）</p>
<ul>
<li>使用置换-选择排序，可以让每个初始归并段的长度超越内存工作区大小的限制</li>
<li>在内存工作区中传入待排序文件的关键字，内存工作区满了之后，选择其中最小的输出，<br>此时设置MINIMAX记录输出关键字的信息，下一个输出的关键字必须大于MINIMAX，否则无法输出<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv90cn.png" alt="pCv90cn.png"></li>
</ul>
</li>
<li>三个关键字都小于MINIMAX时，均无法输出，此时第一个归并段构建完成，可以构建下一个新的归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv94j1.png" alt="pCv94j1.png"></li>
</ul>
</li>
<li>最后将构建出数量r较少的初始归并段<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCv9X3d.png" alt="pCv9X3d.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>最佳归并树</p>
<ul>
<li><p>归并过程中的磁盘I/O次数=归并树的WPL*2</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCvP5TK.png" alt="pCvP5TK.png"></li>
</ul>
</li>
<li><p>最佳归并树指此时的I/O时间最小的树，可以由构造哈夫曼树的方法来构造</p>
<ul>
<li>此时将归并段看做树的带权结点选取最小的组合来构造</li>
<li>2路归并的最佳归并树<ul>
<li><img src="https://s1.ax1x.com/2023/07/26/pCviEmq.png" alt="pCviEmq.png"></li>
</ul>
</li>
<li>多路归并的最佳归并树<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvXWDS.png" alt="pCvXWDS.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>k叉归并的最佳归并树一定是严格k叉树，即树中只有度为k、度为0的结点</p>
</li>
<li><p>对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的“虚段”，再进行k叉哈夫曼树的构造</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvXBAH.png" alt="pCvXBAH.png"></li>
</ul>
</li>
<li><p>如何判断初始归并段的数量无法构成严格k叉归并树以及需要添加虚段的数量</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/27/pCvX3N9.png" alt="pCvX3N9.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第七章-查找</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="数据结构第七章-查找"><a href="#数据结构第七章-查找" class="headerlink" title="数据结构第七章 查找"></a>数据结构第七章 查找</h2><blockquote>
<p>计算机学科基础：数据结构第七章查找的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1.查找的基本概念"></a>1.查找的基本概念</h3><ul>
<li>查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，<br>可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种<ul>
<li>①查询某个特定的数据元素是否在查找表中</li>
<li>②检索满足条件的某个特定的数据</li>
<li>③在查找表中插入一个数据元素</li>
<li>④从查找表中删除某个数据元素</li>
</ul>
</li>
<li>静态查找表和动态查找表<ul>
<li>若一个查找表的操作只涉及上述操作①和②，则无须动态地修改查找表，此类查找表称为静态查找表。</li>
<li>与此对应，需要动态地插入或删除的查找表称为动态查找表。<br>适合静态查找表的查找方法有顺序查找、折半查找、散列查找等，<br>适合动态查找表的查找方法有二叉排序树的查找、散列查找等。</li>
</ul>
</li>
<li>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</li>
<li>平均查找长度（<strong>ASL</strong>）：在查找过程中，一次查找的长度是指需要比较的关键字次数，<br>而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。</li>
</ul>
<h3 id="2-顺序查找和折半查找（✪）"><a href="#2-顺序查找和折半查找（✪）" class="headerlink" title="2.顺序查找和折半查找（✪）"></a>2.顺序查找和折半查找（✪）</h3><ul>
<li><p>顺序查找（线性查找，适用于顺序表和链表）</p>
<ul>
<li><p>一般线性表的顺序查找</p>
<ul>
<li><p>加入哨兵的线性查找，算法从尾部开始查找，此时在0号位设置一个哨兵，查找失败则返回0，<br>无需判断是否越界，提高程序效率</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>		<span class="comment">//顺序表</span></span><br><span class="line">    <span class="type">int</span> *elem;		<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;   <span class="comment">//表长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST,ElemType Key)</span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key; <span class="comment">//0号位置存哨兵</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.TableLen;ST.elem[i]!=key;i--) <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>平均查找长度：查找成功时：ASL=$\frac{n+1}{2}$，查找失败时为：ASL=$n+1$</p>
</li>
</ul>
</li>
<li><p>有序表的顺序查找</p>
<ul>
<li>可以设置查找判定树<ul>
<li>成功结点的关键字对比次数=结点所在层数</li>
<li>失败结点的关键字对比次数=其父节点所在层数</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pC7kJsS.png" alt="pC7kJsS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平均查找长度：查找成功时：ASL=$\frac{n+1}{2}$，查找失败时为：ASL=$\frac{n}{n+1}+\frac{n}{2}$</p>
</li>
<li><p>顺序查找的时间复杂度：O(n)</p>
</li>
</ul>
</li>
<li><p>折半查找（二分查找，仅适用于<strong>有序的顺序表</strong>✪）</p>
<ul>
<li><p>此时设定中间指针(mid=(low+high)/2)，向下取整。如果较小则high=mid-1，在左边的区间再进行折半查找；<br>如果较大则low=mid+1,在右边的区间再进行折半查找。</p>
</li>
<li><p>代码实现（中间指针向下取整）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>; <span class="comment">//取有序表的中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;   <span class="comment">//查找成功则返回当前位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low=mid+<span class="number">1</span>; <span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>折半查找的判定树</p>
<ul>
<li>性质（当$\operatorname{mid}{=\lfloor(} low +   high ) / 2\rfloor$时）<ul>
<li>如果当前Iow和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</li>
<li>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</li>
<li>每个结点值均大于其左子结点值，小于其右子结点值</li>
<li>此二叉树时一颗平衡二叉树，并且有性质：右子树结点数—左子树结点数=0或1</li>
<li>折半查找的判定树中，只有最下面一层是不满的，元素个数为${\boldsymbol{n}}$时树高${h=\left\lceil\log _{2}(n+1)\right\rceil}$<ul>
<li>折半查找不成功时的最多比较次数为树的高度，最少比较次数为树的高度减一<ul>
<li>此时由${h=\left\lceil\log _{2}(16+1&gt;2^{4})\right\rceil}$最多需要比较5次，最少需要比较4次<img src="https://s1.ax1x.com/2023/07/20/pCHyCUf.png" alt="pCHyCUf.png"></li>
</ul>
</li>
</ul>
</li>
<li>若有序序列有个n元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点<br>（失败结点的数量=成功结点所构成的树的空链域数量=n+1）</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pC7Exr8.png" alt="pC7Exr8.png"></li>
</ul>
</li>
<li>关于折半查找二叉树的例题<ul>
<li>例1，已知关键字的个数，求查找成功的平均复杂长度和查找失败的平均复杂长度<ul>
<li>此时构造判定树，采用（$\operatorname{mid}{=\lfloor(} low +   high ) / 2\rfloor$写出中间的点，<br>再根据左小右大确定两边的范围，再某段范围里通过公式求出两边的点的中间的点）<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHyxWF.png" alt="pCHyxWF.png"></li>
</ul>
</li>
</ul>
</li>
<li>例2，判断是否能成为折半查找中关键字的比较序列<ul>
<li>此时直接写出相关的判定树，之后对各元素存在的合理性进行判断，<br>A选项中200后的450说明之后的数都应该比200大，但是之后出现了180，此时不满足判定树的原理<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCH6XnA.png" alt="pCH6XnA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>折半查找的时间复杂度：$O ( \log _ { 2 } n )$</p>
</li>
</ul>
</li>
<li><p>分块查找（索引顺序查找,了解）</p>
<ul>
<li><p>概述</p>
<ul>
<li>将查找表分为若干块，块内的元素可以无序，但是块间的元素必须是有序的，<br>前一个块中的最大关键字小于后一个块中所有记录的关键字</li>
<li>之后建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，<br>索引表按关键字有序排序。</li>
<li>对索引表进行折半查找时，若索引表中不包含目标关键字，则折半查找最终停在low&gt;high,要在Iow所指分块中查找</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCH0oY4.png" alt="pCH0oY4.png"></li>
</ul>
</li>
<li><p>分块查找的平均时间复杂度分析（一般只分析分块查找的顺序查找索引表下的ASL）</p>
<ul>
<li><strong>当每个分块内部元素的数量（s）等于元素总数开根时<script type="math/tex">\sqrt{n}</script>时，（此时s=b=$\sqrt{n}$）此时其查找时间最小</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHBwcR.png" alt="pCHBwcR.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>分块矩阵的相应例题</p>
<ul>
<li><p>例1，利用分块矩阵顺序查找索引查找表的公式来计算查找成功的平均查找长度，$A S L = \frac { b + 1 } { 2 } + \frac { s + 1 } { 2 }$，<br>b和s分别是块内的单元数和分块的数量，选B</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHcK9U.png" alt="pCHcK9U.png"></li>
</ul>
</li>
<li><p>例2，分析在什么条件下的分块查找的平均查找长度最小并计算，此时需要满足：块数=块长=$\sqrt{元素总数}=255$，<br>这个时候可以在索引项和索引表中都采取<strong>折半查找</strong>的方式，来计算最小的平均查找长度：${A S L=\left\lceil\log _{2}(255+1)\right\rceil + \left\lceil\log _{2}(255+1)\right\rceil}=16$</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHcRC8.png" alt="pCHcRC8.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-树形查找（✪）"><a href="#3-树形查找（✪）" class="headerlink" title="3.树形查找（✪）"></a>3.树形查找（✪）</h3><ul>
<li><p>二叉排序树（BST✪）</p>
<ul>
<li><p>二叉排序树的定义</p>
<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字</li>
<li>右子树上所有结点的关键字均大于根结点的关键字</li>
<li>左子树和右子树又各是一棵二叉排序树。</li>
<li>注：空树也是二叉排序树</li>
<li>进行中序遍历，可以得到一个递增的有序序列</li>
</ul>
</li>
<li><p>二叉排序树的查找</p>
<ul>
<li><p>从根结点开始，沿某个分支逐层向下比较的过程</p>
</li>
<li><p>若树非空，目标值与根结点的值比较</p>
<ul>
<li>若相等，则查找成功</li>
<li>若小于根结点，则在左子树上查找，否则在右子树上查找。</li>
</ul>
</li>
<li><p>查找成功，返回结点指针；查找失败返回NULL</p>
</li>
<li><p>代码实现（了解）</p>
<ul>
<li><p>二叉排序树的非递归算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> Key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;Key!=T-&gt;key)&#123;  <span class="comment">//若树空或等于根结点的值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)  <span class="comment">//小于根结点的值，在左子树上查找</span></span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=T-&gt;rchild;  <span class="comment">//大于根结点的值，则在右子树上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的递归算法（空间复杂度较高，执行效率较低）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key); <span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key); <span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的插入</p>
<ul>
<li><p><strong>将二叉排序树T1的<u>先序遍历序列</u>依次插入初始为空的树中，所得到的二叉排序树T2和T1的形态完全相同。</strong></p>
</li>
<li><p><strong>在二叉排序树中插入一个结点的时间复杂度为O(n)</strong></p>
</li>
<li><p>插入结点的过程如下：若原二叉排序树为空，则直接插入，否则，若关键字k小于根结点值，则插入到左子树，<br>若关键字k大于根结点值，则插入到右子树。</p>
</li>
<li><p>代码实现（了解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BiTree &amp;T,keyType k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;	<span class="comment">//此时原树为空，新插入的结点为根节点</span></span><br><span class="line">        T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode)); </span><br><span class="line">        T-&gt;data=k;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回1，插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(K==T-&gt;data)	<span class="comment">//树中存在相同关键字的结点，此时插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;data) <span class="comment">//新结点会插入到此时结点的左子树中</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//新结点会插入到此时结点的右子树中</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的构造</p>
<ul>
<li><p>从一颗空树出发，依次输入元素，并将其插入到二叉树中的合适位置</p>
</li>
<li><p>代码实现（了解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BiTree &amp;T,keyType str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    T=<span class="literal">NULL</span>; <span class="comment">//初始时为空树</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        BST_INsert(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</li>
<li>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li>
<li>若结点z有左、右两棵子树，则令z的直接后继（直接前驱）替代z，然后从二叉排序树中删去这个直接后继（直接前驱）<br><strong>这里的直接后驱指的是右子树中进行中序遍历的第一个数，直接前驱指的是左子树中进行中序遍历的最后一个数</strong>）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/20/pCHfwm4.png" alt="pCHfwm4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的查找效率分析</p>
<ul>
<li>二叉排序树的查找效率，主要取决于树的高度。若树高h，找到最下层的一个结点需要对比h次</li>
<li>若二叉排序树的左、右子树的高度之差的绝对值不超过1(为平衡二叉树时)，它的平均查找长度为O($log_{2}n$)。</li>
<li>若二叉排序树是一个只有右（左）孩子的单支树（类似有序的单链表），则其平均查找长度为O(n)。<ul>
<li>用逐点插入法构建二叉排序树，若先后插入的关键字有序，此时二叉排序树的深度最大</li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHfLjS.png" alt="pCHfLjS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平衡二叉树（AVL树✪）</p>
<ul>
<li><p>平衡二叉树的定义</p>
<ul>
<li>平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：<br>它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。</li>
<li>结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</li>
</ul>
</li>
<li><p>平衡二叉树的插入</p>
<ul>
<li><p>概述</p>
<ul>
<li>每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。</li>
<li><strong>若导致了不平衡，则先找到插入路径上<u>离插入结点最近的</u>平衡因子的绝对值大于1的结点A，</strong><br><strong>再对以A为根的子树（最小不平衡子树），在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</strong><ul>
<li>此时找到距离插入点最近的平衡因子的绝对值大于1的点为序号70，LL插入，此时则应该变动70的左子树68进行右上旋</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHvN3F.png" alt="pCHvN3F.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡</strong></li>
</ul>
</li>
<li><p>四种调整的情况</p>
<ul>
<li><p>LL：在A的左孩子的左子树中插入导致不平衡</p>
<ul>
<li><p>进行右单旋转，将A的左孩子右上旋</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHbUcn.png" alt="pCHbUcn.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f是双亲结点，gf是f的双亲结点</span></span><br><span class="line">f-&gt;lchild=p-&gt;rchild;</span><br><span class="line">p-&gt;rchild=f;</span><br><span class="line">gf-&gt;lchild/rchild=p</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>RR：在A的右孩子的右子树中插入导致不平衡</p>
<ul>
<li><p>进行左单旋转，将A的右孩子左上旋</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHbH9H.png" alt="pCHbH9H.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f-&gt;rchild=p-&gt;lchild;</span><br><span class="line">p-&gt;lchild=f;</span><br><span class="line">gf-&gt;lchild/rchild=p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LR：在A的左孩子的右子树中插入导致不平衡</p>
<ul>
<li>在A的左孩子的右子树插入导致A不平衡，<strong>将A的左孩子的右孩子先左上旋再右上旋</strong>（此时这里的A为66，绝对值大于1）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHXGbq.png" alt="pCHXGbq.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>RL：在A的右孩子的左子树中插入导致不平衡</p>
<ul>
<li>在A的右孩子的左子树插入导致A不平衡，<strong>将A的右孩子的左孩子先右上旋再左上旋</strong>（此时这里的A为50(绝对值大于1)）</li>
<li>图片1<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHXdGF.png" alt="pCHXdGF.png"></li>
</ul>
</li>
<li>图片2<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCHjZQJ.png" alt="pCHjZQJ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平衡二叉树的删除</p>
<ul>
<li>步骤<ul>
<li>①删除结点(方法同“二叉排序树”)</li>
<li>②向上看是否导致存在不平衡，若没有则结束</li>
<li>③找最小不平衡子树下，“个头”最高的儿子、孙子</li>
<li>④根据孙子相对于最小不平衡子树的根结点的位置，使用相关方法调整平衡(LL/RR/LR/RL)<ul>
<li>孙子在LL:儿子右单旋</li>
<li>孙子在RR:儿子左单旋</li>
<li>孙子在LR:孙子先左旋，再右旋</li>
<li>孙子在RL:孙子先右旋，再左旋</li>
</ul>
</li>
<li>⑤如果不平衡向上传导，继续②<ul>
<li>对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</li>
</ul>
</li>
</ul>
</li>
<li>例子：此时删除32后向上找到44不平衡，向下找到44最高的儿子和孙子78、50。孙子的情况是RL，<br>则此时对其先右上旋再左上旋，调整为平衡二叉树<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCbSqgO.png" alt="pCbSqgO.png"></li>
</ul>
</li>
<li>对于一个平衡二叉树如果删除一个结点后再插入（不管是叶结点还是分支结点）此时树可能会发生改变；<br>对于一个二叉排序树，删除叶子结点后再插入此时树不变，删除分支结点后再插入树会发生改变。</li>
</ul>
</li>
<li><p>平衡二叉树的查找</p>
<ul>
<li>在查找过程中，查找次数不会超过平衡二叉树的深度</li>
<li>在平衡二叉树上，树上任一结点的左子树和右子树的高度之差不超过 1 。</li>
<li>假设以${n_{h}}$表示深度为${h}$的平衡树中含有的最少结点数。则有${n_{0}=0, n_{1}=1, n_{2}=2}$, 并且有${n_{h}=n_{h-1}+n_{h-2}+1}$<ul>
<li>本题用此方法递推计算（1,2,4,7,12,20）构建5层平衡二叉树至少需要12个顶点，<br>构建6层平衡二叉树至少需要20个顶点，因此含有15个顶点的平衡二叉树的最大深度为5</li>
<li>平衡二叉树总结点数最小时，所有非叶节点的平衡因子都为1</li>
</ul>
</li>
<li>含有$\mathrm{n}   个结点的平衡二叉树深度最小值为 \left\lfloor\log _{2} \mathrm{n}\right\rfloor+1$</li>
<li>平衡二叉树的平均查找长度为${O\left(\log _{2} n\right)}$</li>
</ul>
</li>
</ul>
</li>
<li><p>红黑树（RBT✪）</p>
<ul>
<li>红黑树的定义：一种特殊的二重排序树<ul>
<li>红黑树RBT，插入/删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。<br>即便需要调整，一般都可以在常数级时间内完成</li>
<li>平衡二叉树：适用于以查为主、很少插入/删除的场景</li>
<li>红黑树：适用于频繁插入、删除的场景，实用性更强</li>
<li>结点的黑高：从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数</li>
</ul>
</li>
<li>红黑树的五个特点（左根右，根叶黑，不红红，黑路同）<ul>
<li>每个结点或是红色，或是黑色的</li>
<li>根节点是黑色的</li>
<li>叶结点(这里指NULL和结点失败结点)均是黑色的</li>
<li>不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</li>
<li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li>
</ul>
</li>
<li>红黑树的结论<ul>
<li>从根节点到叶结点的最长路径不大于最短路径的2倍<ul>
<li>当从根到任意一个叶结点的简单路径最短时，这条路径必然全部由黑结点构成</li>
<li>当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时两者的数量相同</li>
<li>红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过2</li>
</ul>
</li>
<li>有n个内部节点的红黑树高度 h≤$2log_{2}(n+1)$</li>
<li>根节点黑高为h的红黑树，内部结点数（关键字）至少有$2^{h}-1$个</li>
<li>红黑树查找操作时间复杂度=O($log_{2}n$)，查找效率与AVL树同等数量级</li>
</ul>
</li>
<li>红黑树的插入<ul>
<li>插入结点的方法，注：一般插入时违背的是“不红红”<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCbViRA.png" alt="pCbViRA.png"></li>
</ul>
</li>
<li>例子<ul>
<li><img src="https://s1.ax1x.com/2023/07/21/pCbVnIg.png" alt="pCbVnIg.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-B树与B-树（✪）"><a href="#4-B树与B-树（✪）" class="headerlink" title="4.B树与B+树（✪）"></a>4.B树与B+树（✪）</h3><ul>
<li><p>B树（✪）</p>
<ul>
<li><p>B树的性质</p>
<ul>
<li>m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。</li>
<li>一棵m阶B树或为空树，或为满足如下特性的m叉树<ul>
<li><strong>树中每个结点至多有$m$棵子树，即至多含有$m-1$个关键字。</strong></li>
<li>若根结点不是叶结点，则至少有两棵子树。</li>
<li><strong>除根结点外的所有非叶结点至少有$ \lceil m / 2\rceil $棵子树，即至少含有$ \lceil m / 2\rceil-1 $个关键字。</strong></li>
<li>满足左&lt;中&lt;右的性质</li>
<li>所有叶节点都出现在同一层次上，并且不带信息（即为查找失败结点）</li>
<li>${\mathrm{n}}$个关键字的B树必有${\mathrm{n}+1}$个叶子结点</li>
<li>注：判断B树的类型，需要看其中关键字最多的结点判断是几阶</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqrBkV.png" alt="pCqrBkV.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B树的最小高度和最大高度（此时一般不包括最后一层叶子结点的层数）</p>
<ul>
<li>对于n个关键字，m阶B树的最小高度<ul>
<li>在每一层中含有最多的结点数并且在每一个结点中含有最多的关键字数</li>
<li>此时关键字的数量满足：$n \leqslant(m-1)\left(1+m+m^{2}+\cdots+m^{h-1}\right)=m^{h}-1$</li>
<li>此时可算出最小的高度： $h \geqslant \log _{m}(n+1)$</li>
</ul>
</li>
<li>对于n个关键字，m阶B树的最大高度<ul>
<li>在每一层中含有最小的结点数并且在每一个结点中含有最少的关键字数</li>
<li>此时让各层的分叉尽可能的少, 即根节点只有 2 个分叉, 其他结点只有${\lceil m / 2\rceil}$个分叉</li>
<li>各层结点至少有：第一层 1、第二层 2、第三层${2\lceil\mathrm{m} / 2\rceil \ldots}$第h层${2(\lceil\mathrm{m} / 2\rceil)^{h-2}}$，<br>则第h+1层共有叶子结点（失败结点）${2(\lceil m / 2\rceil)^{h-1}}$个</li>
<li>${\mathrm{n}}$个关键字的B树必有${\mathrm{n}+1}$个叶子结点, 则${n+1 \geq 2(\lceil m / 2\rceil)^{h-1}}$, 即${h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1}$</li>
<li>此时可算出最大的高度：$h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1$</li>
</ul>
</li>
<li>含$\mathrm{n}$个关键字的$\mathrm{m叉B} 树, 满足 \log _{m}(n+1) \leq h \leq \log _{\lceil m / 2\rceil} \frac{n+1}{2}+1$</li>
</ul>
</li>
<li><p>B树的插入</p>
<ul>
<li>首先定位元素插入的位置，新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</li>
<li>如果再插入关键字后，结点中的关键字数量没有超过上限，此时直接插入即可<br>（如阶为5的B树的关键字范围为2—4，在一个结点中最多有4个，最少有2个关键字）</li>
<li>在插入key后, 若导致原结点关键字数超过上限, 则从中间位置${(\lceil\mathrm{m} / 2\rceil)}$将其中的关键字分为两部分,<br>左部分包含的关键字放在原结点中, 右部分包含的关键字放到新结点中, 中间位置${(\lceil{m} / 2\rceil)}$的结点插入原结点的父结点</li>
<li>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，<br>进而导致B树高度增1。</li>
<li>图片<ul>
<li>图1<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqy956.png" alt="pCqy956.png"></li>
</ul>
</li>
<li>图2<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqyi8O.png" alt="pCqyi8O.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B树的删除</p>
<ul>
<li><p>若被删除关键字在非终端节点，则用直接前驱或直接后继来替代被删除的关键字</p>
<ul>
<li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li>
<li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqy8MQ.png" alt="pCqy8MQ.png"></li>
</ul>
</li>
<li><p>若被删除关键字在终端节点，此时分为下列三种情况</p>
<ul>
<li>删除后的结点中的关键字的数量不低于低于下限${\lceil m / 2\rceil-1}$时，则直接删除该关键字</li>
<li>（兄弟够借）<ul>
<li>删除后结点的关键字数量将低于下限${\lceil m / 2\rceil-1}$，且与结点相邻的右（或左）兄弟结点的关键字个数还很宽裕，</li>
<li>此时删除该结点后，将其对应的一个父节点的关键字转移到此处，并将右兄弟或左兄弟的一个关键字转移到此父节点</li>
<li>去借右兄弟：<ul>
<li>此时删除38，此时其右兄弟够用，将父结点关键字49下移来替换38，<br>并且将右兄弟关键字70上移到原来的父节点关键字处</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6Ces.png" alt="pCq6Ces.png"></li>
</ul>
</li>
</ul>
</li>
<li>去借左兄弟<ul>
<li>此时删除90，其左兄弟够用，使父结点关键字88下移，再将左兄弟结点关键字87上移</li>
<li>图片1<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq68fK.png" alt="pCq68fK.png"></li>
</ul>
</li>
<li>图片2<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6d0A.png" alt="pCq6d0A.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>(兄弟不够借)<ul>
<li>若被删除关键字所在结点删除关键字后少于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均${\lceil m / 2\rceil-1}$, </li>
<li>则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</li>
<li>在合并过程中, 双亲结点中的关键字个数会减 1，此时可能需要对双亲结点进行相关操作<ul>
<li>若双亲结点不是根结点, 且关键字个数减少到${\lceil m / 2\rceil-2}$, 则又要与它自己的兄弟结点进行调整或合并操作,<br>并重复上述步骤, 直至符合${B}$树的要求为止。</li>
<li>若其双亲结点是根结点且关键字个数减少至 0 (根结点关键字个数为 1 时, 有 2 棵子树) , 则直接将根结点删除,<br>合并后的新结点成为根</li>
</ul>
</li>
<li>流程<ul>
<li>此时删除49，但是其右兄弟的关键字数量已经不够借，<br>此时删除49之后将父结点关键字70下移以及和其右兄弟结点的两个关键字合并到一起<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6TpT.png" alt="pCq6TpT.png"></li>
</ul>
</li>
<li>此时合并之后，上方的父结点中的关键字数量已经少于下限，此时也需要合并，<br>可将父结点82与其右兄弟结点中的87,93关键字合并到一起，此时根节点为空，删除根结点即可<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCq6vA1.png" alt="pCq6vA1.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqcu38.png" alt="pCqcu38.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B+树（适用于数据库）</p>
<ul>
<li><p>B+树的性质</p>
<ul>
<li>每个分支结点最多有m棵子树（孩子结点）</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有${\lceil\mathrm{m} / 2\rceil}$棵子树。</li>
<li>结点的子树个数与关键字个数相等。</li>
<li>所有<strong>叶结点</strong>包含<strong>全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，<br>并且相邻叶结点按大小顺序相互链接起来。（支持顺序查找）</li>
<li>所有分支结点中仅包含它的各个子结点中关键字的<strong>最大值</strong>及指向其<strong>子结点的指针</strong>。</li>
<li><p>B+树含有两个头指针，一个指向根结点，一个指向关键字最小的叶结点，<br>可以进行从最小关键字开始的顺序查找以及从根结点开始的多路查找</p>
<ul>
<li>在B+树中进行的多路查找，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，<br>直到叶结点上的该关键字为止。在B+树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。</li>
</ul>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqcdvF.png" alt="pCqcdvF.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>B+树与B树的区别</p>
<ul>
<li>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；<br>而在B树中，具有n个关键字的结点含有n+1棵子树。</li>
<li>在B+树中，每个结点（非根内部结点）的关键字个数n的范围是 ${\lceil\mathrm{m} / 2\rceil} ≤n≤m$ (而根结点：$1≤n≤m$)；<br>而在B树中，每个结点（非根内部结点）的关键字个数n的范围是${\lceil\mathrm{m} / 2\rceil}-1≤n≤m-1$ (根结点：$1≤n≤m-1$)</li>
<li>在B+树中，叶结点包含了全部关键字，非叶结点中出现的关键字也会出现在叶结点中；<br>而在B树中，最外层的终端结点包含的关键字和其他结点包含的关键字是不重复的。</li>
<li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，<br>非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>B树的结点中都包含了关键字对应的记录的存储地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-散列表（✪）"><a href="#5-散列表（✪）" class="headerlink" title="5.散列表（✪）"></a>5.散列表（✪）</h3><ul>
<li>散列表的基本概念<ul>
<li>散列表 (哈希表，Hash Table)：是一种数据结构。根据关键字而直接进行访问的数据结构。<br>散列表建立了关键字和存储地址之间的一种直接映射关系。</li>
<li>散列函数（哈希函数）：一个把查找表中的关键字映射成该关键字对应的地址的函数，<br>记为Hash(key)=Addr (这里的地址可以是数组下标、索引或内存地址等)</li>
<li>冲突和同义词：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，<br>这些发生碰撞的不同关键字称为同义词</li>
</ul>
</li>
<li>散列表的构造<ul>
<li>进行构造的要点<ul>
<li>定义域必须涵盖所有可能出现的关键字，值域不能超出散列表的地址范围</li>
<li>尽可能减少冲突。散列函数计算出来的地址应尽可能均匀分布在整个地址空间。</li>
<li>散列函数应尽量简单，能够快速计算出任意一个关键字对应的散列地址</li>
</ul>
</li>
<li>四种构造的方法<ul>
<li>除留余数法：H(key)=key%p<ul>
<li>散列表表长为m，取一个不大于m但最接近或等于m的质数p</li>
<li>如表长为13，16，p可以均选13</li>
<li>只要关键字为整数就适用</li>
</ul>
</li>
<li>直接定址法：H(key)=key或H(key)=a*key+b<ul>
<li>其中，和b是常数。这种方法计算最简单，且不会产生冲突。<br>若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li>
<li>适用场景：关键字分布基本连续</li>
</ul>
</li>
<li>数字分析法：选取数码分布较为均匀的若干位作为散列地址<ul>
<li>每个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；<br>而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。</li>
<li>适用场景：关键字集合已知，且关键字的某几个数码位分布均匀</li>
</ul>
</li>
<li>平方取中法：取关键字的平方值的中间几位作为散列地址<ul>
<li>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀。</li>
<li>适用场景：关键字的每位取值都不够均匀。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>处理冲突的方法<ul>
<li>开放定址法：如果发生冲突，就给新元素找另一个空闲的位置<ul>
<li>数学递推公式为：$H _ { i } = ( H ( k e y ) + d _ { i } ) \% m$（m为散列表表长）</li>
<li>其中$d_{i}$为增量序列（偏移量），通过四种方法可以进行选择</li>
<li>采用“开放定址法”时，删除元素不能简单地将被删元素的空间置为空，<br>否则将截断在它之后的探测路径，可以做一个“已删除”标记，<strong>进行逻辑删除</strong>。</li>
<li>理想情况下，若散列表表长=m,则最多发生m-1次冲突即可“探测”完整个散列表。</li>
<li>线性探测法<ul>
<li>$d_{i}=0,1,2,3……m-1$</li>
<li>可以探测到散列表的每一个地址，但是容易造成大量元素在相邻的散列地址上聚集，大大降低查找效率</li>
<li>堆积问题是由于同义词之间或非同义词之间发生冲突导致的</li>
<li><strong>当从散列表中删除一个记录时，不应将这个记录的所在位置置为空，因为这将会影响后面的查找，逻辑删除即可</strong></li>
</ul>
</li>
<li>平方探测法（又称为二次探测法）<ul>
<li>${d_{i}=0^{2}, 1^{2},-1^{2}, 2^{2},-2^{2}, \ldots, k^{2},-k^{2}}$。 其中${k \leq m / 2}$</li>
<li>采用平方探测法，至少可以探测到散列表中一半的位置，即便散列表中有空闲位置，也未必能插入成功</li>
<li>若散列表长度m是一个可以表示成4k+3的素数(如7、11、19)，平方探测法就能探测到所有位置</li>
<li>可以有效避免堆积的问题</li>
</ul>
</li>
<li>双散列法<ul>
<li>${d_{i}=\mathbf{i} \times \operatorname{hash}_{2}(k e y)}$</li>
<li>双散列法未必能探测到散列表的所有位置。双散列法的探测覆盖率取决于第二个散列函数hash2(key)设计的是否合理。</li>
<li>若hash2(key)计算得到的值与散列表表长m互质，就能保证双散列发可以探测所有单元</li>
<li>令表长m本身就是质数，hash2(key)=m-(key%m)，此时无论key值是多少，hash2(key)和m一定互质</li>
</ul>
</li>
<li>伪随机序列法：d是一个伪随机序列，由程序员人为设计</li>
</ul>
</li>
<li>拉链法（链地址法）<ul>
<li>适用于经常进行插入和删除的情况</li>
<li>查找长度是指的查找时与相应关键字的对比次数</li>
<li>如此时要找40，此时需要在1处的链表查找4次，未能找到<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCqqPvd.png" alt="pCqqPvd.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>散列查找及性能分析<ul>
<li>先求得散列地址，在散列地址上已有关键字且与查找的关键字不同时，使用相关方法进行冲突处理。<br>若散列地址上没有关键字此时查找失败。若散列地址上的关键字与被查找关键字相等，此时查找成功，返回相应的地址</li>
<li>散列表的查找效率主要取决于：散列函数，处理冲突的方法和装填因子</li>
<li>装填因子a，定义为一个表的装满程度：$a=\frac{表中记录数n}{散列表长度m}$</li>
<li>散列表的平均查找长度依赖于散列表的装填因子$a$，而不直接依赖于n或m。<br>直观地看，$a$越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。</li>
<li>例题：求查找失败的平均查找长度就是查到表中的空地址时，即查找失败，此时虽然表中有序号为7的元素，<br>但是由于散列为7的余数，此时只会在0-6的范围内有相对应的地址，但是查询的时候会查到序号为8的地方。<ul>
<li><img src="https://s1.ax1x.com/2023/07/23/pCLSwHH.png" alt="pCLSwHH.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/23/pCLSDUA.png" alt="pCLSDUA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第六章-图</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="数据结构第六章-图"><a href="#数据结构第六章-图" class="headerlink" title="数据结构第六章 图"></a>数据结构第六章 图</h2><blockquote>
<p>计算机学科基础：数据结构第六章图的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-图的定义（✪）"><a href="#1-图的定义（✪）" class="headerlink" title="1.图的定义（✪）"></a>1.图的定义（✪）</h3><ul>
<li><p>定义</p>
<ul>
<li>图G由顶点集V和边集E组成，记为G=(V,E)</li>
<li>其中V(G)表示图G中顶点的有限非空集（称为图的阶）；E(G)表示图G中顶点之间的关系（边）集合。</li>
<li>图不能是空图，顶点集不能为空，但是边集可以为空</li>
<li><strong>对于一个具有n个顶点和e条边的图，若采用边集数组表示，则边集数组中的单元数至少为2e个</strong></li>
</ul>
</li>
<li><p>一些关于图的概念</p>
<ul>
<li>无向图：若E是无向边（简称边）的有限集合时，则图G为无向图。边是顶点的无序对，记为(v,w)或(w,v)。</li>
<li>有向图：若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是项点的有序对，记为<v,w>，<br>其中v,w是顶点，v称为弧尾，w称为弧头，<y,w>称为从v到w的弧，也称v邻接到w。</y,w></v,w></li>
<li>简单图、多重图：不存在重复边且不存在顶点到自身的边，则图G即为简单图，否则为多重图</li>
<li>度<ul>
<li>对于无向图，顶点v的度是指依附于顶点v的边的条数，<br><strong>无向图的全部顶点的度的和等于边数的两倍（无向图所有顶点的度之和为偶数）</strong></li>
<li>对于有向图，顶点v的度分为入度和出度，<strong>有向图的全部顶点的入度之和与出度之和相等，并且等于边数。</strong></li>
<li>例题<ul>
<li>此时直接利用相关的关系，所有顶点的度数之和等于边数量的两倍（4*5+3*4+2<em>(n-9)=23\</em>2）选D<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIG4Ln.png" alt="pCIG4Ln.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>路径与回路<ul>
<li>路径：由顶点和相邻顶点序偶构成的边所形成的序列<ul>
<li>注意：由不同顶点所形成的序列不是路径的定义</li>
</ul>
</li>
<li>回路（环）：第一个顶点和最后一个顶点相同的路径称为回路或环<ul>
<li><strong>有n个顶点和n条边的无向图一定是有环的</strong></li>
<li><strong>如果有向图中存在拓扑排序，则其一定是无环的</strong></li>
</ul>
</li>
<li>简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。<ul>
<li>最短路径一定是简单路径</li>
</ul>
</li>
<li>简单回路：除第一个项点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</li>
<li>路径长度：路径上边的数目</li>
<li>点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。<br>若从u到v根本不存在路径，则记该距离为无穷(∞)。</li>
</ul>
</li>
<li>连通与强连通<ul>
<li>无向图中，若从项点v到项点w有路径存在，则称顶点v和顶点w之间是连通的</li>
<li>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的<strong>（可以去和回）</strong></li>
</ul>
</li>
<li>连通图与强连通图<ul>
<li>连通图：任意两个顶点之间都是连通的无向图，则称为连通图否则为非连通图。<ul>
<li><strong>对于n个顶点的无向图G，若G是连通图，则最少有n-1条边</strong><ul>
<li>注意理解：是G为连通图可以推导出该无向图至少有n-1条边</li>
<li>此题选D<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIJKFf.png" alt="pCIJKFf.png"></li>
</ul>
</li>
<li>此题选D，这时肯定构成了回路，但是不一定是连通图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI1Bq0.png" alt="pCI1Bq0.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>若其为非连通图无向图，则最多可能有$\frac {n ( n - 1 ) } {2} $条边</strong><ul>
<li>如果出现由n-1个完全无向图与另外一个单独顶点的极端情况，此时只需加1，<br>则可以确保这n个顶点可以构成无向连通图<ul>
<li>本题即为（5*4）/2+1=11，选D<img src="https://s1.ax1x.com/2023/07/16/pCIGGa6.png" alt="pCIGGa6.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>强连通图：任意一对顶点之间都是强连通的有向图。<ul>
<li><strong>对于n个顶点的有向图G，若其为强连通图，则最少有n条边（形成回路）</strong></li>
</ul>
</li>
</ul>
</li>
<li>连通分量与强联通分量<ul>
<li>连通分量：无向图的极大连通子图（<strong>必须连通且尽可能包含更多的顶点和边</strong>）<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIKLDK.png" alt="pCIKLDK.png"></li>
</ul>
</li>
<li>强连通分量：有向图的极大强连通子图（<strong>必须强连通且尽可能包含更多的边</strong>）<ul>
<li>注：若一个图存在环，则其一定<strong>含有</strong>顶点数大于1的强连通分量</li>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIKOHO.png" alt="pCIKOHO.png"></li>
</ul>
</li>
</ul>
</li>
<li>子图与生成子图<ul>
<li>设有两个图G=(V,E)和G1=(V1,E1),若V1是V的子集，且E1是E的子集，则称G1是G的子图。<ul>
<li>此时需要V1和E1先相互对应，即构成了图。如下面的描述错误<img src="https://s1.ax1x.com/2023/07/16/pCI3ffg.png" alt="pCI3ffg.png"></li>
</ul>
</li>
<li>若有满足V(G)=V(G1)的子图G,则称其为G的生成子图。<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIKRBT.png" alt="pCIKRBT.png"></li>
</ul>
</li>
</ul>
</li>
<li>生成树与生成森林<ul>
<li>连通图的生成树是包含图中全部顶点的一个极小连通子图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIMCvt.png" alt="pCIMCvt.png"></li>
</ul>
</li>
<li>生成森林<ul>
<li>非连通图中，连通分量的生成树构成了非连通图的生成森林<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIMFDf.png" alt="pCIMFDf.png"></li>
</ul>
</li>
</ul>
</li>
<li>边的权、带权图（网）<ul>
<li>边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</li>
<li>带权图/网：边上带有权值的图称为带权图，也称网。</li>
<li>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</li>
</ul>
</li>
</ul>
</li>
<li>几种特殊的图<ul>
<li>完全图<ul>
<li>无向完全图：无向图中任意两个顶点之间都存在边，共有条$\frac {n ( n - 1 ) } {2} $边</li>
<li>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，共有$n(n-1)$条边</li>
<li><strong>讨论拥有n个顶点的无向图需要多少条边才能确保形成一个连通图，</strong><br><strong>此时常常考虑为由n-1个顶点之间形成的完全无向图与另外一个单独结点的组合时，再添加一条边，使这两部分相连。</strong></li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI8Obt.png" alt="pCI8Obt.png"></li>
</ul>
</li>
</ul>
</li>
<li>树：不存在回路，且连通的无向图，n个顶点的树，必有n-1条边。n个顶点的图，若边大于n-1,则一定有回路</li>
<li>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-图的存储（✪）"><a href="#2-图的存储（✪）" class="headerlink" title="2.图的存储（✪）"></a>2.图的存储（✪）</h3><ul>
<li><p>邻接矩阵法（二维数组实现的顺序存储方式✪）</p>
<ul>
<li><p>使用邻接矩阵存储，是指用一个一维数组存储图中项点的信息，<br>用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100 	<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum]; 	<span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; 	<span class="comment">//临接矩阵，存放边的关系</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum; 		<span class="comment">//图的当前顶点数和边数、弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接矩阵存储有向图与无向图</p>
<ul>
<li>值为1时边之间有关系，为0时无关系</li>
<li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。（只需存储上下三角矩阵的元素）</li>
<li>对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是顶点的度数</li>
<li>对于有向图，邻接矩阵的第i行非零元素的个数正好是顶点i的出度，第i列非零元素的个数正好是顶点i的入度</li>
<li>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(n)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI0HFs.png" alt="pCI0HFs.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>邻接矩阵存储带权图</p>
<ul>
<li>∞元素和0元素表示两边之间不邻接，非零数表示相应的权值</li>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIB1pt.png" alt="pCIB1pt.png"></li>
</ul>
</li>
<li><p>邻接矩阵的相关性质</p>
<ul>
<li><strong>邻接矩阵表示法的空间复杂度为O($n^{2}$),其中n为图的顶点数。</strong></li>
<li><strong>稠密图适合使用邻接矩阵的存储表示。</strong></li>
<li><strong>邻接矩阵关于利用矩阵乘法计算路径条数的的重要性质</strong><ul>
<li>矩阵的平方相当于求路径长度为2的路径条数：此时从B到B路径长度为2的路径条数为3<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIBakj.png" alt="pCIBakj.png"></li>
</ul>
</li>
<li>矩阵的立方相当于求路径长度为3的路径条数，此时从B到C路径长度为3的路径条数为4<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIBD10.png" alt="pCIBD10.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>邻接表法（顺序+链式存储✪）</p>
<ul>
<li>对图G中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点$v_{i}$的边(对于有向图则是以顶点为尾的弧)，<br>这个单链表就称为顶点$v_{i}$的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表）</li>
<li>顶点表结点由顶点域(data)和指向第一条邻接边的指针(firstarc)构成，<br>边表（邻接表）结点由邻接点域(adivex)和指向下一条邻接边的指针域(nextarc)构成。</li>
<li>图片<ul>
<li>存储无向图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCI2btS.png" alt="pCI2btS.png"></li>
</ul>
</li>
<li>存储有向图<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIRrcj.png" alt="pCIRrcj.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li><strong>若G为无向图，则所需的存储空间为O(V+2E)</strong>，<strong>若G为有向图，则所需的存储空间为O(V+E)</strong>。<br>前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。（n个顶点的无向图的邻接表最多含有n(n-1)个边表顶点）</li>
<li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li>
<li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。<ul>
<li>在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)</li>
<li>如果要确定两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li>
</ul>
</li>
<li>在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数，<br>但求其顶点的入度则需要遍历全部的邻接表（<strong>在有向图的邻接表中，顶点v在边表的出现次数等于顶点v的入度</strong>）</li>
<li>图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，<br>它取决于建立邻接表的算法及边的输入次序。</li>
</ul>
</li>
<li>邻接表与邻接矩阵的对比<ul>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIRw4S.png" alt="pCIRw4S.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>十字链表（只能用于存储有向图）</p>
<ul>
<li>空间复杂度为O(V+E)，此时要找顶点的出边顺着绿色路线，要找入边顺序橙色路线。</li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoFIu4.png" alt="pCoFIu4.png"></li>
</ul>
</li>
<li><p>邻接多重表（只能用于存储无向图）</p>
<ul>
<li>空间复杂度为O(V+E)，删除边和顶点很方便</li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoAAoR.png" alt="pCoAAoR.png"></li>
</ul>
</li>
</ul>
<h3 id="3-图的遍历（选择题考点，代码了解即可✪）"><a href="#3-图的遍历（选择题考点，代码了解即可✪）" class="headerlink" title="3.图的遍历（选择题考点，代码了解即可✪）"></a>3.图的遍历（选择题考点，代码了解即可✪）</h3><ul>
<li><p>定义：图的遍历是从图的某一顶点出发，按照某种搜索方法沿着图中的边对图的所有顶点访问一次且仅访问一次。</p>
</li>
<li><p>广度优先搜索（BFS）</p>
<ul>
<li>特点<ul>
<li><strong>与二叉树的层序遍历完全一致，都是利用队列进行遍历操作，出队时将其相邻元素入队</strong><br>（使用数组标记已经入队的顶点不用在入队）</li>
<li>同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一</li>
<li>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</li>
<li>空间复杂度最坏情况下为：O(V)</li>
</ul>
</li>
<li>要点<ul>
<li>找到与一个顶点相邻的所有顶点</li>
<li>标记哪些顶点被访问过（visited数组）</li>
<li><strong>需要一个辅助队列，用队列来暂存刚访问过的结点</strong></li>
</ul>
</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoeoDO.png" alt="pCoeoDO.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoef81.png" alt="pCoef81.png"></li>
</ul>
</li>
<li>时间复杂度分析<ul>
<li>采用邻接表时<ul>
<li>访问 |V| 个顶点需要O(|V|)的时间 </li>
<li>查找各个顶点的邻接点共需要O(|E|)的时间, 时间复杂度${=O(|V|+|E|)}$</li>
</ul>
</li>
<li>采用邻接矩阵时<ul>
<li>访问${|\mathbf{V}|}$个顶点需要${O(|\mathbf{V}|)}$的时间</li>
<li>查找每个顶点的邻接点都需要${O(|V|)}$的时间, 而总共有${|\mathbf{V}|}$个顶点的时间复杂度${=O\left(|V|^{2}\right)}$</li>
</ul>
</li>
</ul>
</li>
<li>广度优先生成树<ul>
<li>同一个图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，<br>但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。</li>
<li><img src="https://s1.ax1x.com/2023/07/17/pConPOK.png" alt="pConPOK.png"></li>
</ul>
</li>
</ul>
</li>
<li>深度优先搜索（DFS）<ul>
<li>特点：<strong>与树的先序遍历类似，采用根左右的顺序，需要借助于栈，最坏的空间复杂度为O(V)</strong></li>
<li>要点：此时不需要队列，但是需要借助于函数调用栈以及标记哪些顶点被访问过的visited数组</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pColTSJ.png" alt="pColTSJ.png"></li>
</ul>
</li>
<li>时间复杂度分析<ul>
<li>采用邻接矩阵：查找每个顶点的邻接点所需的时间为${O(| V|)}$，故总的时间复杂度为${O\left(| V^{2}\right)}$。</li>
<li>采用邻接表：查找所有顶点的邻接点所需的时间为${O(|E|)}$, 访问顶点所需的时间为${O(|V|)}$,<br>此时, 总的时间复杂度为${O(|V|+|E|)}$。</li>
</ul>
</li>
<li>利用邻接表找出深度优先遍历的顺序<ul>
<li>此时的具体方法是，首先找到开始的顶点的那条链，遍历一个之前没有遍历到的元素时，从此元素的链继续开始遍历，<br>如果此链遍历完成，那么退回上一个链继续进行上述有关操作。<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo1MXn.png" alt="pCo1MXn.png"></li>
</ul>
</li>
</ul>
</li>
<li>深度优先生成树<ul>
<li>同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一</li>
<li>同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</li>
</ul>
</li>
</ul>
</li>
<li>图的遍历与图的连通性<ul>
<li>对于无向图遍历调用BFS/DFS函数的次数<ul>
<li>若其为连通的，只需要一次遍历即可</li>
<li><strong>若其为非连通的，此时的遍历次数为其连通分量的数量。</strong></li>
</ul>
</li>
<li>对于有向图遍历调用BFS/DFS函数的次数<ul>
<li>此时情况不确定，若起始顶点到其他各顶点都有路径，则只需调用次1BFS/DFS函数</li>
<li>对于强连通图，从任一结点出发都只需调用1次BFS/DFS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-图的应用（✪）"><a href="#4-图的应用（✪）" class="headerlink" title="4.图的应用（✪）"></a>4.图的应用（✪）</h3><ul>
<li><p>求最小生成树问题（✪）</p>
<ul>
<li>最小生成树的概念<ul>
<li>对于一个<strong>带权连通无向图</strong>G=(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。<br>若T为R中边的权值之和最小的那棵生成树，则T称为G的最小生成树(Minimum-Spanning-Tree,MST)。</li>
<li><strong>最小生成树可能不是唯一的，树形可能不唯一（因为图中可能存在权值相等的边）</strong><ul>
<li>只要无向连通图中没有权值相同的边，则其最小生成树唯一，此说法正确</li>
<li>只要无向连通图中有权值相同的边，则其最小生成树一定不唯一，此说法错误<br>（此时若无向图本身就是一颗树，则最小生成树就是其本身，此时唯一）</li>
</ul>
</li>
<li><strong>最小生成树的边的权值之和总是唯一的（代价唯一且最小）</strong></li>
<li>最小生成树的边数为顶点数量减一</li>
<li>最小生成树的算法基于贪心算法的策略</li>
</ul>
</li>
<li>Prim算法<ul>
<li>概述：从某一个顶点开始构建生成树，之后选择一个与当前树中的集合距离最近的顶点纳入生成树，<br>直到所有顶点都纳入为止。</li>
<li>此时若顶点数量为n，则此时生成的最小生成树的边数为n-1</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo6e4e.png" alt="pCo6e4e.png"></li>
</ul>
</li>
<li>普里姆算法的特点<ul>
<li>时间复杂度：O($V^{2}$)，只与顶点有关，不依赖于边</li>
<li>适合求解边稠密图的最小生成树</li>
</ul>
</li>
</ul>
</li>
<li>kruskal算法<ul>
<li>概述：按边来构建最小生成树，每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）<br>直到所有结点都连通</li>
<li>图片：如此图中，第二次选择的边为权值最小的边，权值为2<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo6dvn.png" alt="pCo6dvn.png"></li>
</ul>
</li>
<li>克鲁斯卡尔算法的特点<ul>
<li>时间复杂度：O($|E|log_{2}E$)，只与边的数量有关，与顶点的数量无关</li>
<li>适合求边稀疏图而顶点多的图的最小生成树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求最短路径问题（✪）</p>
<ul>
<li><p>最短路径的定义</p>
<ul>
<li>从一个顶点到图中其余任意一个顶点的一条路径（可能不止一条）所经过边上的权值之和，<br>定义为该路径的（带权）路径长度，（带权）路径长度最短的称为最短路径</li>
<li>最短路径一定是简单路径</li>
</ul>
</li>
<li><p>求单源最短路径（分为有权图和无权图的求法）</p>
<ul>
<li><p>BFS(广度优先)算法求<strong><u>无权图</u></strong>的单源最短路径问题（无权图相当于每一条边的权值都为1）</p>
<ul>
<li><p>概述：就是对广度优先搜索的小修改，在visit访问一个顶点时，修改其最短路径长度d【】并在path【】记录前驱结点</p>
</li>
<li><p>代码实现</p>
<ul>
<li><strong>由顶点2开始时，2到8的最短路径长度=d[8]=3，通过path数组可知，2到8的最短路径为：8&lt;一7&lt;一6&lt;一2</strong></li>
<li><img src="https://s1.ax1x.com/2023/07/17/pCogyp4.png" alt="pCogyp4.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>Dijkstra算法求<strong><u>有权图</u></strong>单源最短路径问题</p>
<ul>
<li>概述<ul>
<li><strong>首先需要设置三个数组（与起始顶点相邻的点的最短路径长度修改为边上的权值，并修改路径前驱为起始点，</strong><br><strong>其余的都设置为最短路径长度为无穷（起始点自身的最短路径长度设置为0），路径前驱为-1）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRPPO.png" alt="pCoRPPO.png"></li>
</ul>
</li>
<li><strong>第一轮：循环遍历所有顶点，优先选择还没有确定最短路径长度并且此时的最短路径长度最小的点进行修改，</strong><br><strong>此时此点为V4，将final值设置为true。并且再进行对其它相邻点的遍历，</strong><br><strong>此时V1需要变动（最短路径长度修改为8，路径前驱修改为4，但是这个时候还不能修改其标志位）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRwJU.png" alt="pCoRwJU.png"></li>
</ul>
</li>
<li><strong>第二轮，在V4遍历完成以后，此时应该开始优先遍历第二个最短路径长度最小的顶点V3，</strong><br><strong>V3修改其标志位，在V3处可以将V2的最短路径的值修改为13，此时前驱变为V3。</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRfJO.png" alt="pCoRfJO.png"></li>
</ul>
</li>
<li><strong>第三轮，在V3遍历完成之后，选择V1进行遍历，此时修改其标志位，</strong><br><strong>并且此时可以修改V2的最短路径长度为9，并将其前驱改变为V3.</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCoRqTP.png" alt="pCoRqTP.png"></li>
</ul>
</li>
<li><strong>求最短路径的长度时，即为dist数组中的值，求最短路径经过的顶点序列时，根据path数组的值往前推出</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTbyAe.png" alt="pCTbyAe.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li><strong>时间复杂度为O(|$V^{2}$|)</strong></li>
<li>不适用于边上带有负权值的图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Floyd算法求各<u><strong>顶点之间</strong></u>最短路径问题</p>
<ul>
<li>概述：使用的是动态规划的思想，通过设置中转点依次来求解，<br>此时需要两个矩阵（一个表示最短路径，另一个表示中转点）</li>
<li>特点<ul>
<li><strong>时间复杂度为O($V^{3}$)</strong></li>
<li>可以用于计算负权值带权图的计算，但是不适用于带有“负权回路”的图（有负权值的边组成回路），这种图有可能没有最短路径</li>
</ul>
</li>
<li><strong>最短路径的表中首先把存在直接联系的的路径长度写上，之后将中转点矩阵中的值均设为-1</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4AtP.png" alt="pCo4AtP.png"></li>
</ul>
</li>
<li><strong>之后规定可以将V0作为中转点，按照表格依次进行遍历，需要满足两个顶点之间经过此中转点之后的路径长度小于原来的长度。此时v2到v1的路径可以修改为11，并且中转矩阵所对应的相关值修改为中转点0</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo43t0.png" alt="pCo43t0.png"></li>
</ul>
</li>
<li><strong>遍历完成后，之后规定可以将V1,V0作为中转点，此时可以修改v0到v2的相关值</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4w7R.png" alt="pCo4w7R.png"></li>
</ul>
</li>
<li><strong>最后将v0、v1、v2均设置为中转点，此时可以将v1到v0的相关值进行修改</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4Dtx.png" alt="pCo4Dtx.png"></li>
</ul>
</li>
<li>代码实现<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo4T9f.png" alt="pCo4T9f.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>三种求最短路径的算法之间的差异</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/17/pCo593T.png" alt="pCo593T.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>求有向无环图描述表达式问题（DAG图，了解）</p>
<ul>
<li>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图(Directed Acyclic Graph)</li>
<li><p>有向无环图可以描述含有公共子式的表达式。并可将重复出现的子表达式共享，节省存储空间</p>
</li>
<li><p>解题思路</p>
<ul>
<li>首先根据规则先画好基本的有向无环图<ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTGNzF.png" alt="pCTGNzF.png"></li>
</ul>
</li>
<li>之后逐层的合体相同的运算符（该层的运算符的两个指向边都分别对应到相同的元素就合并）<ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTGWsH.png" alt="pCTGWsH.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求拓扑排序问题（主要是会手算✪）</p>
<ul>
<li>AOV网 （一种有向无环图）<ul>
<li><strong><u>顶点</u>表示活动的网络的有向图</strong>，有向边${<V_{i},V_{j}>}$表示活动${V_{i}}$必须先于活动${V_{j}}$进行</V_{i},V_{j}></li>
</ul>
</li>
<li>拓扑排序：找到做事的先后顺序（<strong>同时可以判断图中是否存在回路</strong>）<ul>
<li>拓扑排序的特点（当且仅当满足以下的条件时）<ul>
<li>每个顶点出现且只出现一次</li>
<li>若顶点A在序列中排在顶点B的前面，则在图中不存在从J顶点B到顶点A的路径。</li>
</ul>
</li>
<li>拓扑排序的流程<ul>
<li>从AOV网中选择一个没有前驱(入度为0)的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为起点的有向边。</li>
<li>重复之前的操作直到当前的AOV网为空或当前网中不存在无前驱的顶点（说明此时存在回路）为止。</li>
</ul>
</li>
<li>拓扑排序算法代码实现（DFS(深度优先遍历)也可以得出相应的拓扑排序序列，了解）<ul>
<li><strong>建立两个数组，分别表示当前顶点的入度情况以及记录生成拓扑的序列，<br>且用一个栈保存度为0的待处理顶点，也可以用队列</strong><br><strong>首先填写入度表中的各顶点的值，并将有向无序图中入度为0的点依次入栈，该图中有两个顶点0、2可依次入栈</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTYbrQ.png" alt="pCTYbrQ.png"></li>
</ul>
</li>
<li><strong>之后首先弹出栈顶的顶点2，将拓补序列的第一号位修改为2并移动计数指针（序列的第一号即为2）</strong><br><strong>，此时将2的后继结点“3、4”的入度减一，由于此时3、4的入度还不为0，因此暂时不能入栈）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTtZPx.png" alt="pCTtZPx.png"></li>
</ul>
</li>
<li><strong>按照上述过程，此时再将栈顶的顶点0弹出，此时顶点1的入度减一，作为入度为0的顶点入栈，</strong><br><strong>之后依次类推，最后的拓扑顺序为：2、0、1、3、4</strong></li>
<li><strong>进行如果最后的计数指针的数量等于顶点数，此时就得到了相应的拓扑排序序列，</strong><br><strong>否则说明有向无序图中存在环路，无法进行排序，不是AOV网</strong></li>
</ul>
</li>
<li><strong>时间复杂度：采用邻接表时为${O(|V|+|E|)}$，若采用邻接矩阵, 则需${O\left(|V|^{2}\right)}$</strong></li>
</ul>
</li>
<li><strong>逆拓扑排序则是以没有出度的顶点开始排序，此时可以使用DFS(深度优先遍历)的算法进行操作得出逆拓扑排序序列，</strong><br><strong>此时在顶点退栈前输出序列</strong></li>
<li>拓扑排序算法的相关注意事项<ul>
<li><strong>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</strong></li>
<li><strong>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一（但是也不是绝对的，如下面的例题中有经典的反例）</strong></li>
<li>若各个顶点已经排在一个<strong>线性有序</strong>的序列中，每个顶点有<strong>唯一的前驱后继</strong>关系，则拓扑排序的结果是唯一的<ul>
<li>判断：若有向无环图的拓扑序列唯一，则可以唯一确定此图（X），可举出下面的反例<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTLOmV.png" alt="pCTLOmV.png"></li>
</ul>
</li>
</ul>
</li>
<li>由于AOV网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，<br>生成AOV网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵</li>
<li><strong>但对于一般的图来说，若其邻接矩阵是三角矩阵（不存在环），则存在拓扑序列，反之则不一定成立。</strong><ul>
<li>反之成立的条件是此有向图的拓扑排序序列是有序的</li>
</ul>
</li>
</ul>
</li>
<li>例题<ul>
<li>例题1：本题选D，此时可以举出一个经典的反例如下图<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTL3i4.png" alt="pCTL3i4.png"><ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTLsWd.png" alt="pCTLsWd.png"></li>
</ul>
</li>
</ul>
</li>
<li>例题2：此题选D，此时不能排成一个拓扑序列说明该图中存在环，AC选项用一个三角形环就可以排除；<br>对于B选项，连通图是指需要任意两个端点之间可以互相到达的图，如果此时用一个三角形环外加从外面指向一个单独顶点的线，<br>此时该单独顶点无法到达其它顶点，故不是强连通图。只有D满足相关的情况<ul>
<li>若一个有向图的顶点不能排成一个拓扑序列（即存在环路），则可以判定该有向图<strong>含有</strong>顶点数大于1的强连通分量。<br>这是因为环路中的顶点构成了至少一个强连通分量，并且强连通分量中的顶点数大于1。</li>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTO4nx.png" alt="pCTO4nx.png"></li>
</ul>
</li>
<li>例题3，找到拓扑排序的所有序列，用逐次列举的方法来找，不用去考虑机算方法，可以通过画圈辅助判断<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTvBnI.png" alt="pCTvBnI.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求关键路径问题（✪）</p>
<ul>
<li>AOE网概念（一种有向无环图）<ul>
<li>在带权有向图中, <u>以顶点表示事件</u>, <strong>以有向边表示活动</strong>，以边上的权值表示完成该活动的开销（如完成活动所需的时间），<br>称之为<strong>用边表示活动的网络</strong>,简称AOE网 (Activity On Edge NetWork)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/18/pCTUdEj.png" alt="pCTUdEj.png"></li>
</ul>
</li>
</ul>
</li>
<li>AOE网的两个性质<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li>
<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。<br>另外，有些活动是可以并行进行的</li>
</ul>
</li>
<li>源点与汇点<ul>
<li>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始；</li>
<li>也仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。</li>
</ul>
</li>
<li>关键路径与关键活动（<strong>求关键路径是以拓扑排序为基础的</strong>）<ul>
<li><strong>从源点到汇点的有向路径可能有多条，所有路径中，具有<u>最大路径长度</u>的路径称为关键路径</strong></li>
<li><strong>关键路径上的活动称为关键活动，它是决定整个工程的关键因素</strong></li>
<li><strong>完成整个工程的最短时间就是关键路径的长度（关键路径上各活动花费开销的总和），</strong><br><strong>若关键活动不能按时完成，则整个工程的完成时间就会延长（在关键路径上的活动的时间延长多少，整个工程的时间也就随之延长多少）</strong></li>
<li><strong>可以通过加快关键活动（减少关键活动的时间）来缩短整个工程的工期。</strong><br><strong>但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</strong></li>
<li><strong>网络图的关键路径并不唯一，且对于有几条关键路径的网，</strong><br><strong>缩短关键路径上任意一个或多个只包括在一条关键路径的关键活动的持续时间并不能缩短关键路径的长度，</strong><br><strong>需要缩短那些包括在<u>所有</u>关键路径上的关键活动的持续时间才能缩短关键路径的长度。</strong><ul>
<li>关于缩短关键路径长度的例题<ul>
<li>例题1，本题选择C，对于关键路径长度来说，增加是可以增大关键路径长度的，<br>但是缩短需要在一定的条件下才能缩短关键路径长度<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTomM8.png" alt="pCTomM8.png"></li>
</ul>
</li>
<li>例题2，本题选择C，该题的关键路径经过计算得出为：b,d,c,g；b,d,e,h；b,f,h。<br>此时只有C选项的f与d可以同时作用到三条关键路径上，其它的选项只能作用到其中的一条或两条。<ul>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTonsS.png" alt="pCTonsS.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>求关键路径与关键活动以及相关的参数（<strong>求关键路径同时也可以判断图中是否存在回路</strong>）<ul>
<li>注意区别事件(顶点)的最早/最迟开始时间与活动(弧)的最早/最迟开始时间。<ul>
<li>时间余量=下一个顶点的最迟开始时间-活动持续时间—起始顶点的最早开始时间</li>
<li>顶点（事件）的最迟开始时间等于=起始顶点的最早开始时间+时间余量</li>
<li>弧（活动）的最早开始时间等于：弧的起始顶点的最早开始时间</li>
<li>弧（活动）的最迟开始时间等于：下一个顶点的最迟发生时间—该活动的持续时间</li>
</ul>
</li>
<li><img src="https://s1.ax1x.com/2023/07/19/pCTHwdg.jpg" alt="pCTHwdg.jpg"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第五章-树与二叉树</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h2><blockquote>
<p>计算机学科基础：数据结构第五章树与二叉树学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-树的基本概念（✠）"><a href="#1-树的基本概念（✠）" class="headerlink" title="1.树的基本概念（✠）"></a>1.树的基本概念（✠）</h3><ul>
<li><p>①树的定义：</p>
<ul>
<li>树是n(n≥0)个结点的有限集，是一种递归定义的数据结构。当n=0时，称为空树。</li>
<li>在任意一棵非空树中应满足<ul>
<li>有且仅有一个特定的称为根的结点。</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2……Tm<br>其中每个集合本身又是一棵树，并且称为根的子树。</li>
</ul>
</li>
</ul>
</li>
<li><p>②树的基本术语</p>
<ul>
<li>结点的关系图谱：祖先、子孙、双亲（父节点）（根结点是唯一没有双亲的结点）<br>孩子、兄弟（有相同双亲的结点）、堂兄弟（同一层非同父节点）</li>
<li>路径和路径长度。<ul>
<li>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数；</li>
<li>树的路径长度是从树根到每个结点的路径长度的<u>总和</u>（路径只能是由上往下的，同一层之间不存在路径）</li>
</ul>
</li>
<li>结点的深度、层次（从上往下数）；结点的高度（从下往上数）；树的高度（或深度）是树中结点的最大层数</li>
<li>度：<strong>一个结点的孩子个数</strong>；<br>树的度：树中结点的最大度数<ul>
<li>如度为4的树：存在某结点至少有4个孩子结点（而不是至少在某一层正好有4个结点）</li>
<li>度大于0：分支节点（每个结点的分支数就是该结点的度）</li>
<li>度等于0：叶子节点</li>
</ul>
</li>
<li>有序树与无序树（从左到右有无次序）</li>
<li>森林：森林是m(m≥0)棵互不相交的树的集合</li>
</ul>
</li>
<li>③树的性质（选择题考点✪）<ul>
<li>树的结点数=总度数+1（总度数也等于分支数）<ul>
<li>例，此题选B，由总度数+1=结点数，叶子结点个数=总度数-其它非叶子结点的结点个数<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWf6u6.png" alt="pCWf6u6.png"></li>
</ul>
</li>
</ul>
</li>
<li>区分度为m的树和m叉树<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWcsPI.png" alt="pCWcsPI.png"></li>
</ul>
</li>
<li>度为m的树第i层最多有$m^{i-1}$个结点(i≥1)；m叉树第i层最多有$m^{i-1}$个结点 (i≥1)</li>
<li>高度为h的m叉树最多有$\frac{m^{h}-1}{m-1}$个结点（由等比数列求和公式得）</li>
<li>高度为h的m叉树最少有h个结点；高度为h，度为m的树最少有h+m-1个结点<ul>
<li>此时也可以反过来说，度为m，结点数为n的树，高度最多为n-m+1</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCW2f4s.png" alt="pCW2f4s.png"></li>
</ul>
</li>
</ul>
</li>
<li>具有n个结点的m叉树（或度为m）的最小高度为    $\left\lceil\log _{m}(n(m-1)+1)\right\rceil$<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWR9KK.png" alt="pCWR9KK.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-二叉树（✪）"><a href="#2-二叉树（✪）" class="headerlink" title="2.二叉树（✪）"></a>2.二叉树（✪）</h3><ul>
<li><p>①二叉树的定义</p>
<ul>
<li>二叉树是n(n≥0)个结点的有限集合，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）</li>
<li>或者为空二叉树，即n=0</li>
<li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。<br>左子树和右子树又分别是一棵二叉树（二叉树是有序树，左右次序不能颠倒）</li>
</ul>
</li>
<li><p>②特殊的二叉树</p>
<ul>
<li>满二叉树<ul>
<li>一棵高度为h，且含有$2^{h}-1$个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点</li>
<li>满二叉树的叶结点都集中在二叉树的最下一层，并且除叶结点之外的每个结点度数均为2，不存在度为1的结点</li>
<li>按层序从1开始编号，结点ⅰ的左孩子为2i，右孩子为2i+1，结点i的父节点 ⌊i/2⌋（如果有的话）</li>
</ul>
</li>
<li>完全二叉树<ul>
<li>高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</li>
<li>若i ≤ ⌊n/2⌋，则结点i为分支结点，否则为叶结点。</li>
<li><strong>若一棵完全二叉树中的结点无左孩子，则其必是叶节点</strong></li>
<li>叶结点只可能在层次最大的两层上出现。对于最大层次中的叶结点，都依次排列在该层最左边的位置上。</li>
<li>若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li>
<li>按层序编号后，一旦出现某结点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点。</li>
<li>若结点数n为奇数，则每个分支结点都有左孩子和右孩子；</li>
<li>若n为偶数，则编号最大的分支结点(编号为n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCfAsD1.png" alt="pCfAsD1.png"></li>
</ul>
</li>
</ul>
</li>
<li>二叉排序树<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字</li>
<li>右子树上的所有结点的关键字均大于根结点的关键字</li>
<li>左子树和右子树又各是一棵二叉排序树。</li>
<li><strong>将二叉排序树的<u>先序序列</u>中的关键字依次插入初始为空的树中，所得到的二叉排序树与原二叉排序树是相同的</strong></li>
</ul>
</li>
<li>平衡二叉树：树上任意一个结点的左子树和右子树的深度之差不超过1。<ul>
<li><strong>对于高度为n的平衡二叉树，最少需h(n)个结点，最多需要2n-1个结点。</strong></li>
<li><strong>h(n)=h(n-1)+h(n-2)+1</strong></li>
<li><strong>h(0)=0，h(1)=1，h(2)=2</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>③二叉树的性质（选择题考点♚）</p>
<ul>
<li><strong>非空二叉树上的叶结点数等于度为2的结点数加1，即$n_{0}=n_{2}+1$</strong><ul>
<li>可由$n=n_{0}+n_{1}+n_{2}$与$n=n_{1}+2n_{2}+1$得来</li>
</ul>
</li>
<li><strong>二叉树第i层上至多有$2^{i-1}$个结点(i≥1)</strong></li>
<li><strong>高度为h的二叉树至多有$2^{h}-1$个结点（满二叉树），最少有$2^{h-1}$个结点</strong></li>
<li><strong>具有n个${(n&gt;0)}$ 结点的完全二叉树的高度h为${\left\lceil\log _{2}(n+1)\right\rceil}$ 或 $\left\lfloor\log _{2} n\right\rfloor+1$</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfVgpD.png" alt="pCfVgpD.png"></li>
</ul>
</li>
<li><strong>第i个结点所在层次为${\left\lceil\log _{2}(n+1)\right\rceil}$ 或 $\left\lfloor\log _{2} n\right\rfloor+1$</strong></li>
<li>对于<strong>完全二叉树</strong>，可以由节点数推出各类结点的数量情况，分为结点总数n为奇数或偶数<ul>
<li>完全二叉树的度为1的结点数量最多为1，$n_{1}=1或0$</li>
<li>当n=2k时，此时$n_{1}=1,n_{0}=k,n_{2}=k+1$ <strong>（完全二叉树有偶数个结点时，叶子结点的个数为总结点数除以2）</strong></li>
<li>当n=2k-1时，此时$n_{1}=0,n_{0}=k,n_{2}=k+1$<strong>（有奇数个结点时，叶子结点的个数为总结点数+1再除以2）</strong></li>
<li>完全二叉树如果所有的非空结点都有两个子节点，说明其有奇数个结点，此时结点总数=2*叶子节点总数-1</li>
</ul>
</li>
<li>有关性质例题的考察<ul>
<li>例题1：这种题通过画出二叉树的情况来找规律即可，选B<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfxZ9I.png" alt="pCfxZ9I.png"></li>
</ul>
</li>
<li>例题2：给出完全二叉树具体一层的叶结点数量，求最多和最少得结点总数<br>（重要信息：完全二叉树的叶结点只有可能存在于最后一层和倒数第二层）<ul>
<li>结点数量最少时，该层即为最后一层，如此题为前五层满二叉树+8=39，</li>
<li>结点数量最多时，该层为倒数第二层，如此题为总七层-8*2=111</li>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfzZa4.png" alt="pCfzZa4.png"></li>
</ul>
</li>
<li>例题3：最小高度往往是满二叉树时，存放该二叉树至少需要的结点数量（最坏的情况，也为满二叉树时）分别选C、A<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pChSuTg.png" alt="pChSuTg.png"></li>
<li><a href="https://imgse.com/i/pChSmm8"><img src="https://s1.ax1x.com/2023/07/12/pChSmm8.png" alt="pChSmm8.png"></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>④二叉树的存储结构</p>
<ul>
<li><p>二叉树的顺序存储</p>
<ul>
<li><p>对于完全二叉树，顺序存储的结构较为合适，此时可以较好的反映出结点之间的逻辑关系，也能节省存储空间</p>
<ul>
<li><a href="https://imgse.com/i/pCfHGVI"><img src="https://s1.ax1x.com/2023/07/12/pCfHGVI.png" alt="pCfHGVI.png"></a></li>
</ul>
</li>
<li><p>对于一般的二叉树，需要用0来表示并不存在的空结点，以便于反映二叉树的逻辑结构，但是此时会浪费较多的存储空间</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCfHYIP.png" alt="pCfHYIP.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的链式存储</p>
<ul>
<li><p>又称为<strong>二叉链表</strong>，由数据域，左指针域，右指针域组成</p>
</li>
<li><p><strong>n个结点的二叉链表共有n+1个空链域，有n-1个非空链域</strong><br>链域是指左指针或右指针</p>
</li>
<li><p>关于三叉链表：再定义一个父指针指向父节点，方便查找（在后序线索树中可找到后序后继结点）</p>
</li>
<li><p>链式存储的代码实现</p>
<ul>
<li><p>定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化以及插入节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BiTree root=<span class="literal">NULL</span>; <span class="comment">//定义一颗空树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root-&gt;data=<span class="number">1</span>;</span><br><span class="line">root-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchlid=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p=(BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data=<span class="number">2</span>;</span><br><span class="line">p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild=p; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-二叉树的遍历（✪）"><a href="#3-二叉树的遍历（✪）" class="headerlink" title="3.二叉树的遍历（✪）"></a>3.二叉树的遍历（✪）</h3><ul>
<li><p>三种基本遍历</p>
<ul>
<li><p>如中序遍历，先递归遍历左子树，再访问根节点，再递归遍历右子树，二叉树为空则什么都不做。</p>
</li>
<li><p>这三种遍历方法的时间复杂度都是O(n)，每个结点都会被访问一次</p>
</li>
<li><p><strong>二叉树的前中后序遍历中，所有叶节点的顺序完全相同</strong></p>
</li>
<li><p><strong>若一个二叉树的先序和后序序列正好相反，则该二叉树的高度等于结点数，只有一个叶节点</strong></p>
</li>
<li><p>先序序列与中序序列的关系相当于，以先序序列为入栈次序，以中序队列为出栈次序</p>
</li>
<li><p>先序序列为a,b,c,d，求不同二叉树的个数（使用卡特兰数的公式$\frac{1}{n+1}C^{n}_{2n}$）</p>
</li>
<li><p>可用递归子树思想的方法来求出遍历次序</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pChpkEF.png" alt="pChpkEF.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>先序遍历（NLR，根左右）<br>在前序遍历的二叉树中，任何结点的子树的所有结点都是直接跟在该结点的之后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     visit(T);</span><br><span class="line">     preOrder(T-&gt;lchild);</span><br><span class="line">     preOrder(T-&gt;rchild);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历（LNR，左根右）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     InOrder(T-&gt;lchild);</span><br><span class="line">     visit(T);</span><br><span class="line">     InOrder(T-&gt;rchild);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历（LRN，左右根，可找到从子孙到祖先的路径）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     PostOrder(T-&gt;lchild);</span><br><span class="line">     PostOrder(T-&gt;rchild);</span><br><span class="line">     visit(T);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求树的深度</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/12/pCh9ydO.png" alt="pCh9ydO.png"></li>
</ul>
</li>
<li><p>层次遍历二叉树</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/13/pChf03j.png" alt="pChf03j.png"></li>
</ul>
</li>
<li><p>由遍历构造二叉树</p>
<ul>
<li>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树，需要和中序遍历组合才行</li>
<li>前序加中序确定二叉树结构<ul>
<li>以前序序列的第一个单位为准，在中序遍历中确定其左右子树，之后的子树的根节点都以前序遍历靠前的元素为准</li>
<li><img src="https://s1.ax1x.com/2023/07/13/pCh7prj.png" alt="pCh7prj.png"></li>
</ul>
</li>
<li>后序加中序确定二叉树结构<ul>
<li>以后序遍历的最后一个元素为准，在中序遍历中确定其左右子树，之后的子树的根节点都以后序遍历靠后的元素为准</li>
<li><img src="https://s1.ax1x.com/2023/07/13/pCh7iaq.png" alt="pCh7iaq.png"></li>
</ul>
</li>
<li>层序加中序确定二叉树结构<ul>
<li><img src="https://s1.ax1x.com/2023/07/13/pChHXjg.png" alt="pChHXjg.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-线索二叉树（选择题考点，代码无需掌握✪）"><a href="#4-线索二叉树（选择题考点，代码无需掌握✪）" class="headerlink" title="4.线索二叉树（选择题考点，代码无需掌握✪）"></a>4.线索二叉树（选择题考点，代码无需掌握✪）</h3><ul>
<li><p>作用：方便从一个结点出发，找到其前驱、后继，<br>此时先序线索二叉树和中序线索二叉树进行遍历时不需要栈的支持（进行）递归，但是后序线索二叉树仍需要栈的支持</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4wIUI.png" alt="pC4wIUI.png"></li>
</ul>
</li>
<li><p><strong>线索：指向前驱和后继的指针，n个结点的二叉树含有n+1个空指针</strong><br><strong>n个结点的线索二叉树含有n+1个线索</strong></p>
</li>
<li><p><strong>二叉树的线索化就是将二叉链表中的空指针改为指向前驱或后驱的线索</strong><br><strong>按照遍历的顺序进行，如果指针已经指向相应结点则不变动，如果没有空指针就跳过）</strong></p>
</li>
<li><p>存储结构</p>
<ul>
<li>在普通二叉树结点的基础上，增加标志位：Itag和rtag （等于0此结点有孩子，等于1此结点被线索化）</li>
<li>ltag\==1时，表示Ichild指向前驱；Itag\==0时，表示Ichild指向左孩子</li>
<li>rtag\==1时，表示rchild指向后继；rtag\==0时，表示rchild指向右孩子</li>
</ul>
</li>
<li><p>线索化二叉树（代码了解即可）</p>
<ul>
<li><p>线索二叉树的存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;  <span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序线索化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>; <span class="comment">//设定当前访问结点的前驱，并初始化</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  <span class="comment">//线索化非空二叉树</span></span><br><span class="line">        InThread(T,pre);</span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>; <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>; <span class="comment">//改变其标志符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre); <span class="comment">//递归，线索化左子树（按照中序遍历，先遍历左子树）</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;  <span class="comment">//若当前结点左子树为空时，建立前驱线索,左指针指向前驱</span></span><br><span class="line">            P-&gt;lchild=pre;</span><br><span class="line">            p-&gt;ltag=<span class="number">1</span>;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild=p; <span class="comment">//建立前驱节点的后继线索</span></span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p; <span class="comment">//完成以上操作之后，将前驱结点指向当前所遍历到的结点</span></span><br><span class="line">        InThread(p-&gt;rchild,pre); <span class="comment">//递归线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于先序线索化而言只需要将其线索化左子树的操作写在前面，中间是根结点的操作，最后是线索化右子树的操作</p>
<ul>
<li>注：此时在ltag==0时，才能对左子树先序线索化</li>
</ul>
</li>
<li><p>对于后序线索化而言只需要将其线索化左子树的操作写在前面，中间是线索化右子树的操作，最后是根结点的操作</p>
</li>
</ul>
</li>
<li><p>线索二叉树的遍历（会推出各种遍历序列即可✪）</p>
<ul>
<li><p>中序线索二叉树的遍历</p>
<ul>
<li><p>进行遍历时，只要先找到序列中的第一个结点，然后依次找结点的后继，直至其后继为空。</p>
</li>
<li><p>首先找到中序线索二叉树的第一个结点 （最左下的结点，不一定为叶节点）</p>
<ul>
<li><p>代码实现（求中序线索二叉树中中序序列下的第一个结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        p=p-&gt;lchild; (遍历找到最左下的结点，不一定是叶结点)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>之后找中序后继结点</p>
<ul>
<li><p>若此时p-&gt;rtag==1,则next=p-&gt;rchild （此时右链为线索，指向其后继）</p>
</li>
<li><p><strong>p-&gt;ratg==0时，此时右子树不为空，则遍历右子树的第一个访问结点（右子树最左下的结点为其后继）</strong></p>
</li>
<li><p>代码实现（求中序线索二叉树中结点p在中序序列下的后继）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThreadNode *<span class="title function_">Nexttnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild); <span class="comment">//不为空，找到其右子树的最左下角的结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//右标志为1直接返回线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历中序二叉树的代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line">		visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序线索二叉树找到中序前驱</p>
<ul>
<li>若此时p-&gt;ltag==1，此时直接返回左线索</li>
<li>若此时p-&gt;ltag==0，则p结点的左子树中，最右下角的结点就是其前驱结点</li>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4dIpT.png" alt="pC4dIpT.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>先序线索二叉树的遍历</p>
<ul>
<li><p>先序线索二叉树的先序后继</p>
<ul>
<li>若右标志位为0时，首先看先序线索二叉树有无左孩子，如果有的话，就是其先序后继，如果只有右孩子没有左孩子，那么右孩子为其先序后继</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4wFHA.png" alt="pC4wFHA.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>先序线索二叉树不能在左标志位为0的情况下找到先序前驱</p>
</li>
</ul>
</li>
<li><p>后序线索二叉树的遍历</p>
<ul>
<li><p>后序线索二叉树找后序前驱</p>
<ul>
<li>若左标志位为0时，此时如果其有右孩子，那么此右孩子为其后序前驱，如果只有左孩子没有右孩子，那么左孩子为其后序前驱</li>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4wqxS.png" alt="pC4wqxS.png"></li>
</ul>
</li>
<li><p>后序线索二叉树找后序后继</p>
<ul>
<li>如果此时右标志位为0，则不能有效的找到后序后继</li>
<li>此时可以用三叉链表来找到其后序后继<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC40yZj.png" alt="pC40yZj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三种线索二叉树遍历的总结</p>
<ul>
<li>对于中序线索二叉树来说可从任意结点进行遍历和逆向遍历；对于前序线索二叉树来说，只可进行顺向遍历；对于后序线索二叉树来说，只可进行逆向遍历</li>
<li><img src="https://s1.ax1x.com/2023/07/14/pC402iq.png" alt="pC402iq.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-树、森林（✪）"><a href="#5-树、森林（✪）" class="headerlink" title="5.树、森林（✪）"></a>5.树、森林（✪）</h3><ul>
<li><p>树的存储结构（✪）</p>
<ul>
<li><p>双亲表示法（顺序存储✪）</p>
<ul>
<li><p>这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。<br>根结点下标为0，其伪指针域为-1。</p>
</li>
<li><p>特点：该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，<br>但求结点的孩子时则需要遍历整个结构。</p>
</li>
<li><p>适用于找父节点较多找孩子结点较少的树，如并查集</p>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">//树中最多的结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="type">int</span> parent; <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE]; <span class="comment">//双亲表示法</span></span><br><span class="line">    <span class="type">int</span> n; <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC45BlQ.png" alt="pC45BlQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>孩子表示法（顺序存储+链式存储）</p>
<ul>
<li><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表<br>叶结点的孩子链表为空表</p>
</li>
<li><p>用数组顺序存储各个结点。每个结点中保存数据元素、孩子链表头指针</p>
</li>
<li><p>特点：这种存储结构寻找子女的操作非常直接，而寻找双亲的操作需要遍历个结点中孩子链表指针域所指向的n个孩子链表，适用于服务流程树。</p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> child; <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span> <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> n,r; <span class="comment">//结点数与根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC45OfO.png" alt="pC45OfO.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>孩子兄弟表示法（链式存储✪）</p>
<ul>
<li><p>又称为二叉树表示法，即以二叉链表作为树的存储结构，<br>包括结点值，<strong>指向结点第一个孩子的结点指针，以及指向结点下一个兄弟结点的指针</strong></p>
</li>
<li><p>特点：易于查找孩子，但是不易于查找双亲，可以方便实现树转换成二叉树的操作。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4qwEd.png" alt="pC4qwEd.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>树、森林与二叉树的转换（会画✪）</p>
<ul>
<li>树转换为二叉树：<strong>转换后的二叉树一定没有右子树</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4LLSP.png" alt="pC4LLSP.png"></li>
</ul>
</li>
<li>森林转换为二叉树<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4Lxeg.png" alt="pC4Lxeg.png"></li>
</ul>
</li>
<li>二叉树转换为树<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4OJmD.png" alt="pC4OJmD.png"></li>
</ul>
</li>
<li>二叉树转换成森林<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4OB1P.png" alt="pC4OB1P.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>树和森林的遍历（✪）</p>
<ul>
<li>树的遍历<ul>
<li>先根遍历<strong>（等同于对相应二叉树的先序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4j9x0.png" alt="pC4j9x0.png"></li>
</ul>
</li>
<li>后根遍历<strong>（等同于对相应二叉树的中序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jirT.png" alt="pC4jirT.png"></li>
</ul>
</li>
<li>层序遍历<ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jFqU.png" alt="pC4jFqU.png"></li>
</ul>
</li>
</ul>
</li>
<li>森林的遍历<ul>
<li>先序遍历<strong>（等同于对所对应的二叉树依次进行先序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jdQP.png" alt="pC4jdQP.png"></li>
</ul>
</li>
<li>中序遍历<strong>（等同于对所对应的二叉树依次进行中序遍历）</strong><ul>
<li><img src="https://s1.ax1x.com/2023/07/14/pC4jwsf.png" alt="pC4jwsf.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-树与二叉树的应用（✪）"><a href="#6-树与二叉树的应用（✪）" class="headerlink" title="6.树与二叉树的应用（✪）"></a>6.树与二叉树的应用（✪）</h3><ul>
<li><p>哈夫曼树和哈夫曼编码</p>
<ul>
<li>带权路径长度：从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度。<br>树中所有叶结点的带权路径长度之和称为该树的带权路径长度（WPL）。</li>
<li>哈夫曼树<ul>
<li>在含有个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树</li>
<li>哈夫曼树的构造<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5gv7T.png" alt="pC5gv7T.png"></li>
</ul>
</li>
<li>注：如果之后的两个单独的叶子结点的构造出的权值比它于树的根构造出的权值更小，那么两个叶子结点先自行构造<ul>
<li>如此题选C，此时9和12先进行自行的构造<img src="https://s1.ax1x.com/2023/07/16/pCIAbGV.png" alt="pCIAbGV.png"></li>
</ul>
</li>
</ul>
</li>
<li>特点<ul>
<li><strong>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</strong></li>
<li><strong>构建过程中共创建了n-1个新结点（非叶结点），哈夫曼树的结点总数为2n-1</strong><ul>
<li>如此题：度为m,此时若含有n个叶子结点，则总的需要处理的结点数为n-1个，此时每次将处理m-1个，因此非叶子结点的数量为$\frac{n-1}{m-1}$<img src="https://s1.ax1x.com/2023/07/16/pCIVe6U.png" alt="pCIVe6U.png"></li>
</ul>
</li>
<li><strong>哈夫曼树中不存在度为1的结点。</strong></li>
<li><strong>哈夫曼树并不唯一，但WPL必然相同且为最优</strong></li>
</ul>
</li>
</ul>
</li>
<li>哈夫曼编码（一种被广泛应用而且非常有效的数据压缩编码）<ul>
<li>固定长度编码与可变长度编码<ul>
<li>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。</li>
<li>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为可变长度编码。</li>
<li>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。</li>
</ul>
</li>
<li>前缀编码：若没有一个编码是另一个编码的前缀，则成为前缀编码，此时将不会产生歧义<ul>
<li>采用的前一位数的编码将会影响后一位数的编码<ul>
<li>例题<img src="https://s1.ax1x.com/2023/07/16/pCIAfKg.png" alt="pCIAfKg.png"></li>
<li><img src="https://s1.ax1x.com/2023/07/16/pCIA4bj.png" alt="pCIA4bj.png"></li>
</ul>
</li>
</ul>
</li>
<li>通过哈夫曼编码可以构造哈夫曼树，此时最大编码长度为树的带权路径长度（WPL），并且可以算出压缩的数据率<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC52mND.png" alt="pC52mND.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>并查集（集合逻辑结构）</p>
<ul>
<li><p>集合的表示：要将元素划分为互不相交的子集。可以用互不相交的树，来表示多个集合</p>
</li>
<li><p>存储结构：使用双亲表示法，双亲指针指向其父节点的序号</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC570F1.png" alt="pC570F1.png"></li>
</ul>
</li>
<li><p>基本操作</p>
<ul>
<li><p>初始化：将所有元素初始化为-1。</p>
<ul>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE]; <span class="comment">//双亲指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span>; <span class="comment">//初始化时，数组指针设置为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查操作（时间复杂度为 O(n)）</p>
<ul>
<li><p>如何查到某个元素属于哪个集合：可以通过树的根结点来判断</p>
</li>
<li><p>如何判断两个元素之间的关系：通过对比各自所在的树的根结点来判断</p>
</li>
<li><p>代码表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)	<span class="comment">//循环寻找x的根（一般设置为-1）</span></span><br><span class="line">        x=S[x]; </span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//此时找到x的根，返回之</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>并操作（时间复杂度为 O(1)，并操作n个独立元素为一个集合则需要O($n^{2}$)）</p>
<ul>
<li><p>让一棵树成为另一棵树的子树即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> ROOt2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>; <span class="comment">//此时要求两个是不同的集合</span></span><br><span class="line">    S[Root2]=Root1; <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对并查集的并操作作优化</p>
<ul>
<li>此时将根结点的值设置为负数（表示其树的结点的总数，有利于将较小的树合并到更大的树，可以控制高度不变）</li>
<li>当合并时，小树的双亲指针变为大树的数组下标，此时大树的指针需要累加结点总数</li>
<li>进行优化之后，查操作的时间复杂度可变为：$O ( \log _ { 2 } n )$</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5HUc8.png" alt="pC5HUc8.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>对并查集的进一步优化（优化查操作）</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5bn5n.png" alt="pC5bn5n.png"></li>
</ul>
</li>
<li><p>并查集的优化后的时间复杂度的变化</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/15/pC5bQ2V.png" alt="pC5bQ2V.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第四章-串</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="数据结构第四章-串"><a href="#数据结构第四章-串" class="headerlink" title="数据结构第四章-串"></a>数据结构第四章-串</h2><blockquote>
<p>计算机学科基础：数据结构第四章串的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-串的定义（特殊的线性表，了解）"><a href="#1-串的定义（特殊的线性表，了解）" class="headerlink" title="1.串的定义（特殊的线性表，了解）"></a>1.串的定义（特殊的线性表，了解）</h3><ul>
<li>定义：串是由零个或多个字符组成的有限序列（串的数据对象限定为字符集）</li>
<li>串中字符的个数n称为串的长度。n=0时的串称为空串</li>
<li>串中任意多个连续的字符组成的子序列称为该串的子串，包含子串的串称为主串。（以子串作为操作对象）</li>
<li>某个字符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。</li>
<li>两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。</li>
</ul>
<h3 id="2-串的模式匹配（串的定位操作✪）"><a href="#2-串的模式匹配（串的定位操作✪）" class="headerlink" title="2.串的模式匹配（串的定位操作✪）"></a>2.串的模式匹配（串的定位操作✪）</h3><ul>
<li><p>子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置。</p>
</li>
<li><p>KMP算法（选择题考点✪）</p>
<ul>
<li><p>每次匹配失败之后，无需回溯主串指针，根据next数组的对应关系来决定当前的模式串的指针设置<br>next数组只与模式串有关，与主串无关</p>
</li>
<li><p>利用next数组控制指针回溯的举例</p>
<ul>
<li>此时在第五个元素匹配失败之后，只需要将模式串指针移动到2位置继续与主串的5位置比较<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCW1ak9.png" alt="pCW1ak9.png"></li>
</ul>
</li>
<li>移动之后的情况如下<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFsrZR.png" alt="pPFsrZR.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S,SString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]; <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：O(m+n)</p>
</li>
</ul>
</li>
<li><p>求next数组（选择题考点，手算方法♚）</p>
<ul>
<li>next[j]的含义是在子串的第j个字符与主串发生失配时，则跳到子串的next[j]位置重新与主串当前位置进行比较</li>
<li>求解方法：<ul>
<li>首先1号2号位分别固定是0和1</li>
<li>若要比较第n位，在上方写出比较字符，只写出其中n-1位前的值（如比较第3位则只需要写出前2位）<br>下方平行地写出模式串完整字符</li>
<li>此时在比较字符的第n位之前画一个竖线，开始进行比较，在下方的模式串进行后移</li>
<li>当后移到某一位时，模式串能与上方的比较字符完全匹配时，此时记录当前的模式串位数为next数组中对应位的值<br>如果模式串已经全部后移出竖线右侧，说明此时next数组的值为1</li>
</ul>
</li>
<li>完全匹配的展示<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFcaz8.png" alt="pPFcaz8.png"></li>
</ul>
</li>
<li>例：比较第4位的情况<ul>
<li>此时画到第四位之前，将模式串逐步后移检查，此时会后移两位才能完全匹配<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFcmPx.png" alt="pPFcmPx.png"></li>
</ul>
</li>
<li>后移到模式串的第一位a时，此时与上方的比较字符的a匹配，此时为第2位，记录在next数组中的序号4位置<ul>
<li><img src="https://s1.ax1x.com/2023/08/04/pPFctit.png" alt="pPFctit.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对KMP算法的进一步优化（将next数组转变成nextval数组）</p>
<ul>
<li><p>nextval数组概述</p>
<ul>
<li>首先需要先把模式串的next数组算出来，初始的nextval数组可以确定第一个序号的值为0</li>
<li>此时从前往后（序号2开始）依次观察每个序号对应的next的值所对应的序号的模式串<br>如下方的序号2的next数组的值为1，1的序号下的模式串为a</li>
<li><p>若其next数组所对应的序号的模式串的与当前序号的模式串相同，<br>此时新建立的nextval的值改为其next数组所对应序号的nextval数组的值（2的nextval改为0）<br>否则与原来的next数组的值一致</p>
</li>
<li><p>转换流程（依次转换）</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWaD1J.png" alt="pCWaD1J.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>注意：比较字符相同后，赋值是赋予nextval数组的值，而非原数组的值，如下题选C</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWBegg.png" alt="pCWBegg.png"></li>
</ul>
</li>
<li><p>如果next数组最初的指针是从-1开始，则第一第二序号赋值为-1,0，之后的序号的指针起始位是0，如下题选C；</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/07/11/pCWBkUP.png" alt="pCWBkUP.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第三章-栈,队列和数组</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88-%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数据结构第三章-栈，队列和数组"><a href="#数据结构第三章-栈，队列和数组" class="headerlink" title="数据结构第三章-栈，队列和数组"></a>数据结构第三章-栈，队列和数组</h2><blockquote>
<p>计算机学科基础：第三章栈，队列和数组的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-栈（✪）"><a href="#1-栈（✪）" class="headerlink" title="1.栈（✪）"></a>1.栈（✪）</h3><h4 id="栈的基本概念（操作受限的线性表）"><a href="#栈的基本概念（操作受限的线性表）" class="headerlink" title="栈的基本概念（操作受限的线性表）"></a>栈的基本概念（操作受限的线性表）</h4><ul>
<li>栈的定义：只允许在一端进行插入或删除操作的线性表</li>
<li>栈顶是允许进行插入删除操作的那一端</li>
<li>栈的特点：后进先出</li>
<li>卡特兰数：n个不同元素进栈，出栈元素的不同排列的个数为： $(\frac{1}{n+1})*C_{2n}^n$</li>
<li><strong>无论是顺序栈还是链栈，出入栈的时间复杂度都为O(1)</strong></li>
</ul>
<h4 id="顺序栈（✪）"><a href="#顺序栈（✪）" class="headerlink" title="顺序栈（✪）"></a>顺序栈（✪）</h4><ul>
<li><p>概念：采用顺序存储的栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，<br>同时附设一个指针(top)指示当前栈顶元素的位置。</p>
</li>
<li><p>指针的变化（具体问题具体分析）</p>
<ul>
<li>指针的设置：S.top，初始时设置S.top=-1，栈顶元素：S.data[S.top]</li>
<li>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素</li>
<li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1</li>
<li>栈空条件：栈空条件：S.top\==-1</li>
<li>栈满条件：S.top==MaxSize-1；栈长：S.top+1</li>
</ul>
</li>
<li><p>代码表示</p>
<ul>
<li><p>顺序栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//栈顶指针，指示当前栈顶元素的位置 </span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span><span class="comment">//初始化 </span></span><br><span class="line">&#123; </span><br><span class="line">	S.top=<span class="number">-1</span>; <span class="comment">//初始化栈顶指针 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Sqstack S)</span><span class="comment">//判空 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的进栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span><span class="comment">//进栈 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	S.data[++S.top]=x; <span class="comment">//此处表示当栈不满时，先加栈顶指针，再执行进栈操作 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序栈的出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span><span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x=S.data[S.top--];<span class="comment">//此时表示当栈不为空时，先将指针处元素赋予x,再将栈顶指针减一，执行出栈操作 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>读取栈顶的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTOP</span><span class="params">(SqStack S,<span class="type">int</span> &amp;x)</span><span class="comment">//读栈顶元素 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	x=S.data[S.top];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<ul>
<li>若栈顶指针初始化为S.top=0，即top指向栈顶元素的下一位置，</li>
<li>则入栈操作变为S.data[S.top++]=x；</li>
<li>出栈操作变为x=S.data[—S,top]；</li>
</ul>
</li>
</ul>
</li>
<li><p>关于共享栈（非重点）</p>
<ul>
<li>共享栈的定义：利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，<br>将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCw87Cj.png" alt="pCw87Cj.png"></li>
</ul>
</li>
<li>共享栈的栈顶指针<ul>
<li>两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；</li>
<li>仅当两个栈顶指针相邻(top1-top0=1)时，判断为栈满</li>
</ul>
</li>
<li>共享栈的出入栈操作：当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反。</li>
<li>共享栈的特点：共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，<br>只有在整个存储空间被占满时才发生上溢，对存取效率没有影响</li>
</ul>
</li>
</ul>
<h4 id="链式栈（✠）"><a href="#链式栈（✠）" class="headerlink" title="链式栈（✠）"></a>链式栈（✠）</h4><ul>
<li><p>链栈的定义：链栈一般由单链表来实现，不带头节点，并规定所有的操作都在表头来进行（相当于栈顶），头指针指向栈顶元素。</p>
</li>
<li><p>链栈的优点：链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9nMLBF.jpg" alt="p9nMLBF.jpg"></li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>链栈的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;	<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域 </span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;S)</span><span class="comment">//初始化链栈 </span></span><br><span class="line">&#123;</span><br><span class="line"> 	S=<span class="literal">NULL</span>;<span class="comment">//头指针为空</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的入栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LiStack &amp;S,<span class="type">int</span> x)</span><span class="comment">//入栈操作 </span></span><br><span class="line">&#123;</span><br><span class="line">  Linknode *p=(Linknode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Linknode));<span class="comment">//分配了一个结点的空间 </span></span><br><span class="line">  p-&gt;data=x;</span><br><span class="line">  p-&gt;next=S; </span><br><span class="line">  S=p; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;	 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LiStack &amp;S,<span class="type">int</span> &amp;x)</span><span class="comment">//出栈操作</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line"> x=S-&gt;data;</span><br><span class="line"> S=S-&gt;next;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; 	 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈的判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EmptyStack</span><span class="params">(LiStack S)</span><span class="comment">//判空</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>取栈顶元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTOP</span><span class="params">(LiStack S,<span class="type">int</span> &amp;x)</span><span class="comment">//取栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">  x=S-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>; 	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-队列（✪）"><a href="#2-队列（✪）" class="headerlink" title="2.队列（✪）"></a>2.队列（✪）</h3><h4 id="队列的基本概念（操作受限的线性表）"><a href="#队列的基本概念（操作受限的线性表）" class="headerlink" title="队列的基本概念（操作受限的线性表）"></a>队列的基本概念（操作受限的线性表）</h4><ul>
<li>队列的定义：只允许在表的一端进行插入，而在表的另一端进行删除。</li>
<li>向队列中插入元素称为入队或进队（此端为队尾rear）；删除元素称为出队或离队（此端为队头front）</li>
<li>特点：先进先出</li>
</ul>
<h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><ul>
<li><p>顺序队列的指针设置：<strong>顺序队列设置两个指针，队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置</strong></p>
</li>
<li><p>顺序队列的出入队操作</p>
<ul>
<li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加一</li>
<li>出队操作：队不空时，先取队头元素值，再将队头指针加一</li>
</ul>
</li>
<li><p>初始时：Q.front==Q.rear\==0，此即为判空的条件</p>
</li>
<li><p><strong>存在的问题：不能用 Q.rear==MaxSize作为判断队满的条件，并且还有可能造成假溢出</strong></p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwYUvn.png" alt="pCwYUvn.png"></li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];</span><br><span class="line">	<span class="type">int</span> front,rear; <span class="comment">//队头指针指向队头元素、队尾指针指向队尾元素的下一个位置 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="循环队列（✪）"><a href="#循环队列（✪）" class="headerlink" title="循环队列（✪）"></a>循环队列（✪）</h4><ul>
<li><p>循环队列的概念：采用循环队列时，将顺序队列想像成一个环形的空间（逻辑上视为一个环），<br>当队首指针Q.front==MaxSize-1后，再前进一个位置就自动到0，可采取除法取余运算（%）来实现。</p>
</li>
<li><p>循环队列的指针设置：<strong>入队出队时相应的指针按顺时针方向进1</strong></p>
<ul>
<li>初始时：Q.front=Q.rear=0</li>
<li>出队时，队首指针进1：Q.front=(Q.front+1)%MaxSize.</li>
<li>入队时，队尾指针进1：Q.rear=(Q.rear+1)%MaxSize.</li>
<li>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize.</li>
</ul>
</li>
<li><p>循环队列的判空条件：Q.front==Q.rear。</p>
</li>
<li><p>此时的局限性：<strong>若入队元素的速度快于出队元素的速度，则队尾指针很快就会赶上队尾指针，此时将无法判断队满还是队空</strong></p>
</li>
<li><p>三种处理方式区分队空和队满的判断条件（✪）</p>
<ul>
<li><p>牺牲一个数组单元来区分队空和队满（♚）</p>
<ul>
<li><p>具体实现：<strong>入队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置“作为队满的标志</strong></p>
</li>
<li><p>此时判断队满和队空的条件</p>
<ul>
<li><strong>队满条件：(Q.rear+1)%Maxsize\==Q.front</strong></li>
<li><strong>队空条件：Q.front==Q.rear.</strong></li>
<li><strong>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize。</strong></li>
</ul>
</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwt8qx.png" alt="pCwt8qx.png"></li>
</ul>
</li>
<li>例题：本题选A<ul>
<li><img src="https://s1.ax1x.com/2023/07/04/pCscjpQ.png" alt="pCscjpQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>结构体类型中增设表示元素个数的数据成员（size）</p>
<ul>
<li>入队时：Q.size++；出队时：Q.size—，此时队空和队满都满足：Q.front\==Q.rear</li>
<li>队空的条件为：Q.s1ze\==0</li>
<li>队满的条件为：Q.size\==MaxSize</li>
</ul>
</li>
<li><p>结构体类型中增设tag数据成员，以区分是队满还是队空。</p>
<ul>
<li>初始化时tag=0；入队成功时令tag=1；出队成功时令tag=0</li>
<li>tag等于0时，若因删除导致Q.front\==Q.rear,则为队空</li>
<li>tag等于1时，若因插入导致Q.front\==Q.rear,则为队满</li>
</ul>
</li>
</ul>
</li>
<li><p>循环队列的代码实现</p>
<ul>
<li><p>循环队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	Q.rear=Q.front=<span class="number">0</span>;	<span class="comment">//初始化队首与队尾指针 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的判断队空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(SqQueue Q)</span><span class="comment">//判空 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front) </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的入队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//入队 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)	<span class="comment">//判断队列是否已满	</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Q.data[Q.rear]=x;</span><br><span class="line">	Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列的出队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> &amp;x)</span><span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)	<span class="comment">//判空 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">	Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>取循环队列的队首元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue Q,<span class="type">int</span> &amp;x)</span><span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==Q.front)<span class="comment">//判空 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="链式队列（✠）"><a href="#链式队列（✠）" class="headerlink" title="链式队列（✠）"></a>链式队列（✠）</h4><ul>
<li><p>链式队列的定义</p>
<ul>
<li><strong>一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点(即单链表的最后一个结点)</strong><br><strong>注意与顺序存储的不同</strong></li>
<li><strong>一般将链式队列设计成一个带头结点的单链表，统一插入和删除操作</strong></li>
<li><strong>最适合作为链队的链表是带队头指针和队尾指针的非循环单链表（带头结点）</strong>，<br>此时可快速在第一个位置实现删除操作，在最后一个位置实现插入操作（循环单链表画蛇添足了）</li>
<li><strong>用链式方式存储的队列，在进行插入运算时，头尾指针可能都要修改</strong><ul>
<li>当队列不为空时，只会修改rear尾指针。</li>
<li>当队列为空时，再当有头结点时，也只要修改rear</li>
<li>当队列为空且没有头结点时，头尾指向相同，在插入时就需要同时修改头和尾</li>
</ul>
</li>
</ul>
</li>
<li><p>不带头结点的链式队列</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwwUv4.png" alt="pCwwUv4.png"></li>
</ul>
</li>
<li>链式队列的判空：当Q.front\==NULL&amp;&amp;Q.rear==NULL时，链式队列为空</li>
<li>链式队列的出入队操作：<ul>
<li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点<br>若原队列为空队，则令Q.front也指向该结点</li>
<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点<br>若该结点为最后一个结点，则置Q.front和Q.rear都为NULL</li>
</ul>
</li>
</ul>
</li>
<li><p>带头结点的链式队列</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/29/pCwwdKJ.png" alt="pCwwdKJ.png"></li>
</ul>
</li>
<li>链式队列的判空：Q.front==Q.rear</li>
<li>链式队列的出入队操作<ul>
<li>入队时，建立一个新结点，将新结点插入到链表的尾部，并让Q.rear指向这个新插入的结点</li>
<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除，并让Q.front指向下一个结点<br>若该结点为最后一个结点，则置Q.rear=Q.front</li>
</ul>
</li>
</ul>
</li>
<li><p>链式队列的优点</p>
<ul>
<li>用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</li>
<li>假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和“溢出”的问题。</li>
</ul>
</li>
<li><p>带头结点的链式队列的代码实现</p>
<ul>
<li><p>链式队列的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>//链式队列结点 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//链式队列 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LinkNode *front,*rear;<span class="comment">//链式队列头指针与尾指针 </span></span><br><span class="line">&#125;LinkQueue;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span><span class="comment">//链式队列的初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//头指针和尾指针指向新建立的头结点 </span></span><br><span class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始为空 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的判空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkQueue Q)</span><span class="comment">//链式队列的判空 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的入队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//链式队列的入队 </span></span><br><span class="line">&#123;</span><br><span class="line">	LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));<span class="comment">//创建新节点 </span></span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q.rear-&gt;next=s;</span><br><span class="line">	Q.rear=s;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>链式队列的出队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用链式存储方式的队列进行删除操作时需要：头尾指针可能都需要修改,因为如果此时队列中只有一个元素的话，删除之后，队列为空，需要将Q.rear=Q.front;</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span><span class="comment">//链式队列的出队 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)<span class="comment">//判空 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LinkNode *p=Q.front-&gt;next;	<span class="comment">//创建一个指针此时指向出队的结点 </span></span><br><span class="line">	x=p-&gt;data;</span><br><span class="line">	Q.front-&gt;next=p-&gt;next;	<span class="comment">//进行出队的操作</span></span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)<span class="comment">//	若原队列中只有一个结点，则删除之后变空。 </span></span><br><span class="line">		Q.rear=Q.front;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="双端队列（主要考察选择题✪）"><a href="#双端队列（主要考察选择题✪）" class="headerlink" title="双端队列（主要考察选择题✪）"></a>双端队列（主要考察选择题✪）</h4><ul>
<li>双端队列的概念：双端队列是指允许两端都可以进行入队和出队操作的队列，此时可以加上一定的限制<br>形成输出受限的双端队列和输入受限的双端队列</li>
<li>题目考查<ul>
<li><strong>作为选择题：常常以输入序列来判断相关的输出序列是否正确，此时的方法是画图进行分析。</strong></li>
<li><strong>特别地，对于输出序列受限的这一类的题目，可以将其的输出序列直接依次填入所画的双端队列图，由题目的输入序列来反推是否可以得到此输出序列</strong></li>
<li>例题：分别选C、C<ul>
<li><img src="https://s1.ax1x.com/2023/04/21/p9E0NGQ.png" alt="p9E0NGQ.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-栈和队列的应用-侧重手算模拟-代码不需要掌握✪"><a href="#3-栈和队列的应用-侧重手算模拟-代码不需要掌握✪" class="headerlink" title="3.栈和队列的应用 (侧重手算模拟,代码不需要掌握✪)"></a>3.栈和队列的应用 (侧重手算模拟,代码不需要掌握✪)</h3><h4 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h4><ul>
<li>过程：依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</li>
<li>匹配失败情况：①左括号单身②右括号单身③左右括号不匹配</li>
<li>流程图<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eIMRJ.jpg" alt="p9eIMRJ.jpg"></li>
</ul>
</li>
<li>算法实现<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eIuiF.jpg" alt="p9eIuiF.jpg"></li>
</ul>
</li>
</ul>
<h4 id="栈在表达式求值中的应用（✪）"><a href="#栈在表达式求值中的应用（✪）" class="headerlink" title="栈在表达式求值中的应用（✪）"></a>栈在表达式求值中的应用（✪）</h4><ul>
<li>中缀表达式<ul>
<li>中缀表达式包括:操作数、运算符、界限符</li>
<li>其运算符在两个操作数的中间（a+b-c*d）</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mqljg.jpg" alt="p9mqljg.jpg"></li>
</ul>
</li>
</ul>
</li>
<li>后缀表达式（♚）<ul>
<li>定义：也称逆波兰表达式，运算符在两个操作数的后面（$ab+cd*-$）</li>
<li>中缀表达式转为后缀表达式<ul>
<li>手算（在确定中缀表达式的运算顺序时，只要左边的能算，就优先算左边的）<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eohtO.jpg" alt="p9eohtO.jpg"></li>
</ul>
</li>
<li>机算<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mbg1S.jpg" alt="p9mbg1S.jpg"></li>
</ul>
</li>
</ul>
</li>
<li>后缀表达式求值<ul>
<li>手算<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eTg2Q.png" alt></li>
</ul>
</li>
<li>机算<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9e7AsA.png" alt="p9e7AsA.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>前缀表达式<ul>
<li>定义：也称波兰表达式，运算符在两个操作数的前面（$-+ab*cd$）</li>
<li>中缀表达式转前缀表达式<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eH1fO.jpg" alt="p9eH1fO.jpg"></li>
</ul>
</li>
<li>前缀表达式求值<ul>
<li><img src="https://s1.ax1x.com/2023/04/23/p9eH6Xj.png" alt="p9eH6Xj.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h4><ul>
<li><p>关于函数的调用</p>
<ul>
<li><strong>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</strong></li>
<li>函数调用时，需要用一个函数调用栈存储相关信息：调用返回地址、实参、局部变量</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mjPIA.png" alt="p9mjPIA.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>关于递归</p>
<ul>
<li><p><strong>定义：若在一个函数、过程或数据结构的定义中又应用了它自身，则称为递归</strong></p>
<ul>
<li><p>递归调用时，函数调用栈可称为”递归工作栈”</p>
</li>
<li><p>每进入一层递归，就将递归调用所需信息压入栈顶</p>
</li>
<li>每退出一层递归，就从栈顶弹出相应信息</li>
</ul>
</li>
<li>递归模型不能是循环定义的，必须满足的两个条件：递归表达式（递归体）；边界条件（递归出口）。</li>
<li>适合用“递归”算法解决的问题：可以把原始问题转换为属性相同，但规模较小的问题，此时可以大大减少程序的代码量</li>
<li>可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换</li>
<li><p>递归程序的缺点</p>
<ul>
<li>太多层递归可能会导致栈溢出</li>
<li><strong>通常效率较低，可能包含很多重复计算</strong></li>
<li>空间复杂度较高</li>
</ul>
</li>
<li>消除递归不一定必须用栈来实现</li>
</ul>
</li>
<li><p>求阶乘问题</p>
<ul>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="comment">//边界条件 </span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);<span class="comment">//递归表达式 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n=factorial(<span class="number">10</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mvmSx.jpg" alt="p9mvmSx.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><p>斐波那契数列问题</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/04/24/p9mz2eU.png" alt="p9mz2eU.png"></li>
</ul>
</li>
</ul>
<h4 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h4><ul>
<li>可作为树的层次遍历、图的广度遍历、页面替换算法、可作为<strong>数据缓冲区（打印机应用）</strong></li>
</ul>
<h3 id="4-数组和特殊矩阵（选择题考点✪）"><a href="#4-数组和特殊矩阵（选择题考点✪）" class="headerlink" title="4.数组和特殊矩阵（选择题考点✪）"></a>4.数组和特殊矩阵（选择题考点✪）</h3><ul>
<li>数组的存储结构<ul>
<li>数组是由n(n≥1)个相同类型的数据元素构成的有限序列，是线性表的推广（顺序存储结构）</li>
<li><strong>广义表采取的是链式存储结构，一个广义表的表尾总是一个广义表</strong></li>
<li>多维数组的两种映射方法<ul>
<li>行优先<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6AC0e.png" alt="pC6AC0e.png"></li>
</ul>
</li>
<li>列优先<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6AM7Q.png" alt="pC6AM7Q.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>特殊矩阵的压缩存储<ul>
<li>压缩存储的定义：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间</li>
<li>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。<br>常见的特殊矩阵有对称矩阵、上（下）三角矩阵、对角矩阵等。</li>
<li>特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，<br>把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。</li>
<li>注意: 二维数组 ${A[n][n]}$ 和 ${A[0 \ldots n-1][0 \ldots n-1]}$ 的写法是等价的。<ul>
<li>如果数组写为 ${A[1 \ldots n][1 \ldots n]}$, 则说明指定了从下标 1 开始存储元素。</li>
<li>二维数组元素写为 ${a[i][j]}$, 注意数组元素下标 ${i}$ 和 ${j}$ 通常是从 0 开始的。</li>
<li>矩阵元素通常写为 ${a_{i, j}}$ 或 ${a_{(i)(j)}}$, 注意行号 ${i}$ 和列号 ${j}$ 是 从 1 开始的。</li>
</ul>
</li>
</ul>
</li>
<li>特殊矩阵（♚）<ul>
<li>处理特殊矩阵的方式，一般先找出前i-1行的规律，再将其与第i行相加即可<strong>（通过画出具体的方阵图来分析）</strong></li>
<li>对称矩阵<ul>
<li>此时n阶方阵中均有：$a_{i,j} = a_{j,i}$，则只需要存放主对角线和下三角形部分。</li>
<li>如果为将下三角部分的元素存入数组的对称矩阵，此时按行优先方式有以下结论<br>（前i-1行可由求和公式得出，为上三角形时，i与j互换）<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6EzZD.png" alt="pC6EzZD.png"></li>
</ul>
</li>
</ul>
</li>
<li>三角矩阵<ul>
<li>下三角形矩阵<ul>
<li>上三角区的所有元素均为同一常量。存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6ZG9A.png" alt="pC6ZG9A.png"></li>
</ul>
</li>
<li>行优先原则的下标<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6ZaB8.png" alt="pC6ZaB8.png"></li>
</ul>
</li>
</ul>
</li>
<li>上三角形矩阵<ul>
<li>行优先原则的下标<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6Z0Ag.png" alt="pC6Z0Ag.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>三对角矩阵（带状矩阵）<ul>
<li>三对角矩阵中，所有非零元素都集中在以主对角线为中心的三条对角线的区域，其它区域的元素都为0<br>当|i-j|&gt;1时，此时为0<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6ZvUe.png" alt="pC6ZvUe.png"></li>
</ul>
</li>
<li>行优先原则的下标<ul>
<li>前i-1行共 3(i-1)-1 个元素 （第一行需要减1）</li>
<li>$a_{i,j}$是i行第j-i+2个元素，$a_{i,j}$是第2i+j-2个元素</li>
<li>此时数组下标k为k=2i+j-3</li>
</ul>
</li>
<li>如何根据下标求出元素在数组中的具体位置<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6necn.png" alt="pC6necn.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>稀疏矩阵（<strong>压缩存储后必定会失去随机存储的功能</strong>）<ul>
<li>矩阵中非零元素的个数远远小于为0的元素</li>
<li>使用顺序存储方式压缩存储（三元组表）<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6Qze1.png" alt="pC6Qze1.png"></li>
</ul>
</li>
<li>使用链式存储方式压缩存储（十字链表）<ul>
<li><img src="https://s1.ax1x.com/2023/07/06/pC6liWD.png" alt="pC6liWD.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第二章-线性表</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="数据结构第二章-线性表"><a href="#数据结构第二章-线性表" class="headerlink" title="数据结构第二章 线性表"></a>数据结构第二章 线性表</h2><blockquote>
<p>计算机学科基础：数据结构第二章线性表的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-线性表的定义"><a href="#1-线性表的定义" class="headerlink" title="1.线性表的定义"></a>1.线性表的定义</h3><ul>
<li><p>①定义：具有<u>相同数据类型</u>的n个<u>数据元素</u>的<u>有限序列</u>，<strong>线性表是一种逻辑结构，表示元素之间一对一的相邻关系</strong></p>
</li>
<li><p>②特点：<strong>表中的元素在逻辑上相邻，具有逻辑上的顺序性，有其先后次序，每个元素只有唯一的前驱元素</strong></p>
</li>
</ul>
<h3 id="2-顺序表（线性表的顺序存储结构✪）"><a href="#2-顺序表（线性表的顺序存储结构✪）" class="headerlink" title="2.顺序表（线性表的顺序存储结构✪）"></a>2.顺序表（线性表的顺序存储结构✪）</h3><ul>
<li><p>①定义：<strong>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素</strong><br><strong>从而使得逻辑上相邻的两个元素在物理位置上也相邻</strong></p>
</li>
<li><p>②特点</p>
<ul>
<li>顺序表中元素的逻辑顺序与其物理顺序相同</li>
<li>顺序表中的任意一个数据元素都可以<strong>随机存取</strong>，即通过首地址和元素序号可在时间O(1)内找到指定的元素。</li>
<li>顺序表的存储密度高，每个结点只存储数据元素。</li>
<li><strong>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</strong></li>
<li><strong>n个元素的顺序表可插入的位置有n+1个，移动次数总数为：n(n+1)/2</strong><br><strong>平均移动次数为：n/2</strong></li>
<li><strong>n个元素的顺序表删除元素时，平均移动次数为：(n-1)/2</strong></li>
<li><strong>n个元素的顺序表顺序查找的平均比较/查找次数为：(n+1)/2</strong></li>
</ul>
</li>
<li><p>③代码实现（用<strong>数组</strong>来描述线性表的顺序存储结构♚）</p>
<ul>
<li><p>顺序表的定义</p>
<ul>
<li><p>静态分配一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50 <span class="comment">//定义顺序表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[Maxsize]; <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//对顺序表进行初始化 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>动态分配一维数组（存储数组的空间使用malloc函数进行动态分配）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> *data; <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">	<span class="type">int</span> MaxSize,length; <span class="comment">//数组的最大容量和当前顺序表的长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqLsit L;</span><br><span class="line">	InitList(L); <span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="comment">//...向表中插入几个元素</span></span><br><span class="line">    IncreaseSize(L,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span><span class="comment">//使用动态分配方法的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span><span class="comment">//为数组分配新的空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=L.data;<span class="comment">//申请一个新指针</span></span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize=L.Maxsize+len;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>顺序表的插入操作（平均时间复杂度：O(n)）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span><span class="comment">//顺序表的插入，指定位置，插入元素 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.length&gt;=MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)</span><br><span class="line">		L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">	L.data[i<span class="number">-1</span>]=e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的删除操作（平均时间复杂度：O(n)）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//顺序表的删除，删除指定位置的元素，并传出此元素 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e=L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的按值查找位置 （平均时间复杂度：O(n)）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Locate</span><span class="params">(SqList L,<span class="type">int</span> e)</span><span class="comment">//按值查号，返回该第一个等于值的位置 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">		<span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//查到了则返回其位序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序表的按位查找元素 （平均时间复杂度：O(1)，此时为随机访问）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Get</span><span class="params">(SqList L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//按位查找，返回在位置i上的元素e </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e=L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-链表（线性表的链式存储结构✪）"><a href="#3-链表（线性表的链式存储结构✪）" class="headerlink" title="3.链表（线性表的链式存储结构✪）"></a>3.链表（线性表的链式存储结构✪）</h3><ul>
<li><p>①定义：<strong>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。</strong><br><strong>为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针。</strong></p>
</li>
<li><p>②特点</p>
<ul>
<li>链式存储线性表时，不需要使用地址连续的存储单元，不要求逻辑上相邻的元素在物理上也相邻</li>
<li>插入和删除元素不需要移动元素，只需要修改指针。</li>
<li>单链表附加指针域，也存在浪费存储空间的缺点。</li>
<li>由于单链表的元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，<br>即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找。</li>
<li><strong>设一个有序的单链表中有n个结点，现要求插入一个新节点后使得单链表仍然保持有序，则该操作的时间复杂度为O(n)</strong></li>
</ul>
</li>
<li><p>③代码实现（♚）</p>
<ul>
<li><p>单链表的定义</p>
<ul>
<li><p>单链表的结点由数据域（data，存放数据元素）和指针域（next，存放其后继结点的地址）组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList; <span class="comment">//别名，第一个强调它是一个结点，第二个强调它是一个链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：要表示一个单链表，只需声明一个头指针L，指向单链表的第一个结点。</span></span><br><span class="line"><span class="comment">// LNode *L;或 LinkList L;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>初始化单链表</p>
<ul>
<li><p>带头结点的单链表（头指针指向头结点）</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaMWPx.png" alt="pCaMWPx.png"></li>
</ul>
</li>
<li><p>为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点<br>头结点的数据域不带任何信息，指针域指向线性表的第一个<strong>数据结点</strong>（区分第一个结点和第一个数据结点）</p>
</li>
<li><p>头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点<br>而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。</p>
</li>
<li><p>引入头结点的优点</p>
<ul>
<li><strong>对于插入或删除第一个数据结点的操作，由于第一个数据结点的位置被存放在头结点的指针域中，</strong><br><strong>因此在链表的第一个位置上的操作和在表的其他位置上的操作一致，无须进行特殊处理。</strong></li>
<li>无论链表是否为空，其头指针都是指向头结点的非空指针（空表中头结点的指针域为空）<br>因此空表和非空表的处理也就得到了统一。</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//初始化单链表 </span></span><br><span class="line">&#123;</span><br><span class="line">	L=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//分配一个头结点 </span></span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不带头结点的单链表 （头指针指向第一个数据结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">	L=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>建立单链表</p>
<ul>
<li><p>使用头插法建立单链表（<strong>时间复杂度O(n)</strong>）</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCa8TUJ.png" alt="pCa8TUJ.png"></li>
</ul>
</li>
<li><p>从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头</p>
</li>
<li><p>读入数据的顺序与生成的链表中的元素的顺序是相反的</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//头插法建立单链表,可以用于实现逆置 </span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *s;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建头结点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;   <span class="comment">//初始为空链表</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//创建新结点</span></span><br><span class="line">		s-&gt;data=x;</span><br><span class="line">		s-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=s;  <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用尾插法建立单链表（<strong>时间复杂度O(n)</strong>）</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCa8jKK.png" alt="pCa8jKK.png"></li>
</ul>
</li>
<li><p>该方法将新结点插入到当前链表的表尾，需要增加一个尾指针r，使其始终指向当前链表的尾结点</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TaliInsert</span><span class="params">(LinkList &amp;L)</span><span class="comment">//尾插法建立单链表 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	LNode *s,*r=L;		<span class="comment">//尾插法需要建立一个尾指针r,刚开始都指向头结点 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data=x;</span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">		r=s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); </span><br><span class="line">	&#125; </span><br><span class="line">	r-&gt;next=<span class="literal">NULL</span>;	<span class="comment">//尾结点指针置空</span></span><br><span class="line">	<span class="keyword">return</span> L; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表按序号查找结点 （<strong>时间复杂度O(n)</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span><span class="comment">//循环单链表找到第i个位置的指针 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">//若i无效，返回NULL</span></span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;	<span class="comment">//相当于把头结点看作是0号位置</span></span><br><span class="line">	LNode *p=L;	<span class="comment">//刚开始P指向头结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p; <span class="comment">//返回第i个结点的指针，若i大于表长，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表按值查找节点（<strong>时间复杂度O(n)</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,<span class="type">int</span> e)</span><span class="comment">//按值查找结点 </span></span><br><span class="line">&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)	<span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">	 	p=p-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p; 	<span class="comment">//找到后返回该结点的指针，如果链表中没有该值将返回空值 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的插入结点操作</p>
<ul>
<li><p>指定的结点后插操作</p>
<ul>
<li><p>查找待插入位置的前驱结点的时间复杂度为O(n)，在给定的结点后面插入新结点的时间复杂度为O(1)</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaJDYj.png" alt="pCaJDYj.png"></li>
</ul>
</li>
<li><p>插入结点操作将值为×的新结点插入到单链表的第i个位置上。先检查插入位置的合法性<br>然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点</p>
</li>
<li><p>算法首先调用按序号查找算法GetElem（L，i-1），查找第i-1个结点。<br>假设返回的第i-1个结点为p，然后令新结点s的指针域指向p的后继结点，再令结点p的指针域指向新插入的结点s</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找插入位置的前驱结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertNext</span><span class="params">(LNode *p,<span class="type">int</span> e)</span><span class="comment">//指定结点的后插操作,需要找到其前驱结点,此时的p是指向待插入位置的前驱结点的指针  </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=p-&gt;next; </span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>指定结点的前插操作</p>
<ul>
<li><p><strong>查找待插入位置的结点的时间复杂度为O(n)，在给定的结点前面插入新结点的时间复杂度为O(1)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPrior</span><span class="params">(LNode *p,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">	s-&gt;next=p-&gt;next; </span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">	s-&gt;data=p-&gt;data;  <span class="comment">//交换了数据域 </span></span><br><span class="line">	p-&gt;data=e; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表的删除结点操作</p>
<ul>
<li><p>寻找待删除结点的前驱结点，再执行相关删除操作</p>
<ul>
<li><p>查找待删除位置的前驱结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p>
</li>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaYsED.png" alt="pCaYsED.png"></li>
</ul>
</li>
<li><p>先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span><span class="comment">//删除第i个位置的元素，并用e返回删除元素的值,需要找到前驱结点 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *p=GetElem(L,i<span class="number">-1</span>);	<span class="comment">//循环单链表找到第i-1个位置的指针</span></span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *q=p-&gt;next;	<span class="comment">//新创建一个指针，并使该指针指向当前欲删除的结点 </span></span><br><span class="line">	e=q-&gt;data;</span><br><span class="line">	p-&gt;next=q-&gt;next;	<span class="comment">//修改前驱结点的指针域使其指向待删除结点的下一个结点,将*q结点从链中断开 </span></span><br><span class="line">	<span class="built_in">free</span>(q);	<span class="comment">//释放结点的存储空间 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寻找待删除结点，再执行相关删除操作</p>
<ul>
<li><p>查找待删除位置的结点的时间复杂度为O(n)，删除此结点的时间复杂度为O(1)</p>
</li>
<li><p>删除结点P的操作可用删除P的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p=GetElem(L,i<span class="number">-1</span>); <span class="comment">//查找待插入位置的结点</span></span><br><span class="line">，，，</span><br><span class="line"><span class="type">int</span> <span class="title function_">DeleteNext</span><span class="params">(LNode *p,<span class="type">int</span> &amp;e)</span><span class="comment">//删除需删除结点的后继结点，但是此时由于该原本该删除的结点的数据域和指针域已经被实际删除的结点的值覆盖，因此相当于删除了需删除的结点 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LNode *q=p-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">	p-&gt;data=q-&gt;data;</span><br><span class="line">	p-&gt;next=q-&gt;next</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单链表的求表长操作<strong>（时间复杂度为O(n)）</strong></p>
<ul>
<li><p>求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，<br>为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span><span class="comment">//求表长 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	LNode *p=L-&gt;next; <span class="comment">//创建一个指针指向第一个数据结点</span></span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-双链表（主要考察选择题✪）"><a href="#4-双链表（主要考察选择题✪）" class="headerlink" title="4.双链表（主要考察选择题✪）"></a>4.双链表（主要考察选择题✪）</h3><ul>
<li><p>①定义</p>
<ul>
<li>双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点，<br>在指针已经指向相应结点的情况下，插入和删除的时间复杂度为O(1)</li>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCatOFe.png" alt="pCatOFe.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>②代码实现</p>
<ul>
<li><p>双链表的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;; DNode,*DLinkList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InitDLink</span><span class="params">(DLinkList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">	L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">	<span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	L-&gt;prior=<span class="literal">NULL</span>;<span class="comment">//头结点的前驱指针永远指向NULL </span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>双链表的插入操作</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCaUsET.png" alt="pCaUsET.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Insert</span><span class="params">(DNode *p,DNode *s)</span><span class="comment">//在i位置上的p节点之后插入结点s，数值为e </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	s-&gt;next=p-&gt;next; <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		p-&gt;next-&gt;prior=s;</span><br><span class="line">	s-&gt;prior=p;  <span class="comment">//2</span></span><br><span class="line">	p-&gt;next=s; 	 <span class="comment">//3</span></span><br><span class="line">	p-&gt;data=e;	 <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; <span class="comment">//1和2步必须在第4步之前，否则p的后继结点的指针就会丢掉，导致插入失败</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>双链表的删除操作</p>
<ul>
<li><p>图片</p>
<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCadQTf.png" alt="pCadQTf.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(DNode *p)</span><span class="comment">//删除p结点的后继结点q </span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	DNode *q=p-&gt;next; <span class="comment">//找到p的后继结点q </span></span><br><span class="line">	<span class="keyword">if</span>(q==<span class="literal">NULL</span>)<span class="comment">//p结点没有后继 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	p-&gt;next=q-&gt;next; </span><br><span class="line">	<span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">		q-&gt;next-&gt;prior=p;</span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-循环链表（主要考察选择题✪）"><a href="#5-循环链表（主要考察选择题✪）" class="headerlink" title="5.循环链表（主要考察选择题✪）"></a>5.循环链表（主要考察选择题✪）</h3><ul>
<li><p>①循环单链表</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCawDbt.png" alt="pCawDbt.png"></li>
</ul>
</li>
<li>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li>
<li>在循环单链表中，表尾结点r的next域指向L，故表中没有指针域为NULL的结点，<br>因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</li>
<li>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表</li>
<li>有时对循环单链表不设头指针而仅设尾指针，以使得操作效率更高。<ul>
<li>其原因是，若设的是头指针，对在表尾插入元素需要O(n)的时间复杂度，</li>
<li>而若设的是尾指针r，r-&gt;next即为头指针，对在表头或表尾插入元素都只需要O($1$)的时间复杂度。</li>
</ul>
</li>
</ul>
</li>
<li><p>②循环双链表</p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCawbPU.png" alt="pCawbPU.png"></li>
</ul>
</li>
<li>循环双链表中，头结点的前指针指向表尾节点，判空的条件是头结点的前后指针域都等于头结点</li>
<li>循环双链表是有助于删除第一个结点、删除最后一个结点，在第一个结点前插入一个结点，在最后一个结点后添加一个结点<ul>
<li>选A、C，如果是循环单链表，没办法处理删除最后一个结点（无法快速找到最后一个结点的前驱结点）</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsd3sU.png" alt="pCsd3sU.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h3><ul>
<li><p><strong>静态链表借助数组来描述线性表的<u>链式存储结构</u>，也有指针域和数据域</strong></p>
<ul>
<li>图片<ul>
<li><img src="https://s1.ax1x.com/2023/06/27/pCa0zlQ.png" alt="pCa0zlQ.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>指针表示下一个元素的数组下标（游标），静态链表也需要事先分配一块连续的内存空间。</p>
</li>
<li><p>其插入和删除不需要移动元素，只需要修改指针。</p>
</li>
<li><p>以next==-1作为结束的标志。</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-顺序表和链表的比较（✪）"><a href="#7-顺序表和链表的比较（✪）" class="headerlink" title="7.顺序表和链表的比较（✪）"></a>7.顺序表和链表的比较（✪）</h3><ul>
<li>1.存取（读写）方式<ul>
<li>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。</li>
<li>例如在第i个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问i次。</li>
</ul>
</li>
<li>2.逻辑结构与物理结构<ul>
<li>采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。</li>
<li>而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。</li>
</ul>
</li>
<li>3.查找、插入和删除操作<ul>
<li>对于按值查找，顺序表无序时，两者的时间复杂度均为O(n)<br>顺序表有序时，可采用折半查找，此时的时间复杂度为O($log_2n$).</li>
<li>对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)<br>而链表的平均时间复杂度为O(n)</li>
<li>顺序表的插入、删除操作，平均需要移动半个表长的元素。<br>链表的插入、删除操作，只需修改相关结点的指针域即可。</li>
<li>由于链表的每个结点都带有指针域，故而存储密度不够大。</li>
</ul>
</li>
<li>4.空间分配<ul>
<li>顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，<br>因此需要预先分配足够大的存储空间。<ul>
<li>预先分配过大，可能会导致顺序表后部大量闲置；</li>
<li>预先分配过小，又会造成溢出。</li>
</ul>
</li>
<li>动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，<br>而且若内存中没有更大块的连续存储空间，则会导致分配失败。</li>
<li>链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。</li>
</ul>
</li>
<li>如何选取存储结构<ul>
<li>1.基于存储的考虑<ul>
<li>难以估计线性表的长度或存储规模时，不宜采用顺序表</li>
<li>链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。</li>
</ul>
</li>
<li>2.基于运算的考虑<ul>
<li>在顺序表中按序访问的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n),<br>因此若经常做的运算是按序号访问数据元素，则显然顺序表优于链表。</li>
<li>在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点是不应忽视的</li>
<li>在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是比较操作，从这个角度考虑显然后者优于前者。</li>
</ul>
</li>
<li>3.基于环境的考虑<ul>
<li>顺序表容易实现，任何高级语言中都有数组类型，链表的操作是基于指针的，<br>相对来讲，前者实现较为简单，这也是用户考虑的一个因素。</li>
<li>通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（即动态性较强）宜选择链式存储。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构第一章-绪论</title>
    <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="数据结构第一章-绪论"><a href="#数据结构第一章-绪论" class="headerlink" title="数据结构第一章 绪论"></a>数据结构第一章 绪论</h2><blockquote>
<p>计算机学科基础：数据结构第一章绪论的学习笔记</p>
</blockquote>
<span id="more"></span>
<h3 id="1-数据结构的基本概念"><a href="#1-数据结构的基本概念" class="headerlink" title="1.数据结构的基本概念"></a>1.数据结构的基本概念</h3><ul>
<li>数据</li>
<li>数据元素：<u>数据的基本单位</u>，由若干个数据项组成<br><strong>数据项是不可分割的最小独立数据单位</strong></li>
<li>数据对象：具有相同性质的数据元素的集合，是数据的一个子集</li>
<li>数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称<ul>
<li>原子类型：其值不可再分的数据类型。（如bool、int）</li>
<li>结构类型：其值可以再分解为若干成分（分量）的数据类型。(如结构体)</li>
<li><strong>抽象数据类型ADT</strong>：抽象数据组织及与之相关的操作<br>描述了数据的逻辑结构和抽象运算，定义了一个完整的数据结构，如线性表、栈、队列、树、图等）。</li>
</ul>
</li>
<li>数据结构<ul>
<li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构(Structure)</li>
<li>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</li>
<li>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，<br>而算法的实现依赖于所采用的存储结构。</li>
</ul>
</li>
</ul>
<h3 id="2-数据结构的三要素"><a href="#2-数据结构的三要素" class="headerlink" title="2.数据结构的三要素"></a>2.数据结构的三要素</h3><ul>
<li>数据的逻辑结构：数据元素之间的逻辑关系，<strong>数据的逻辑结构独立于其存储结构</strong><ul>
<li>线性结构（数据元素之间只存在一对一的关系）<ul>
<li>一般线性表</li>
<li>受限线性表：栈和队列、串</li>
<li>线性表推广：数组</li>
</ul>
</li>
<li>非线性结构<ul>
<li>集合 （结构中的数据元素之间除“同属一个集合外”，别无其他关系）</li>
<li>树形结构：一般树、二叉树（数据元素之间存在一对多的关系）</li>
<li>图状结构：有向图、无向图（数据元素之间存在多对多的关系）</li>
</ul>
</li>
<li>概念型的例题<ul>
<li>此题选C，逻辑结构均是线性结构</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCs0g2t.png" alt="pCs0g2t.png"></li>
</ul>
</li>
</ul>
</li>
<li>数据的存储结构：存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。<br>包括数据元素的表示和关系的表示（<strong>存储数据时，不仅要存储各数据元素的值，也要存储数据元素之间的关系</strong>）<ul>
<li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中（如顺序表）<br>元素之间的关系由存储单元的邻接关系来体现。<ul>
<li>其优点是可以实现随机存取，每个元素占用最少的存储空间</li>
<li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。</li>
</ul>
</li>
<li>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，<br>借助指示元素存储地址的指针来表示元素之间的逻辑关系<ul>
<li>链式存储时，链式存储时各个不同结点的存储空间可以不连续，但结点内的存储单元地址一定连续</li>
<li>链式存储结构比顺序存储结构更能方便地表示各种逻辑结构</li>
<li>其优点是不会出现碎片现象，能充分利用所有存储单元</li>
<li>缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。</li>
</ul>
</li>
<li>索引存储：在存储元素信息的同时，还建立附加的索引表。<br>索引表中的每项称为索引项，索引项的一般形式是(关键字，地址)。<ul>
<li>其优点是检索速度快：缺点是附加的索引表额外占用存储空间。</li>
<li>增加和删除数据时也要修改索引表，因而会花费较多的时间。</li>
</ul>
</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hsh)存储。<ul>
<li>其优点是检索、增加和删除结点的操作都很快</li>
<li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。</li>
</ul>
</li>
</ul>
</li>
<li>数据的运算：施加在数据上的运算包括运算的定义和实现。<ul>
<li>运算的定义是针对逻辑结构的，指出运算的功能</li>
<li>运算的实现是针对存储结构的，指出运算的具体操作步骤。</li>
<li><strong>不是每种数据结构都具备三种基本运算：插入、删除和查找</strong><br><strong>如栈和队列无法查找，二维数组无法删除</strong></li>
</ul>
</li>
</ul>
<h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul>
<li>算法的概念：<strong>对特定问题求解步骤的一种描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li>
<li>五个重要特性<ul>
<li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li>
<li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li>
<li>可行性：算法中描述的操作都可以通过已经实现的基本运算<u>执行有限次</u>来实现。</li>
<li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li>
<li>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</li>
</ul>
</li>
<li>四个目标<ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，<br>这两者都与问题的规模有关。</li>
</ul>
</li>
</ul>
<h3 id="4-算法效率的度量（✪）"><a href="#4-算法效率的度量（✪）" class="headerlink" title="4.算法效率的度量（✪）"></a>4.算法效率的度量（✪）</h3><ul>
<li><p>时间复杂度</p>
<ul>
<li>一个语句的频度是指该语句在算法中<u>被重复执行的次数</u>。算法中所有语句的频度之和记为T(n)，<br><u>它是该算法问题规模n的函数</u>，时间复杂度主要分析T(n)的<u>数量级</u>，<strong>执行时间与时间复杂度的值成正比</strong>。</li>
<li>算法中基本运算（<strong>最深层循环内的语句</strong>）的频度与T(n)同数量级，<br><strong>因此通常采用算法中基本运算的频度f(n)来分析时间复杂度</strong>，$T ( n ) = O ( f ( n ) )$<ul>
<li>如此题中，问题规模始终都是n，执行时间与时间复杂度的值成正比，选C<ul>
<li><img src="https://s1.ax1x.com/2023/07/04/pCse6aQ.png" alt="pCse6aQ.png"></li>
</ul>
</li>
<li>此题可以反映时间复杂度是看问题规模的数量级（即看最高阶，抓大头选B）<ul>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsKhY4.png" alt="pCsKhY4.png"></li>
</ul>
</li>
<li>但是有两个变量的话就不一样了，如此题选C<ul>
<li><img src="https://s1.ax1x.com/2023/08/14/pPMMWOs.png" alt="pPMMWOs.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>算法的时间复杂度不仅依赖于问题的规模，也取决于待输入数据的性质（如输入数据元素的初始状态)</strong></li>
</ul>
</li>
<li><p>空间复杂度：算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。</p>
</li>
<li><p>关于时间复杂度的例题（♚）</p>
<ul>
<li>步骤：首先确定循环中变化的值，之后跟据其变化情况列出其经过每轮循环之后的值<br>（先用实数，最后写出规律式（含频数k）），之后并与问题规模n组成不等式，最后求出k关于n的表达式</li>
<li>例1<ul>
<li>此时写出i的变化规律：$1,2,4…2^{k},2^{k}=n,k=log_{2}n$</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsnQ0O.png" alt="pCsnQ0O.png"></li>
</ul>
</li>
<li>例2<ul>
<li>此时写出x的变化规律：$4,8,16…2^{k+1},2^{k+1}&lt;n/2,k=log_{2}n/2-1=log_{2}n-2$，此时即选A</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsu8bT.png" alt="pCsu8bT.png"></li>
</ul>
</li>
<li>例3<ul>
<li>此时有内外两层的循环，且外层循环的值决定了内层循环的次数，应该以外层为基准来看</li>
<li>外层执行第一轮(i=1)：最内层语句执行2次，外层执行第二轮(i=2)，最内层语句执行4次，<br>外层执行第三轮(i=3)，最内层语句执行6次，</li>
<li>此时有规律得（外层执行第n轮时，最内层语句执行2n次）总次数即为相加（求和公式(2+2n)*n/2)=n(n+1)）</li>
<li><img src="https://s1.ax1x.com/2023/07/04/pCsKneK.png" alt="pCsKneK.png"></li>
</ul>
</li>
<li><p>例4</p>
<ul>
<li><p>先看外层的循环取值</p>
</li>
<li><p>此时有$i=1,2,4……2^{k}&lt;n ，此时对应的内层总次数相加为1+2+……2^{k}=2^{k+1}-1&lt;2n$，时间复杂度为n</p>
</li>
<li><p><img src="https://s1.ax1x.com/2023/07/04/pCs3Arn.png" alt="pCs3Arn.png"></p>
</li>
</ul>
</li>
<li><p>例5</p>
<ul>
<li><p>此时有两层循环但是内层循环的次数不由外层循环的值确定，此时可以看做两个单独的循环，总次数即为此两次循环的积，选C</p>
</li>
<li><p><img src="https://s1.ax1x.com/2023/07/04/pCsKsln.png" alt="pCsKsln.png"></p>
</li>
</ul>
</li>
<li><p>例6</p>
<ul>
<li><p>将表达式简化后写出规律，i=0时，sum=1；i=1，sum=1+2，i=2，sum=1+2+3，则i=k时，sum=(1+k)k/2=n，此时选B</p>
</li>
<li><p><img src="https://s1.ax1x.com/2023/07/04/pCslT6s.png" alt="pCslT6s.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
